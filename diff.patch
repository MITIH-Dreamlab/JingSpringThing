diff --git a/data/public/js/components/visualization/core.js b/data/public/js/components/visualization/core.js
index 5d5cfee3..f1203c4d 100644
--- a/data/public/js/components/visualization/core.js
+++ b/data/public/js/components/visualization/core.js
@@ -28,6 +28,8 @@ export class WebXRVisualization {
 
         this.controls = null;
         this.animationFrameId = null;
+        this.lastPositionUpdate = 0;
+        this.positionUpdateThreshold = 16; // ~60fps for smooth updates
 
         // Get initial settings
         const settings = visualizationSettings.getSettings();
@@ -45,7 +47,7 @@ export class WebXRVisualization {
         // Initialize settings
         this.initializeSettings();
 
-        // Add event listeners for graph data and position updates
+        // Add event listeners for updates
         window.addEventListener('graphDataUpdated', (event) => {
             console.log('Received graphDataUpdated event:', event.detail);
             this.updateVisualization();
@@ -56,27 +58,79 @@ export class WebXRVisualization {
             this.updateSettings(event.detail);
         });
 
-        // Handle position updates from layout manager
-        window.addEventListener('positionUpdate', (event) => {
-            console.log('Received position update:', event.detail);
-            if (this.graphDataManager.websocketService) {
-                this.graphDataManager.websocketService.sendGraphMessage(event.detail);
+        // Add event listener for node position updates from server
+        window.addEventListener('nodePositionsUpdated', (event) => {
+            if (event.detail instanceof ArrayBuffer) {
+                this.handleBinaryPositionUpdate(event.detail);
             }
         });
 
-        // Handle incoming position updates from other clients
-        window.addEventListener('graphPositionsUpdated', (event) => {
-            console.log('Received position update from server:', event.detail);
-            const { positions } = event.detail;
-            if (this.layoutManager) {
-                this.layoutManager.applyPositionUpdates(positions);
-                this.nodeManager.updateNodePositions(positions);
-            }
+        // Add event listener for node drag events
+        window.addEventListener('nodeDragged', (event) => {
+            const { nodeId, position } = event.detail;
+            this.handleNodeDrag(nodeId, position);
         });
 
         console.log('WebXRVisualization constructor completed');
     }
 
+    handleBinaryPositionUpdate(buffer) {
+        const positions = new Float32Array(buffer);
+        const updates = [];
+        
+        // Each position update contains 6 float values (x,y,z, vx,vy,vz)
+        for (let i = 0; i < positions.length; i += 6) {
+            updates.push({
+                position: new THREE.Vector3(
+                    positions[i],
+                    positions[i + 1],
+                    positions[i + 2]
+                ),
+                velocity: new THREE.Vector3(
+                    positions[i + 3],
+                    positions[i + 4],
+                    positions[i + 5]
+                )
+            });
+        }
+
+        // Update node positions through the node manager
+        this.nodeManager.updateNodePositions(updates);
+    }
+
+    handleNodeDrag(nodeId, position) {
+        // Update local node position
+        this.nodeManager.updateNodePosition(nodeId, position);
+
+        // Send position update to server if enough time has passed
+        const now = Date.now();
+        if (now - this.lastPositionUpdate >= this.positionUpdateThreshold) {
+            this.lastPositionUpdate = now;
+            
+            // Get all node positions for synchronization
+            const positions = this.nodeManager.getNodePositions();
+            
+            // Create binary position data
+            const buffer = new ArrayBuffer(positions.length * 24); // 6 floats per node (x,y,z, vx,vy,vz)
+            const view = new Float32Array(buffer);
+            
+            positions.forEach((pos, index) => {
+                const offset = index * 6;
+                view[offset] = pos.position.x;
+                view[offset + 1] = pos.position.y;
+                view[offset + 2] = pos.position.z;
+                view[offset + 3] = pos.velocity.x;
+                view[offset + 4] = pos.velocity.y;
+                view[offset + 5] = pos.velocity.z;
+            });
+
+            // Dispatch binary position update
+            window.dispatchEvent(new CustomEvent('positionUpdate', {
+                detail: buffer
+            }));
+        }
+    }
+
     updateSettings(settings) {
         console.log('Updating settings:', settings);
         if (!settings) return;
@@ -172,8 +226,12 @@ export class WebXRVisualization {
 
     animate() {
         this.animationFrameId = requestAnimationFrame(this.animate.bind(this));
+        
+        // Update controls and layout
         this.controls.update();
+        this.layoutManager.update();
 
+        // Update visuals
         this.effectsManager.animate();
         this.nodeManager.updateLabelOrientations(this.camera);
         this.effectsManager.render();
diff --git a/data/public/js/components/visualization/layout.js b/data/public/js/components/visualization/layout.js
index 4ffb4963..9f7c3083 100644
--- a/data/public/js/components/visualization/layout.js
+++ b/data/public/js/components/visualization/layout.js
@@ -15,7 +15,8 @@ export class LayoutManager {
         this.lastPositions = null;       // Store previous positions for change detection
         this.updateThreshold = 0.001;    // Minimum position change to trigger update
         this.lastUpdateTime = 0;         // Last time positions were sent to server
-        this.updateInterval = 50;        // Minimum ms between position updates
+        this.updateInterval = 16;        // ~60fps for smooth updates
+        this.currentGraphData = null;    // Store current graph data
     }
 
     initializePositions(nodes) {
@@ -36,7 +37,7 @@ export class LayoutManager {
             if (!node.vz) node.vz = 0;
         });
 
-        // Initialize last positions
+        // Initialize last positions for change detection
         this.lastPositions = nodes.map(node => ({
             x: node.x,
             y: node.y,
@@ -44,7 +45,26 @@ export class LayoutManager {
         }));
     }
 
-    calculateSpringForce(pos1, pos2, mass1, mass2, isConnected) {
+    // Update position of a node (e.g., from VR interaction)
+    updateNodePosition(nodeId, position, nodes) {
+        const node = nodes.find(n => n.id === nodeId);
+        if (!node) return;
+
+        // Update node position
+        node.x = position.x;
+        node.y = position.y;
+        node.z = position.z;
+        
+        // Clear velocity since position was directly set
+        node.vx = 0;
+        node.vy = 0;
+        node.vz = 0;
+
+        // Send immediate update of all positions
+        this.sendPositionUpdates(nodes);
+    }
+
+    calculateSpringForce(pos1, pos2, mass1, mass2, isConnected, weight = 1.0) {
         const dx = pos2.x - pos1.x;
         const dy = pos2.y - pos1.y;
         const dz = pos2.z - pos1.z;
@@ -52,8 +72,10 @@ export class LayoutManager {
 
         let forceMagnitude;
         if (isConnected) {
-            forceMagnitude = this.forceDirectedSpring * (distance - this.naturalLength);
+            // Use edge weight to scale the spring force
+            forceMagnitude = this.forceDirectedSpring * (distance - this.naturalLength) * weight;
         } else {
+            // Use node masses for repulsion
             forceMagnitude = -this.forceDirectedSpring * mass1 * mass2 / (distance * distance + 0.1);
         }
 
@@ -68,6 +90,7 @@ export class LayoutManager {
     }
 
     applyForceDirectedLayout(graphData, onComplete) {
+        this.currentGraphData = graphData;
         const nodes = graphData.nodes;
         
         // Initialize positions if needed
@@ -79,18 +102,19 @@ export class LayoutManager {
         }
 
         // Perform a single iteration of force-directed layout
-        this.performLayout(graphData, this.updateIterations);
+        this.performLayout(graphData);
         
         if (onComplete) {
             onComplete();
         }
     }
 
-    performLayout(graphData, iterations) {
-        const nodes = graphData.nodes;
-        const edges = graphData.edges;
+    performLayout(graphData) {
+        const now = Date.now();
+        if (now - this.lastUpdateTime >= this.updateInterval) {
+            const nodes = graphData.nodes;
+            const edges = graphData.edges;
 
-        for (let iteration = 0; iteration < iterations; iteration++) {
             // Calculate forces between all nodes
             for (let i = 0; i < nodes.length; i++) {
                 for (let j = i + 1; j < nodes.length; j++) {
@@ -117,7 +141,8 @@ export class LayoutManager {
                     const force = this.calculateSpringForce(
                         source, target,
                         source.mass || 1, target.mass || 1,
-                        true
+                        true,
+                        edge.weight || 1.0
                     );
 
                     source.vx += force.fx;
@@ -129,13 +154,15 @@ export class LayoutManager {
                 }
             });
 
-            // Apply centering force and update positions
+            // Apply forces and update positions
             const maxVelocity = 10.0;
-            nodes.forEach(node => {
+            let hasChanges = false;
+
+            nodes.forEach((node, index) => {
                 // Centering force
                 const distance = Math.sqrt(node.x * node.x + node.y * node.y + node.z * node.z);
                 if (distance > this.targetRadius) {
-                    const centerForce = 0.05 * (distance - this.targetRadius); // Reduced strength
+                    const centerForce = 0.05 * (distance - this.targetRadius);
                     node.vx -= (node.x / distance) * centerForce;
                     node.vy -= (node.y / distance) * centerForce;
                     node.vz -= (node.z / distance) * centerForce;
@@ -155,60 +182,93 @@ export class LayoutManager {
                     node.vz *= scale;
                 }
 
-                // Update positions with smaller step size for smoother motion
+                // Update positions
+                const oldPos = this.lastPositions[index];
                 const stepSize = 0.5;
-                node.x += node.vx * stepSize;
-                node.y += node.vy * stepSize;
-                node.z += node.vz * stepSize;
-
-                // Ensure positions stay within bounds
-                const maxCoord = 100.0;
-                node.x = Math.max(Math.min(node.x, maxCoord), -maxCoord);
-                node.y = Math.max(Math.min(node.y, maxCoord), -maxCoord);
-                node.z = Math.max(Math.min(node.z, maxCoord), -maxCoord);
+                const newX = node.x + node.vx * stepSize;
+                const newY = node.y + node.vy * stepSize;
+                const newZ = node.z + node.vz * stepSize;
+
+                // Check if position changed significantly
+                if (Math.abs(newX - oldPos.x) > this.updateThreshold ||
+                    Math.abs(newY - oldPos.y) > this.updateThreshold ||
+                    Math.abs(newZ - oldPos.z) > this.updateThreshold) {
+                    hasChanges = true;
+                    
+                    // Update position with bounds checking
+                    const maxCoord = 100.0;
+                    node.x = Math.max(Math.min(newX, maxCoord), -maxCoord);
+                    node.y = Math.max(Math.min(newY, maxCoord), -maxCoord);
+                    node.z = Math.max(Math.min(newZ, maxCoord), -maxCoord);
+                    
+                    // Update last position
+                    oldPos.x = node.x;
+                    oldPos.y = node.y;
+                    oldPos.z = node.z;
+                }
             });
-        }
 
-        // Check if we should send position updates
-        const now = Date.now();
-        if (now - this.lastUpdateTime >= this.updateInterval) {
-            this.sendPositionUpdates(nodes);
-            this.lastUpdateTime = now;
+            // Send position updates if there were significant changes
+            if (hasChanges) {
+                this.sendPositionUpdates(nodes);
+                this.lastUpdateTime = now;
+            }
         }
     }
 
     sendPositionUpdates(nodes) {
-        if (!this.lastPositions) return;
+        // Create binary buffer for position updates
+        const buffer = new ArrayBuffer(nodes.length * 24); // 6 floats per node (x,y,z, vx,vy,vz)
+        const dataView = new DataView(buffer);
 
-        // Convert to array format for binary transmission
-        const positions = nodes.map((node, index) => {
-            const lastPos = this.lastPositions[index];
-            if (!lastPos) return [node.x, node.y, node.z];
+        nodes.forEach((node, index) => {
+            const offset = index * 24;
+            
+            // Position (vec3<f32>)
+            dataView.setFloat32(offset, node.x, true);
+            dataView.setFloat32(offset + 4, node.y, true);
+            dataView.setFloat32(offset + 8, node.z, true);
 
-            // Check if position has changed significantly
-            if (Math.abs(node.x - lastPos.x) > this.updateThreshold ||
-                Math.abs(node.y - lastPos.y) > this.updateThreshold ||
-                Math.abs(node.z - lastPos.z) > this.updateThreshold) {
-                
-                // Update last position
-                lastPos.x = node.x;
-                lastPos.y = node.y;
-                lastPos.z = node.z;
-                
-                return [node.x, node.y, node.z];
-            }
-            return [lastPos.x, lastPos.y, lastPos.z];
+            // Velocity (vec3<f32>)
+            dataView.setFloat32(offset + 12, node.vx || 0, true);
+            dataView.setFloat32(offset + 16, node.vy || 0, true);
+            dataView.setFloat32(offset + 20, node.vz || 0, true);
         });
 
-        // Send position update event
+        // Dispatch binary data event
         window.dispatchEvent(new CustomEvent('positionUpdate', {
-            detail: {
-                type: 'PositionUpdate',
-                positions: positions
-            }
+            detail: buffer
         }));
     }
 
+    // Handle incoming position updates from server
+    applyPositionUpdates(buffer) {
+        if (!this.lastPositions || !this.currentGraphData) return;
+
+        const dataView = new DataView(buffer);
+        const nodes = this.currentGraphData.nodes;
+
+        for (let i = 0; i < nodes.length; i++) {
+            const offset = i * 24;
+            const node = nodes[i];
+            
+            // Update position and velocity
+            node.x = dataView.getFloat32(offset, true);
+            node.y = dataView.getFloat32(offset + 4, true);
+            node.z = dataView.getFloat32(offset + 8, true);
+            node.vx = dataView.getFloat32(offset + 12, true);
+            node.vy = dataView.getFloat32(offset + 16, true);
+            node.vz = dataView.getFloat32(offset + 20, true);
+
+            // Update last positions
+            this.lastPositions[i] = {
+                x: node.x,
+                y: node.y,
+                z: node.z
+            };
+        }
+    }
+
     startContinuousSimulation(graphData) {
         if (this.isSimulating) return;
         
@@ -216,8 +276,8 @@ export class LayoutManager {
         const animate = () => {
             if (!this.isSimulating) return;
             
-            // Perform continuous gentle refinement
-            this.performLayout(graphData, 1);
+            // Send position updates at regular intervals
+            this.performLayout(graphData);
             this.animationFrameId = requestAnimationFrame(animate);
         };
         
@@ -242,28 +302,4 @@ export class LayoutManager {
                 break;
         }
     }
-
-    // Handle incoming position updates from server
-    applyPositionUpdates(positions) {
-        if (!this.lastPositions) return;
-
-        // Handle array-based format (new binary format)
-        if (Array.isArray(positions)) {
-            positions.forEach((position, index) => {
-                if (this.lastPositions[index]) {
-                    const [x, y, z] = position;
-                    this.lastPositions[index] = { x, y, z };
-                }
-            });
-        }
-        // Handle legacy object-based format
-        else if (typeof positions === 'object') {
-            Object.entries(positions).forEach(([index, position]) => {
-                const idx = parseInt(index);
-                if (this.lastPositions[idx]) {
-                    this.lastPositions[idx] = position;
-                }
-            });
-        }
-    }
 }
diff --git a/data/public/js/components/visualization/nodes.js b/data/public/js/components/visualization/nodes.js
index 8aa782b7..e3ddaa64 100644
--- a/data/public/js/components/visualization/nodes.js
+++ b/data/public/js/components/visualization/nodes.js
@@ -4,12 +4,9 @@ import * as THREE from 'three';
 export const BLOOM_LAYER = 1;
 export const NORMAL_LAYER = 0;
 
-export const NODE_COLORS = {
-    NEW: new THREE.Color(0x00ff88),      // Bright green for very recent files (< 3 days)
-    RECENT: new THREE.Color(0x4444ff),    // Blue for recent files (< 7 days)
-    MEDIUM: new THREE.Color(0xffaa00),    // Orange for medium-age files (< 30 days)
-    OLD: new THREE.Color(0xff4444)        // Red for old files (>= 30 days)
-};
+// Base colors for age interpolation
+const NEW_COLOR = new THREE.Color(0x00ff00); // Green for newest
+const OLD_COLOR = new THREE.Color(0xff0000); // Red for oldest
 
 export const NODE_SHAPES = {
     FEW_LINKS: 'sphere',      // 0-5 links
@@ -26,45 +23,155 @@ export class NodeManager {
         this.edgeMeshes = new Map();
         
         // Node settings
-        this.minNodeSize = 0.1;  // Minimum node size in visualization
-        this.maxNodeSize = 5;    // Maximum node size in visualization
-        this.nodeSizeScalingFactor = 1;  // Global scaling factor
+        this.minNodeSize = 0.1;
+        this.maxNodeSize = 5;
+        this.nodeSizeScalingFactor = 1;
         this.labelFontSize = 18;
-        this.nodeColor = new THREE.Color(0x4444ff);  // Initialize as THREE.Color
+        this.colorSaturation = 1.0;
+        this.colorBrightness = 1.0;
 
         // Edge settings
-        this.edgeColor = new THREE.Color(0x4444ff);  // Initialize as THREE.Color
+        this.edgeColor = new THREE.Color(0x4444ff);
         this.edgeOpacity = 0.6;
 
-        // Server-side node size range (must match constants in file_service.rs)
+        // Server-side node size range
         this.serverMinNodeSize = 5.0;
         this.serverMaxNodeSize = 50.0;
+
+        // Track oldest and newest dates for normalization
+        this.oldestDate = new Date().getTime();
+        this.newestDate = 0;
+    }
+
+    updateDateRange(nodes) {
+        let oldest = new Date().getTime();
+        let newest = 0;
+
+        nodes.forEach(node => {
+            const metadata = node.metadata || {};
+            const lastModified = new Date(metadata.last_modified || new Date()).getTime();
+            oldest = Math.min(oldest, lastModified);
+            newest = Math.max(newest, lastModified);
+        });
+
+        this.oldestDate = oldest;
+        this.newestDate = newest;
+    }
+
+    calculateNodeColor(lastModified) {
+        const timestamp = new Date(lastModified).getTime();
+        
+        // Normalize age to 0-1 range
+        const ageRange = this.newestDate - this.oldestDate;
+        const normalizedAge = ageRange === 0 ? 0 : 
+            (timestamp - this.oldestDate) / ageRange;
+
+        // Create interpolated color
+        const color = new THREE.Color();
+        color.copy(OLD_COLOR).lerp(NEW_COLOR, normalizedAge);
+
+        // Apply saturation and brightness
+        const hsl = {};
+        color.getHSL(hsl);
+        color.setHSL(
+            hsl.h, // Keep the interpolated hue
+            hsl.s * this.colorSaturation, // Apply saturation control
+            hsl.l * this.colorBrightness  // Apply brightness control
+        );
+
+        return color;
+    }
+
+    updateNodePositions(updates) {
+        updates.forEach((update, index) => {
+            const nodeId = Array.from(this.nodeMeshes.keys())[index];
+            if (!nodeId) return;
+
+            const mesh = this.nodeMeshes.get(nodeId);
+            const label = this.nodeLabels.get(nodeId);
+            
+            if (mesh) {
+                mesh.position.copy(update.position);
+                
+                if (label) {
+                    const size = mesh.geometry.parameters.radius || 
+                               mesh.geometry.parameters.width || 
+                               1;
+                    label.position.set(
+                        update.position.x,
+                        update.position.y + size + 2,
+                        update.position.z
+                    );
+                }
+
+                this.updateEdgesForNode(nodeId);
+            }
+        });
+    }
+
+    updateNodePosition(nodeId, position) {
+        const mesh = this.nodeMeshes.get(nodeId);
+        const label = this.nodeLabels.get(nodeId);
+        
+        if (mesh) {
+            mesh.position.copy(position);
+            
+            if (label) {
+                const size = mesh.geometry.parameters.radius || 
+                           mesh.geometry.parameters.width || 
+                           1;
+                label.position.set(
+                    position.x,
+                    position.y + size + 2,
+                    position.z
+                );
+            }
+
+            this.updateEdgesForNode(nodeId);
+        }
+    }
+
+    updateEdgesForNode(nodeId) {
+        this.edgeMeshes.forEach((line, edgeKey) => {
+            const [source, target] = edgeKey.split('-');
+            if (source === nodeId || target === nodeId) {
+                const positions = line.geometry.attributes.position.array;
+                const sourceMesh = this.nodeMeshes.get(source);
+                const targetMesh = this.nodeMeshes.get(target);
+
+                if (sourceMesh && targetMesh) {
+                    positions[0] = sourceMesh.position.x;
+                    positions[1] = sourceMesh.position.y;
+                    positions[2] = sourceMesh.position.z;
+                    positions[3] = targetMesh.position.x;
+                    positions[4] = targetMesh.position.y;
+                    positions[5] = targetMesh.position.z;
+                    line.geometry.attributes.position.needsUpdate = true;
+                }
+            }
+        });
+    }
+
+    getNodePositions() {
+        return Array.from(this.nodeMeshes.values()).map(mesh => ({
+            position: mesh.position.clone(),
+            velocity: new THREE.Vector3(0, 0, 0)
+        }));
     }
 
     getNodeSize(metadata) {
-        // Use the node_size from metadata if available
         if (metadata.node_size) {
-            // Convert from server's range (5.0-50.0) to visualization range (0.1-5.0)
             const serverSize = parseFloat(metadata.node_size);
-            const normalizedSize = (serverSize - this.serverMinNodeSize) / (this.serverMaxNodeSize - this.serverMinNodeSize);
-            return this.minNodeSize + (this.maxNodeSize - this.minNodeSize) * normalizedSize * this.nodeSizeScalingFactor;
+            const normalizedSize = (serverSize - this.serverMinNodeSize) / 
+                                 (this.serverMaxNodeSize - this.serverMinNodeSize);
+            return this.minNodeSize + 
+                   (this.maxNodeSize - this.minNodeSize) * 
+                   normalizedSize * 
+                   this.nodeSizeScalingFactor;
         }
-        
-        // Fallback to a default size if node_size is not available
         return this.minNodeSize;
     }
 
-    calculateNodeColor(lastModified) {
-        const now = Date.now();
-        const age = now - new Date(lastModified).getTime();
-        const dayInMs = 24 * 60 * 60 * 1000;
-        
-        if (age < 3 * dayInMs) return NODE_COLORS.NEW;        // Less than 3 days old
-        if (age < 7 * dayInMs) return NODE_COLORS.RECENT;     // Less than 7 days old
-        if (age < 30 * dayInMs) return NODE_COLORS.MEDIUM;    // Less than 30 days old
-        return NODE_COLORS.OLD;                               // 30 days or older
-    }
-
     createNodeGeometry(size, hyperlinkCount) {
         if (hyperlinkCount < 6) {
             return new THREE.SphereGeometry(size, 32, 32);
@@ -136,7 +243,6 @@ export class NodeManager {
     }
 
     centerNodes(nodes) {
-        // Calculate center of mass
         let centerX = 0, centerY = 0, centerZ = 0;
         nodes.forEach(node => {
             centerX += node.x;
@@ -147,21 +253,19 @@ export class NodeManager {
         centerY /= nodes.length;
         centerZ /= nodes.length;
 
-        // Subtract center from all positions to center around origin
         nodes.forEach(node => {
             node.x -= centerX;
             node.y -= centerY;
             node.z -= centerZ;
         });
 
-        // Scale positions to reasonable range
         const maxDist = nodes.reduce((max, node) => {
             const dist = Math.sqrt(node.x * node.x + node.y * node.y + node.z * node.z);
             return Math.max(max, dist);
         }, 0);
 
         if (maxDist > 0) {
-            const scale = 100 / maxDist; // Scale to fit in 100 unit radius
+            const scale = 100 / maxDist;
             nodes.forEach(node => {
                 node.x *= scale;
                 node.y *= scale;
@@ -173,9 +277,10 @@ export class NodeManager {
     updateNodes(nodes) {
         console.log(`Updating nodes: ${nodes.length}`);
         
-        // Center and scale nodes
-        this.centerNodes(nodes);
+        // Update date range for color normalization
+        this.updateDateRange(nodes);
         
+        this.centerNodes(nodes);
         const existingNodeIds = new Set(nodes.map(node => node.id));
 
         // Remove non-existent nodes
@@ -212,14 +317,15 @@ export class NodeManager {
                 const geometry = this.createNodeGeometry(size, hyperlinkCount);
                 const material = new THREE.MeshStandardMaterial({
                     color: color,
-                    metalness: 0.2,  // Reduced for more glow
-                    roughness: 0.2,  // Reduced for more glow
+                    metalness: 0.2,
+                    roughness: 0.2,
                     emissive: color,
-                    emissiveIntensity: 1.0  // Increased from 0.5 to 1.0 for stronger glow
+                    emissiveIntensity: 1.0
                 });
 
                 mesh = new THREE.Mesh(geometry, material);
                 mesh.layers.enable(BLOOM_LAYER);
+                mesh.userData.lastModified = lastModified; // Store for color updates
                 this.scene.add(mesh);
                 this.nodeMeshes.set(node.id, mesh);
 
@@ -231,7 +337,8 @@ export class NodeManager {
                 mesh.geometry = this.createNodeGeometry(size, hyperlinkCount);
                 mesh.material.color.copy(color);
                 mesh.material.emissive.copy(color);
-                mesh.material.emissiveIntensity = 1.0; // Ensure updated nodes also have strong glow
+                mesh.material.emissiveIntensity = 1.0;
+                mesh.userData.lastModified = lastModified;
             }
 
             mesh.position.set(node.x, node.y, node.z);
@@ -246,7 +353,6 @@ export class NodeManager {
         console.log(`Updating edges: ${edges.length}`);
         const existingEdgeKeys = new Set(edges.map(edge => `${edge.source}-${edge.target_node}`));
 
-        // Remove non-existent edges
         this.edgeMeshes.forEach((line, edgeKey) => {
             if (!existingEdgeKeys.has(edgeKey)) {
                 this.scene.remove(line);
@@ -254,7 +360,6 @@ export class NodeManager {
             }
         });
 
-        // Update or create edges
         edges.forEach(edge => {
             if (!edge.source || !edge.target_node) {
                 console.warn('Invalid edge data:', edge);
@@ -306,17 +411,27 @@ export class NodeManager {
     updateFeature(control, value) {
         console.log(`Updating feature: ${control} = ${value}`);
         switch (control) {
-            // Node features
-            case 'nodeColor':
-                if (typeof value === 'number' || typeof value === 'string') {
-                    this.nodeColor = new THREE.Color(value);
-                    this.nodeMeshes.forEach(mesh => {
-                        if (mesh.material) {
-                            mesh.material.color.copy(this.nodeColor);
-                            mesh.material.emissive.copy(this.nodeColor);
-                        }
-                    });
-                }
+            case 'nodeSaturation':
+                this.colorSaturation = value;
+                // Update all node colors
+                this.nodeMeshes.forEach((mesh) => {
+                    if (mesh.material && mesh.userData.lastModified) {
+                        const color = this.calculateNodeColor(mesh.userData.lastModified);
+                        mesh.material.color.copy(color);
+                        mesh.material.emissive.copy(color);
+                    }
+                });
+                break;
+            case 'nodeBrightness':
+                this.colorBrightness = value;
+                // Update all node colors
+                this.nodeMeshes.forEach((mesh) => {
+                    if (mesh.material && mesh.userData.lastModified) {
+                        const color = this.calculateNodeColor(mesh.userData.lastModified);
+                        mesh.material.color.copy(color);
+                        mesh.material.emissive.copy(color);
+                    }
+                });
                 break;
             case 'nodeSizeScalingFactor':
                 this.nodeSizeScalingFactor = value;
@@ -324,8 +439,6 @@ export class NodeManager {
             case 'labelFontSize':
                 this.labelFontSize = value;
                 break;
-
-            // Edge features
             case 'edgeColor':
                 if (typeof value === 'number' || typeof value === 'string') {
                     this.edgeColor = new THREE.Color(value);
@@ -347,90 +460,7 @@ export class NodeManager {
         }
     }
 
-    updateNodePositions(positions) {
-        // Handle array-based format (new binary format)
-        if (Array.isArray(positions)) {
-            positions.forEach((position, index) => {
-                const nodeId = Array.from(this.nodeMeshes.keys())[index];
-                if (!nodeId) return;
-
-                const mesh = this.nodeMeshes.get(nodeId);
-                const label = this.nodeLabels.get(nodeId);
-                
-                if (mesh) {
-                    const [x, y, z] = position;
-                    mesh.position.set(x, y, z);
-                    
-                    if (label) {
-                        const size = mesh.geometry.parameters.radius || 
-                                   mesh.geometry.parameters.width || 
-                                   1; // fallback size
-                        label.position.set(x, y + size + 2, z);
-                    }
-
-                    // Update connected edges
-                    this.updateEdgesForNode(nodeId);
-                }
-            });
-        }
-        // Handle legacy object-based format
-        else if (typeof positions === 'object') {
-            Object.entries(positions).forEach(([index, position]) => {
-                const nodeId = Array.from(this.nodeMeshes.keys())[index];
-                if (!nodeId) return;
-
-                const mesh = this.nodeMeshes.get(nodeId);
-                const label = this.nodeLabels.get(nodeId);
-                
-                if (mesh) {
-                    mesh.position.set(position.x, position.y, position.z);
-                    
-                    if (label) {
-                        const size = mesh.geometry.parameters.radius || 
-                                   mesh.geometry.parameters.width || 
-                                   1; // fallback size
-                        label.position.set(position.x, position.y + size + 2, position.z);
-                    }
-
-                    // Update connected edges
-                    this.updateEdgesForNode(nodeId);
-                }
-            });
-        }
-    }
-
-    // Helper method to update edges for a specific node
-    updateEdgesForNode(nodeId) {
-        this.edgeMeshes.forEach((line, edgeKey) => {
-            const [source, target] = edgeKey.split('-');
-            if (source === nodeId || target === nodeId) {
-                const positions = line.geometry.attributes.position.array;
-                const sourceMesh = this.nodeMeshes.get(source);
-                const targetMesh = this.nodeMeshes.get(target);
-
-                if (sourceMesh && targetMesh) {
-                    positions[0] = sourceMesh.position.x;
-                    positions[1] = sourceMesh.position.y;
-                    positions[2] = sourceMesh.position.z;
-                    positions[3] = targetMesh.position.x;
-                    positions[4] = targetMesh.position.y;
-                    positions[5] = targetMesh.position.z;
-                    line.geometry.attributes.position.needsUpdate = true;
-                }
-            }
-        });
-    }
-
-    getNodePositions() {
-        return Array.from(this.nodeMeshes.values()).map(mesh => [
-            mesh.position.x,
-            mesh.position.y,
-            mesh.position.z
-        ]);
-    }
-
     dispose() {
-        // Dispose node resources
         this.nodeMeshes.forEach(mesh => {
             if (mesh.geometry) mesh.geometry.dispose();
             if (mesh.material) mesh.material.dispose();
@@ -439,8 +469,6 @@ export class NodeManager {
             if (label.material.map) label.material.map.dispose();
             if (label.material) label.material.dispose();
         });
-
-        // Dispose edge resources
         this.edgeMeshes.forEach(line => {
             if (line.geometry) line.geometry.dispose();
             if (line.material) line.material.dispose();
diff --git a/data/public/js/services/graphDataManager.js b/data/public/js/services/graphDataManager.js
index 7cd1df06..1c062b06 100644
--- a/data/public/js/services/graphDataManager.js
+++ b/data/public/js/services/graphDataManager.js
@@ -13,15 +13,14 @@ export class GraphDataManager {
         this.graphData = null;
         this.forceDirectedParams = {
             iterations: 100,
-            repulsionStrength: 1.0,
-            attractionStrength: 0.01,
+            repulsion_strength: 1.0,
+            attraction_strength: 0.01,
             damping: 0.9
         };
         console.log('GraphDataManager initialized');
         
-        // Set up WebSocket message listeners
+        // Set up WebSocket graph update listener
         this.websocketService.on('graphUpdate', this.handleGraphUpdate.bind(this));
-        this.websocketService.on('gpuPositions', this.handleGPUPositions.bind(this));
     }
 
     /**
@@ -33,39 +32,7 @@ export class GraphDataManager {
     }
 
     /**
-     * Handles GPU-computed position updates from the server.
-     * @param {object} update - The position update data.
-     */
-    handleGPUPositions(update) {
-        if (!this.graphData || !this.graphData.nodes) {
-            console.error('Cannot apply GPU position update: No graph data exists');
-            return;
-        }
-
-        const { positions } = update;
-        
-        // Update node positions from GPU computation
-        this.graphData.nodes.forEach((node, index) => {
-            if (positions[index]) {
-                const [x, y, z] = positions[index];
-                node.x = x;
-                node.y = y;
-                node.z = z;
-                // Clear velocities since GPU is handling movement
-                node.vx = 0;
-                node.vy = 0;
-                node.vz = 0;
-            }
-        });
-
-        // Notify visualization of position updates
-        window.dispatchEvent(new CustomEvent('graphDataUpdated', { 
-            detail: this.graphData 
-        }));
-    }
-
-    /**
-     * Handles graph update messages.
+     * Handles incoming graph update messages.
      * @param {object} data - The received graph data.
      */
     handleGraphUpdate(data) {
@@ -162,6 +129,14 @@ export class GraphDataManager {
 
         console.log(`Graph data updated: ${this.graphData.nodes.length} nodes, ${this.graphData.edges.length} edges`);
         
+        // Log some sample data
+        if (this.graphData.nodes.length > 0) {
+            console.log('Sample node:', this.graphData.nodes[0]);
+        }
+        if (this.graphData.edges.length > 0) {
+            console.log('Sample edge:', this.graphData.edges[0]);
+        }
+        
         // Dispatch an event to notify that the graph data has been updated
         window.dispatchEvent(new CustomEvent('graphDataUpdated', { detail: this.graphData }));
     }
@@ -199,14 +174,16 @@ export class GraphDataManager {
         console.log(`Updating force-directed parameter: ${name} = ${value}`);
         const paramMap = {
             'iterations': 'iterations',
-            'repulsionStrength': 'repulsionStrength',
-            'attractionStrength': 'attractionStrength'
+            'repulsion_strength': 'repulsion_strength',
+            'attraction_strength': 'attraction_strength'
         };
 
         const serverParamName = paramMap[name];
         if (serverParamName) {
             this.forceDirectedParams[serverParamName] = value;
             console.log('Force-directed parameters updated:', this.forceDirectedParams);
+            
+            // Request server recalculation with new parameters
             this.recalculateLayout();
         } else {
             console.warn(`Unknown force-directed parameter: ${name}`);
@@ -223,7 +200,8 @@ export class GraphDataManager {
                 type: 'recalculateLayout',
                 params: {
                     iterations: this.forceDirectedParams.iterations,
-                    springStrength: this.forceDirectedParams.attractionStrength,
+                    repulsion_strength: this.forceDirectedParams.repulsion_strength,
+                    attraction_strength: this.forceDirectedParams.attraction_strength,
                     damping: this.forceDirectedParams.damping
                 }
             });
diff --git a/data/public/js/services/websocketService.js b/data/public/js/services/websocketService.js
index 7cce19ed..79d86a73 100644
--- a/data/public/js/services/websocketService.js
+++ b/data/public/js/services/websocketService.js
@@ -1,4 +1,6 @@
 // WebSocket service for handling real-time communication
+import pako from 'pako';
+
 export default class WebsocketService {
     constructor() {
         // Initialize with environment variables from .env_template
@@ -32,18 +34,10 @@ export default class WebsocketService {
         this.audioQueue = [];
         this.isPlaying = false;
         
-        // Force-directed parameters
-        this.forceDirectedParams = {
-            iterations: 100,
-            attraction_strength: 0.01,
-            damping: 0.9
-        };
-        
         this.connect();
     }
 
     getWebSocketUrl() {
-        // Always use wss:// since nginx is handling SSL on 8443
         const host = window.location.hostname;
         return `wss://${host}:8443/ws`;
     }
@@ -52,44 +46,30 @@ export default class WebsocketService {
         const url = this.getWebSocketUrl();
         console.log('Attempting to connect to WebSocket at:', url);
         this.socket = new WebSocket(url);
+        this.socket.binaryType = 'arraybuffer';
 
         this.socket.onopen = () => {
             console.log('WebSocket connection established');
             this.reconnectAttempts = 0;
             this.emit('open');
             
-            // Request initial graph data and settings
             console.log('Requesting initial data');
             this.send({ type: 'getInitialData' });
         };
 
         this.socket.onmessage = async (event) => {
             try {
-                // Handle binary messages (GPU position updates)
-                if (event.data instanceof Blob) {
-                    const arrayBuffer = await event.data.arrayBuffer();
-                    const positions = new Float32Array(arrayBuffer);
-                    const positionArray = [];
-                    
-                    // Each position is 3 float values (x, y, z)
-                    for (let i = 0; i < positions.length; i += 3) {
-                        positionArray.push([
-                            positions[i],
-                            positions[i + 1],
-                            positions[i + 2]
-                        ]);
-                    }
-                    
-                    this.emit('gpuPositions', {
-                        positions: positionArray
-                    });
-                    return;
+                if (event.data instanceof ArrayBuffer) {
+                    // Handle binary position updates
+                    window.dispatchEvent(new CustomEvent('nodePositionsUpdated', {
+                        detail: event.data
+                    }));
+                } else {
+                    // Handle JSON messages
+                    const data = JSON.parse(event.data);
+                    console.log('Received JSON message:', data);
+                    this.handleServerMessage(data);
                 }
-
-                // Handle JSON messages
-                const data = JSON.parse(event.data);
-                console.log('Received message:', data);
-                this.handleServerMessage(data);
             } catch (error) {
                 console.error('Error processing WebSocket message:', error);
                 console.error('Raw message:', event.data);
@@ -126,8 +106,14 @@ export default class WebsocketService {
 
     send(data) {
         if (this.socket && this.socket.readyState === WebSocket.OPEN) {
-            console.log('Sending WebSocket message:', data);
-            this.socket.send(JSON.stringify(data));
+            if (data instanceof ArrayBuffer) {
+                // Send binary data directly
+                this.socket.send(data);
+            } else {
+                // Send JSON data
+                console.log('Sending WebSocket message:', data);
+                this.socket.send(JSON.stringify(data));
+            }
         } else {
             console.warn('WebSocket is not open. Unable to send message:', data);
             this.emit('error', { type: 'send_error', message: 'WebSocket is not open' });
@@ -170,10 +156,8 @@ export default class WebsocketService {
     handleServerMessage(data) {
         console.log('Handling server message:', data);
         
-        // First emit the raw message for any listeners that need it
         this.emit('message', data);
         
-        // Then handle specific message types
         switch (data.type) {
             case 'getInitialData':
                 console.log('Received initial data:', data);
@@ -183,20 +167,16 @@ export default class WebsocketService {
                 }
                 if (data.settings) {
                     console.log('Dispatching server settings:', data.settings);
-                    // Clean up color values before dispatching
                     if (data.settings.visualization) {
                         const viz = data.settings.visualization;
-                        // Convert color values to proper hex format
                         ['nodeColor', 'edgeColor', 'hologramColor'].forEach(key => {
                             if (viz[key]) {
-                                // Remove quotes and 0x prefix, ensure proper hex format
-                                let color = viz[key].replace(/['"]/g, '');  // Remove quotes
+                                let color = viz[key].replace(/['"]/g, '');
                                 if (color.startsWith('0x')) {
-                                    color = color.slice(2);  // Remove 0x prefix
+                                    color = color.slice(2);
                                 } else if (color.startsWith('#')) {
-                                    color = color.slice(1);  // Remove # prefix
+                                    color = color.slice(1);
                                 }
-                                // Ensure 6 characters for hex color
                                 color = color.padStart(6, '0');
                                 viz[key] = '#' + color;
                             }
@@ -210,15 +190,15 @@ export default class WebsocketService {
                 }
                 break;
                 
-            case 'graphUpdate':
+            case 'graph_update':
                 console.log('Received graph update:', data.graph_data);
                 if (data.graph_data) {
                     this.emit('graphUpdate', { graphData: data.graph_data });
                 }
                 break;
                 
-            case 'audioData':
-                this.handleAudioData(data.audio_data);
+            case 'audio':
+                this.handleAudioData(data.audio);
                 break;
                 
             case 'answer':
@@ -238,14 +218,13 @@ export default class WebsocketService {
                 this.emit('openaiResponse', data.response);
                 break;
                 
-            case 'simulationModeSet':
+            case 'simulation_mode_set':
                 console.log('Simulation mode set:', data.mode);
                 this.emit('simulationModeSet', data.mode);
                 break;
 
-            case 'fisheyeSettingsUpdated':
+            case 'fisheye_settings_updated':
                 console.log('Fisheye settings updated:', data);
-                // Convert focus_point to focusPoint for client-side consistency
                 const settings = {
                     enabled: data.enabled,
                     strength: data.strength,
@@ -376,13 +355,12 @@ export default class WebsocketService {
         this.send({
             type: 'chatMessage',
             message,
-            use_openai: useOpenAI
+            tts_provider: useOpenAI ? 'openai' : 'sonata'
         });
     }
 
     updateFisheyeSettings(settings) {
         console.log('Updating fisheye settings:', settings);
-        // Convert focusPoint to focus_point to match Rust struct field name
         const focus_point = settings.focusPoint || [0, 0, 0];
         this.send({
             type: 'updateFisheyeSettings',
diff --git a/src/config.rs b/src/config.rs
index ca726187..bf9d1547 100644
--- a/src/config.rs
+++ b/src/config.rs
@@ -256,7 +256,6 @@ impl fmt::Display for VisualizationSettings {
 #[cfg(test)]
 mod tests {
     use super::*;
-    use crate::models::simulation_params::{SimulationParams, SimulationPhase};
 
     #[test]
     fn test_simulation_params_from_config() {
@@ -277,63 +276,39 @@ mod tests {
             force_directed_damping: 0.8,
         };
 
-        let params = SimulationParams::from_config(&config, SimulationPhase::Initial);
+        let params = crate::models::simulation_params::SimulationParams::from_config(&config);
         assert_eq!(params.iterations, 100);
-        assert_eq!(params.spring_strength, 0.1);
         assert_eq!(params.repulsion_strength, 1000.0);
         assert_eq!(params.attraction_strength, 0.01);
         assert_eq!(params.damping, 0.8);
-        assert!(params.is_initial_layout);
     }
 
     #[test]
     fn test_simulation_params_clamping() {
-        let params = SimulationParams::new(
-            5,
-            0.0001, // spring_strength
-            0.5,    // repulsion_strength
-            0.0001, // attraction_strength
-            0.3,    // damping
-            false   // is_initial
-        );
-        assert_eq!(params.iterations, 5);
-        assert_eq!(params.spring_strength, 0.001); // Clamped to min
-        assert_eq!(params.repulsion_strength, 1.0); // Clamped to min
-        assert_eq!(params.attraction_strength, 0.001); // Clamped to min
-        assert_eq!(params.damping, 0.5); // Clamped to min
-        assert!(!params.is_initial_layout);
+        let params = crate::models::simulation_params::SimulationParams::new(5, 50.0, 0.001, 0.05);
+        assert_eq!(params.iterations, 10); // Clamped to min
+        assert_eq!(params.repulsion_strength, 100.0); // Clamped to min
+        assert_eq!(params.attraction_strength, 0.01); // Clamped to min
+        assert_eq!(params.damping, 0.1); // Clamped to min
 
-        let params = SimulationParams::new(
-            1000,
-            2.0,     // spring_strength
-            20000.0, // repulsion_strength
-            2.0,     // attraction_strength
-            1.0,     // damping
-            true     // is_initial
-        );
+        let params = crate::models::simulation_params::SimulationParams::new(1000, 10000.0, 2.0, 1.0);
         assert_eq!(params.iterations, 500); // Clamped to max
-        assert_eq!(params.spring_strength, 1.0); // Clamped to max
-        assert_eq!(params.repulsion_strength, 10000.0); // Clamped to max
+        assert_eq!(params.repulsion_strength, 5000.0); // Clamped to max
         assert_eq!(params.attraction_strength, 1.0); // Clamped to max
-        assert_eq!(params.damping, 0.95); // Clamped to max
-        assert!(params.is_initial_layout);
+        assert_eq!(params.damping, 0.9); // Clamped to max
     }
 
     #[test]
     fn test_simulation_params_builder() {
-        let params = SimulationParams::default()
+        let params = crate::models::simulation_params::SimulationParams::default()
             .with_iterations(200)
-            .with_spring_strength(0.5)
-            .with_repulsion_strength(5000.0)
-            .with_attraction_strength(0.05)
-            .with_damping(0.7)
-            .with_time_step(0.8);
+            .with_repulsion(2000.0)
+            .with_attraction(0.05)
+            .with_damping(0.7);
 
-        assert_eq!(params.iterations, 10); // Clamped to interactive max since not initial
-        assert_eq!(params.spring_strength, 0.5);
-        assert_eq!(params.repulsion_strength, 5000.0);
+        assert_eq!(params.iterations, 200);
+        assert_eq!(params.repulsion_strength, 2000.0);
         assert_eq!(params.attraction_strength, 0.05);
         assert_eq!(params.damping, 0.7);
-        assert_eq!(params.time_step, 0.8);
     }
 }
diff --git a/src/models/position_update.rs b/src/models/position_update.rs
deleted file mode 100644
index ec6d58fc..00000000
--- a/src/models/position_update.rs
+++ /dev/null
@@ -1,70 +0,0 @@
-use serde::{Serialize, Deserialize};
-use std::collections::HashMap;
-
-/// Represents a minimal position update for a node
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub struct NodePosition {
-    pub x: f32,
-    pub y: f32,
-    pub z: f32,
-}
-
-/// Represents a batch of position updates for multiple nodes
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub struct PositionUpdate {
-    /// Maps node indices to their new positions
-    pub positions: HashMap<usize, NodePosition>,
-    /// Optional timestamp for synchronization
-    pub timestamp: Option<u64>,
-}
-
-impl PositionUpdate {
-    pub fn new() -> Self {
-        Self {
-            positions: HashMap::new(),
-            timestamp: Some(std::time::SystemTime::now()
-                .duration_since(std::time::UNIX_EPOCH)
-                .unwrap()
-                .as_millis() as u64),
-        }
-    }
-
-    /// Adds a position update for a node
-    pub fn add_position(&mut self, index: usize, x: f32, y: f32, z: f32) {
-        self.positions.insert(index, NodePosition { x, y, z });
-    }
-
-    /// Creates a position update from changes only
-    pub fn from_changes(old_positions: &[(f32, f32, f32)], new_positions: &[(f32, f32, f32)]) -> Self {
-        let mut update = Self::new();
-        
-        for (i, (old, new)) in old_positions.iter().zip(new_positions.iter()).enumerate() {
-            if (old.0 - new.0).abs() > 0.001 || 
-               (old.1 - new.1).abs() > 0.001 || 
-               (old.2 - new.2).abs() > 0.001 {
-                update.add_position(i, new.0, new.1, new.2);
-            }
-        }
-        
-        update
-    }
-}
-
-/// Message types for WebSocket communication
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub enum GraphMessage {
-    /// Complete graph initialization
-    InitialGraph {
-        nodes: Vec<String>,  // Node IDs only
-        edges: Vec<(String, String, f32)>,  // (source, target, weight)
-        metadata: serde_json::Value,
-    },
-    /// Position updates only
-    PositionUpdate(PositionUpdate),
-    /// Parameter updates
-    ParameterUpdate {
-        spring_strength: Option<f32>,
-        damping: Option<f32>,
-        iterations: Option<u32>,
-    },
-}
diff --git a/src/models/simulation_params.rs b/src/models/simulation_params.rs
index f430edc3..d1a4e775 100644
--- a/src/models/simulation_params.rs
+++ b/src/models/simulation_params.rs
@@ -16,57 +16,50 @@ pub enum SimulationPhase {
 }
 
 /// Parameters controlling the force-directed graph layout simulation
-#[derive(Serialize, Deserialize, Clone, Debug)]
+#[derive(Serialize, Deserialize)]
 #[repr(C)]
 pub struct SimulationParams {
     pub iterations: u32,           // Range: 1-500, Default: varies by phase
-    pub spring_strength: f32,      // Range: 0.001-1.0, Default: 0.01
-    pub repulsion_strength: f32,   // Range: 1.0-10000.0, Default: 1000.0
-    pub attraction_strength: f32,  // Range: 0.001-1.0, Default: 0.01
+    pub spring_strength: f32,      // Range: 0.001-1.0, Default: 0.01 (reduced for stability)
     pub damping: f32,             // Range: 0.5-0.95, Default: 0.8
-    pub is_initial_layout: bool,   // true for initial layout, false for interactive
+    pub is_initial_layout: u32,   // 1 for initial layout, 0 for interactive
     pub time_step: f32,           // Animation time step (0.1-1.0)
-    pub padding: u32,             // Complete 32-byte alignment
+    pub padding2: u32,            // Padding for alignment
+    pub padding3: u32,            // Padding for alignment
+    pub padding4: u32,            // Complete 32-byte alignment
 }
 
 impl Default for SimulationParams {
     fn default() -> Self {
         Self {
-            iterations: 5,
-            spring_strength: 0.01,
-            repulsion_strength: 1000.0,
-            attraction_strength: 0.01,
-            damping: 0.8,
-            is_initial_layout: false,
-            time_step: 0.5,
-            padding: 0,
+            iterations: 5,          // Default to interactive mode iterations
+            spring_strength: 0.01,  // Reduced default strength for better stability
+            damping: 0.8,          // Balanced damping for smooth movement
+            is_initial_layout: 0,   // Default to interactive mode
+            time_step: 0.5,        // Reduced time step for smoother animation
+            padding2: 0,
+            padding3: 0,
+            padding4: 0,
         }
     }
 }
 
 impl SimulationParams {
     /// Creates new simulation parameters with validation
-    pub fn new(
-        iterations: u32,
-        spring_strength: f32,
-        repulsion_strength: f32,
-        attraction_strength: f32,
-        damping: f32,
-        is_initial: bool
-    ) -> Self {
+    pub fn new(iterations: u32, spring_strength: f32, damping: f32, is_initial: bool) -> Self {
         Self {
             iterations: if is_initial { 
                 iterations.clamp(200, 500) // More iterations for initial layout
             } else {
                 iterations.clamp(1, 10)    // Fewer iterations for interactive updates
             },
-            spring_strength: spring_strength.clamp(0.001, 1.0),
-            repulsion_strength: repulsion_strength.clamp(1.0, 10000.0),
-            attraction_strength: attraction_strength.clamp(0.001, 1.0),
-            damping: damping.clamp(0.5, 0.95),
-            is_initial_layout: is_initial,
-            time_step: 0.5,
-            padding: 0,
+            spring_strength: spring_strength.clamp(0.001, 1.0), // Reduced range for better control
+            damping: damping.clamp(0.5, 0.95), // Increased minimum damping for stability
+            is_initial_layout: if is_initial { 1 } else { 0 },
+            time_step: 0.5, // Default to moderate time step
+            padding2: 0,
+            padding3: 0,
+            padding4: 0,
         }
     }
 
@@ -76,8 +69,6 @@ impl SimulationParams {
         Self::new(
             if is_initial { config.force_directed_iterations } else { 5 },
             config.force_directed_spring,
-            config.force_directed_repulsion,
-            config.force_directed_attraction,
             config.force_directed_damping,
             is_initial
         )
@@ -85,7 +76,7 @@ impl SimulationParams {
 
     /// Updates iterations with phase-appropriate validation
     pub fn with_iterations(mut self, iterations: u32) -> Self {
-        self.iterations = if self.is_initial_layout {
+        self.iterations = if self.is_initial_layout == 1 {
             iterations.clamp(200, 500)
         } else {
             iterations.clamp(1, 10)
@@ -99,18 +90,6 @@ impl SimulationParams {
         self
     }
 
-    /// Updates repulsion strength with validation
-    pub fn with_repulsion_strength(mut self, strength: f32) -> Self {
-        self.repulsion_strength = strength.clamp(1.0, 10000.0);
-        self
-    }
-
-    /// Updates attraction strength with validation
-    pub fn with_attraction_strength(mut self, strength: f32) -> Self {
-        self.attraction_strength = strength.clamp(0.001, 1.0);
-        self
-    }
-
     /// Updates damping with validation
     pub fn with_damping(mut self, damping: f32) -> Self {
         self.damping = damping.clamp(0.5, 0.95);
@@ -125,8 +104,26 @@ impl SimulationParams {
 }
 
 // Manual implementations for required GPU traits
+impl Clone for SimulationParams {
+    fn clone(&self) -> Self {
+        *self
+    }
+}
+
 impl Copy for SimulationParams {}
 
+impl std::fmt::Debug for SimulationParams {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        f.debug_struct("SimulationParams")
+            .field("iterations", &self.iterations)
+            .field("spring_strength", &self.spring_strength)
+            .field("damping", &self.damping)
+            .field("is_initial_layout", &self.is_initial_layout)
+            .field("time_step", &self.time_step)
+            .finish()
+    }
+}
+
 // SAFETY: This type is #[repr(C)], contains only Pod types (u32 and f32),
 // and has explicit padding for proper alignment. All bit patterns are valid.
 unsafe impl bytemuck::Pod for SimulationParams {}
@@ -143,29 +140,26 @@ mod tests {
         let params = SimulationParams::default();
         assert_eq!(params.iterations, 5);
         assert_eq!(params.spring_strength, 0.01);
-        assert_eq!(params.repulsion_strength, 1000.0);
-        assert_eq!(params.attraction_strength, 0.01);
         assert_eq!(params.damping, 0.8);
-        assert!(!params.is_initial_layout);
+        assert_eq!(params.is_initial_layout, 0);
+        assert_eq!(params.time_step, 0.5);
     }
 
     #[test]
     fn test_simulation_params_validation() {
-        let params = SimulationParams::new(20, 0.0001, 0.5, 0.0001, 0.3, false);
+        // Test interactive mode limits
+        let params = SimulationParams::new(20, 0.0001, 0.3, false);
         assert_eq!(params.iterations, 10); // Clamped to interactive max
         assert_eq!(params.spring_strength, 0.001); // Clamped to min
-        assert_eq!(params.repulsion_strength, 1.0); // Clamped to min
-        assert_eq!(params.attraction_strength, 0.001); // Clamped to min
         assert_eq!(params.damping, 0.5); // Clamped to min
-        assert!(!params.is_initial_layout);
+        assert_eq!(params.is_initial_layout, 0);
 
-        let params = SimulationParams::new(600, 2.0, 20000.0, 2.0, 1.0, true);
+        // Test initial layout mode limits
+        let params = SimulationParams::new(600, 2.0, 1.0, true);
         assert_eq!(params.iterations, 500); // Clamped to max
         assert_eq!(params.spring_strength, 1.0); // Clamped to max
-        assert_eq!(params.repulsion_strength, 10000.0); // Clamped to max
-        assert_eq!(params.attraction_strength, 1.0); // Clamped to max
         assert_eq!(params.damping, 0.95); // Clamped to max
-        assert!(params.is_initial_layout);
+        assert_eq!(params.is_initial_layout, 1);
     }
 
     #[test]
@@ -173,15 +167,11 @@ mod tests {
         let params = SimulationParams::default()
             .with_iterations(200)
             .with_spring_strength(0.5)
-            .with_repulsion_strength(5000.0)
-            .with_attraction_strength(0.05)
             .with_damping(0.7)
             .with_time_step(0.8);
 
         assert_eq!(params.iterations, 10); // Clamped to interactive max
         assert_eq!(params.spring_strength, 0.5);
-        assert_eq!(params.repulsion_strength, 5000.0);
-        assert_eq!(params.attraction_strength, 0.05);
         assert_eq!(params.damping, 0.7);
         assert_eq!(params.time_step, 0.8);
     }
diff --git a/src/services/graph_service.rs b/src/services/graph_service.rs
index c003f741..eca019e3 100644
--- a/src/services/graph_service.rs
+++ b/src/services/graph_service.rs
@@ -55,14 +55,17 @@ impl GraphService {
         for (file_name, file_metadata) in &metadata {
             let source_id = file_name.trim_end_matches(".md").to_string();
             
+            // Look through all references in topic_counts
             for (target_id, reference_count) in &file_metadata.topic_counts {
                 if source_id != *target_id {
+                    // Create a canonical edge key (alphabetically ordered)
                     let edge_key = if source_id < *target_id {
                         (source_id.clone(), target_id.clone())
                     } else {
                         (target_id.clone(), source_id.clone())
                     };
 
+                    // Update edge weight
                     edge_map.entry(edge_key)
                         .and_modify(|weight| *weight += *reference_count as f32)
                         .or_insert(*reference_count as f32);
@@ -76,26 +79,31 @@ impl GraphService {
         }).collect();
         
         info!("Graph data built with {} nodes and {} edges", graph.nodes.len(), graph.edges.len());
+        debug!("Sample node data: {:?}", graph.nodes.first());
+        debug!("Sample edge data: {:?}", graph.edges.first());
 
-        // Calculate initial layout
+        // Calculate layout using GPU if available, otherwise fall back to CPU
         let settings = app_state.settings.read().await;
         let params = SimulationParams::new(
             settings.visualization.force_directed_iterations as u32,
             settings.visualization.force_directed_spring,
-            settings.visualization.force_directed_repulsion,
-            settings.visualization.force_directed_attraction,
             settings.visualization.force_directed_damping,
             true // Initial layout
         );
 
         Self::calculate_layout(&app_state.gpu_compute, &mut graph, &params).await?;
         
+        debug!("Final sample node data after layout calculation: {:?}", graph.nodes.first());
+        
         Ok(graph)
     }
 
+    /// Initializes random positions for nodes in a spherical distribution
     fn initialize_random_positions(graph: &mut GraphData) {
         use rand::Rng;
         let mut rng = rand::thread_rng();
+        
+        // Use a smaller initial radius to prevent nodes from spreading too far
         let initial_radius = 30.0;
         
         for node in &mut graph.nodes {
@@ -106,57 +114,63 @@ impl GraphService {
             node.x = r * theta.cos() * phi.sin();
             node.y = r * theta.sin() * phi.sin();
             node.z = r * phi.cos();
+            
+            // Initialize velocities to 0
             node.vx = 0.0;
             node.vy = 0.0;
             node.vz = 0.0;
         }
     }
 
+    /// Calculates the force-directed layout using GPUCompute if available, otherwise falls back to CPU.
     pub async fn calculate_layout(
         gpu_compute: &Option<Arc<RwLock<GPUCompute>>>,
         graph: &mut GraphData,
         params: &SimulationParams,
     ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
+        // Initialize random positions before layout calculation
+        Self::initialize_random_positions(graph);
+        
         match gpu_compute {
             Some(gpu) => {
                 info!("Using GPU for layout calculation");
                 let mut gpu_compute = gpu.write().await;
-                
-                // Only initialize positions for new graphs
-                if graph.nodes.iter().all(|n| n.x == 0.0 && n.y == 0.0 && n.z == 0.0) {
-                    Self::initialize_random_positions(graph);
-                }
-                
                 gpu_compute.update_graph_data(graph)?;
                 gpu_compute.update_simulation_params(params)?;
                 
-                // Run iterations with more frequent updates
-                for _ in 0..params.iterations {
+                // Run multiple iterations with position updates
+                for i in 0..params.iterations {
                     gpu_compute.step()?;
                     
-                    // Update positions every iteration for smoother motion
-                    let updated_nodes = gpu_compute.get_node_positions().await?;
-                    for (i, node) in graph.nodes.iter_mut().enumerate() {
-                        node.update_from_gpu_node(&updated_nodes[i]);
-                        
-                        // Apply bounds
-                        let max_coord = 100.0;
-                        node.x = node.x.clamp(-max_coord, max_coord);
-                        node.y = node.y.clamp(-max_coord, max_coord);
-                        node.z = node.z.clamp(-max_coord, max_coord);
+                    // Update positions every few iterations to maintain stability
+                    if i % 10 == 0 {
+                        let updated_nodes = gpu_compute.get_node_positions().await?;
+                        for (i, node) in graph.nodes.iter_mut().enumerate() {
+                            node.update_from_gpu_node(&updated_nodes[i]);
+                            
+                            // Add bounds checking
+                            let max_coord = 100.0;
+                            node.x = node.x.clamp(-max_coord, max_coord);
+                            node.y = node.y.clamp(-max_coord, max_coord);
+                            node.z = node.z.clamp(-max_coord, max_coord);
+                        }
                     }
                 }
+                
+                debug!("GPU layout calculation complete. Sample updated node: {:?}", graph.nodes.first());
             },
             None => {
                 warn!("GPU not available. Falling back to CPU-based layout calculation.");
                 Self::calculate_layout_cpu(graph, params.iterations, params.spring_strength, params.damping);
+                debug!("CPU layout calculation complete. Sample updated node: {:?}", graph.nodes.first());
             }
         }
         Ok(())
     }
 
+    /// Calculates the force-directed layout using CPU.
     fn calculate_layout_cpu(graph: &mut GraphData, iterations: u32, spring_strength: f32, damping: f32) {
-        let repulsion_strength = spring_strength * 10000.0;
+        let repulsion_strength = spring_strength * 10000.0; // Increase repulsion for better spacing
         
         for _ in 0..iterations {
             // Calculate repulsive forces
@@ -171,6 +185,7 @@ impl GraphService {
                     let fy = force * dy / distance;
                     let fz = force * dz / distance;
 
+                    // Apply force with a maximum limit
                     let max_force = 50.0;
                     let force_magnitude = (fx * fx + fy * fy + fz * fz).sqrt();
                     let scale = if force_magnitude > max_force {
@@ -197,11 +212,13 @@ impl GraphService {
                 let dz = graph.nodes[target].z - graph.nodes[source].z;
                 let distance = (dx * dx + dy * dy + dz * dz).sqrt().max(0.1);
                 
+                // Use spring strength and weight for attraction
                 let force = spring_strength * distance * edge.weight;
                 let fx = force * dx / distance;
                 let fy = force * dy / distance;
                 let fz = force * dz / distance;
 
+                // Apply force with a maximum limit
                 let max_force = 50.0;
                 let force_magnitude = (fx * fx + fy * fy + fz * fz).sqrt();
                 let scale = if force_magnitude > max_force {
@@ -218,8 +235,9 @@ impl GraphService {
                 graph.nodes[target].vz -= fz * scale;
             }
 
-            // Update positions
+            // Update positions with bounds checking
             for node in &mut graph.nodes {
+                // Apply velocity limits
                 let max_velocity = 10.0;
                 let velocity_magnitude = (node.vx * node.vx + node.vy * node.vy + node.vz * node.vz).sqrt();
                 if velocity_magnitude > max_velocity {
@@ -229,15 +247,18 @@ impl GraphService {
                     node.vz *= scale;
                 }
 
+                // Update position
                 node.x += node.vx;
                 node.y += node.vy;
                 node.z += node.vz;
 
+                // Apply position bounds
                 let max_coord = 100.0;
                 node.x = node.x.clamp(-max_coord, max_coord);
                 node.y = node.y.clamp(-max_coord, max_coord);
                 node.z = node.z.clamp(-max_coord, max_coord);
 
+                // Apply damping
                 node.vx *= damping;
                 node.vy *= damping;
                 node.vz *= damping;
@@ -245,6 +266,7 @@ impl GraphService {
         }
     }
 
+    /// Finds the shortest path between two nodes in the graph.
     pub fn find_shortest_path(graph: &GraphData, start: &str, end: &str) -> Result<Vec<String>, String> {
         let mut distances: HashMap<String, f32> = HashMap::new();
         let mut previous: HashMap<String, Option<String>> = HashMap::new();
@@ -283,6 +305,7 @@ impl GraphService {
             }
         }
     
+        // Reconstruct path
         let mut path = Vec::new();
         let mut current = end.to_string();
         while let Some(prev) = previous[&current].clone() {
diff --git a/src/utils/mod.rs b/src/utils/mod.rs
index 4bc04eaa..170c1c1b 100644
--- a/src/utils/mod.rs
+++ b/src/utils/mod.rs
@@ -1,4 +1,5 @@
 pub mod audio_processor;
+pub mod compression;
 pub mod gpu_compute;
 pub mod websocket_manager;
 pub mod websocket_messages;
diff --git a/src/utils/websocket_manager.rs b/src/utils/websocket_manager.rs
index 3e22b618..9a8dccff 100644
--- a/src/utils/websocket_manager.rs
+++ b/src/utils/websocket_manager.rs
@@ -5,21 +5,20 @@ use log::{info, error, debug};
 use std::sync::{Mutex, Arc};
 use serde_json::json;
 use futures::stream::StreamExt;
+use futures::future::join_all;
+use std::error::Error as StdError;
+use bytestring::ByteString;
 use serde::Deserialize;
 use tokio::time::Duration;
-use actix_web::web::Bytes;
-use bytestring::ByteString;
 
 use crate::AppState;
 use crate::models::simulation_params::{SimulationMode, SimulationParams};
-use crate::utils::websocket_messages::{
-    MessageHandler, OpenAIMessage, ServerMessage,
-    OpenAIConnected, OpenAIConnectionFailed, SendText, SendBinary
-};
+use crate::utils::compression::{compress_message, decompress_message};
+use crate::utils::websocket_messages::{SendCompressedMessage, MessageHandler, OpenAIMessage};
 use crate::utils::websocket_openai::OpenAIWebSocket;
+use crate::services::graph_service::GraphService;
 
 const OPENAI_CONNECT_TIMEOUT: Duration = Duration::from_secs(5);
-const GPU_UPDATE_INTERVAL: Duration = Duration::from_millis(50); // 20 fps
 
 #[derive(Deserialize, Debug)]
 #[serde(tag = "type")]
@@ -57,18 +56,6 @@ fn format_color(color: &str) -> String {
     format!("#{}", color)
 }
 
-/// Helper function to convert positions to binary Float32Array data
-fn positions_to_binary(positions: &Vec<[f32; 3]>) -> Vec<u8> {
-    let mut binary_data = Vec::with_capacity(positions.len() * 12); // 3 floats * 4 bytes each
-    for pos in positions {
-        // Ensure little-endian byte order for JavaScript Float32Array compatibility
-        binary_data.extend_from_slice(&pos[0].to_le_bytes());
-        binary_data.extend_from_slice(&pos[1].to_le_bytes());
-        binary_data.extend_from_slice(&pos[2].to_le_bytes());
-    }
-    binary_data
-}
-
 /// Manages WebSocket sessions and communication.
 pub struct WebSocketManager {
     pub sessions: Mutex<Vec<Addr<WebSocketSession>>>,
@@ -85,7 +72,7 @@ impl WebSocketManager {
     }
 
     /// Initializes the WebSocketManager with a conversation ID.
-    pub async fn initialize(&self, ragflow_service: &crate::services::ragflow_service::RAGFlowService) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
+    pub async fn initialize(&self, ragflow_service: &crate::services::ragflow_service::RAGFlowService) -> Result<(), Box<dyn StdError + Send + Sync>> {
         let conversation_id = ragflow_service.create_conversation("default_user".to_string()).await?;
         let mut conv_id_lock = self.conversation_id.lock().unwrap();
         *conv_id_lock = Some(conversation_id.clone());
@@ -107,16 +94,26 @@ impl WebSocketManager {
     }
 
     /// Broadcasts a message to all connected WebSocket sessions.
-    pub async fn broadcast_message(&self, message: &str) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
+    pub async fn broadcast_message(&self, message: &str) -> Result<(), Box<dyn StdError + Send + Sync>> {
         let sessions = self.sessions.lock().unwrap().clone();
-        for session in sessions {
-            session.do_send(SendText(message.to_string()));
+        let futures: Vec<_> = sessions.iter()
+            .map(|session| {
+                let compressed = compress_message(message).unwrap_or_default();
+                session.send(SendCompressedMessage(compressed))
+            })
+            .collect();
+        
+        let results = join_all(futures).await;
+        for result in results {
+            if let Err(e) = result {
+                error!("Failed to broadcast message: {}", e);
+            }
         }
         Ok(())
     }
 
     /// Broadcasts graph update to all connected WebSocket sessions.
-    pub async fn broadcast_graph_update(&self, graph_data: &crate::models::graph::GraphData) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
+    pub async fn broadcast_graph_update(&self, graph_data: &crate::models::graph::GraphData) -> Result<(), Box<dyn StdError + Send + Sync>> {
         let json_data = json!({
             "type": "graph_update",
             "graph_data": graph_data
@@ -145,13 +142,6 @@ impl Actor for WebSocketSession {
             "WebSocket session started. Total sessions: {}",
             self.state.websocket_manager.sessions.lock().unwrap().len()
         );
-
-        // Start GPU updates if in remote mode
-        if matches!(self.simulation_mode, SimulationMode::Remote) {
-            if let Some(_) = &self.state.gpu_compute {
-                self.start_gpu_updates(ctx);
-            }
-        }
     }
 
     fn stopped(&mut self, ctx: &mut Self::Context) {
@@ -166,19 +156,11 @@ impl Actor for WebSocketSession {
 
 impl MessageHandler for WebSocketSession {}
 
-impl Handler<SendText> for WebSocketSession {
-    type Result = ();
-
-    fn handle(&mut self, msg: SendText, ctx: &mut Self::Context) {
-        ctx.text(ByteString::from(msg.0));
-    }
-}
-
-impl Handler<SendBinary> for WebSocketSession {
+impl Handler<SendCompressedMessage> for WebSocketSession {
     type Result = ();
 
-    fn handle(&mut self, msg: SendBinary, ctx: &mut Self::Context) {
-        ctx.binary(Bytes::from(msg.0));
+    fn handle(&mut self, msg: SendCompressedMessage, ctx: &mut Self::Context) {
+        ctx.binary(msg.0);
     }
 }
 
@@ -219,7 +201,9 @@ impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for WebSocketSession
                                         "radius": radius
                                     });
                                     if let Ok(response_str) = serde_json::to_string(&response) {
-                                        ctx_addr.do_send(SendText(response_str));
+                                        if let Ok(compressed) = compress_message(&response_str) {
+                                            ctx_addr.do_send(SendCompressedMessage(compressed));
+                                        }
                                     }
                                 } else {
                                     error!("GPU compute service not available");
@@ -228,7 +212,9 @@ impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for WebSocketSession
                                         "message": "GPU compute service not available"
                                     });
                                     if let Ok(error_str) = serde_json::to_string(&error_message) {
-                                        ctx_addr.do_send(SendText(error_str));
+                                        if let Ok(compressed) = compress_message(&error_str) {
+                                            ctx_addr.do_send(SendCompressedMessage(compressed));
+                                        }
                                     }
                                 }
                             }.into_actor(self));
@@ -245,12 +231,11 @@ impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for WebSocketSession
                 }
             },
             Ok(ws::Message::Binary(bin)) => {
-                error!("Unexpected binary message received");
-                let error_message = json!({
-                    "type": "error",
-                    "message": "Unexpected binary message"
-                });
-                self.send_json_response(error_message, ctx);
+                if let Ok(text) = decompress_message(&bin) {
+                    StreamHandler::handle(self, Ok(ws::Message::Text(ByteString::from(text))), ctx);
+                } else {
+                    error!("Failed to decompress binary message");
+                }
             },
             Ok(ws::Message::Close(reason)) => {
                 ctx.close(reason);
@@ -324,7 +309,9 @@ impl WebSocketSession {
                                             "message": format!("Failed to generate speech: {}", e)
                                         });
                                         if let Ok(error_str) = serde_json::to_string(&error_message) {
-                                            ctx_addr.do_send(SendText(error_str));
+                                            if let Ok(compressed) = compress_message(&error_str) {
+                                                ctx_addr.do_send(SendCompressedMessage(compressed));
+                                            }
                                         }
                                     }
                                 }
@@ -336,7 +323,9 @@ impl WebSocketSession {
                                     "message": format!("Error processing RAGFlow response: {}", e)
                                 });
                                 if let Ok(error_str) = serde_json::to_string(&error_message) {
-                                    ctx_addr.do_send(SendText(error_str));
+                                    if let Ok(compressed) = compress_message(&error_str) {
+                                        ctx_addr.do_send(SendCompressedMessage(compressed));
+                                    }
                                 }
                             }
                         }
@@ -349,7 +338,9 @@ impl WebSocketSession {
                         "message": format!("Failed to send message to RAGFlow: {}", e)
                     });
                     if let Ok(error_str) = serde_json::to_string(&error_message) {
-                        ctx_addr.do_send(SendText(error_str));
+                        if let Ok(compressed) = compress_message(&error_str) {
+                            ctx_addr.do_send(SendCompressedMessage(compressed));
+                        }
                     }
                 }
             }
@@ -360,10 +351,6 @@ impl WebSocketSession {
         self.simulation_mode = match mode {
             "remote" => {
                 info!("Simulation mode set to Remote (GPU-accelerated)");
-                // Start GPU position updates when switching to remote mode
-                if let Some(_) = &self.state.gpu_compute {
-                    self.start_gpu_updates(ctx);
-                }
                 SimulationMode::Remote
             },
             "gpu" => {
@@ -390,120 +377,63 @@ impl WebSocketSession {
 
     fn handle_layout(&mut self, ctx: &mut ws::WebsocketContext<Self>, params: SimulationParams) {
         let state = self.state.clone();
+        let simulation_mode = self.simulation_mode.clone();
         let ctx_addr = ctx.address();
         
         ctx.spawn(async move {
-            if let Some(gpu_compute) = &state.gpu_compute {
-                let mut gpu = gpu_compute.write().await;
-                
-                // Update simulation parameters
-                if let Err(e) = gpu.update_simulation_params(&params) {
-                    error!("Failed to update simulation parameters: {}", e);
-                    let error_message = json!({
-                        "type": "error",
-                        "message": format!("Failed to update simulation parameters: {}", e)
-                    });
-                    if let Ok(error_str) = serde_json::to_string(&error_message) {
-                        ctx_addr.do_send(SendText(error_str));
+            let mut graph_data = state.graph_data.write().await;
+            
+            let result = match simulation_mode {
+                SimulationMode::Remote => {
+                    if let Some(gpu_compute) = &state.gpu_compute {
+                        GraphService::calculate_layout(
+                            &Some(gpu_compute.clone()),
+                            &mut *graph_data,
+                            &params
+                        ).await
+                    } else {
+                        GraphService::calculate_layout(
+                            &None,
+                            &mut *graph_data,
+                            &params
+                        ).await
                     }
-                    return;
-                }
+                },
+                _ => GraphService::calculate_layout(
+                    &None,
+                    &mut *graph_data,
+                    &params
+                ).await,
+            };
 
-                // Run initial GPU computation steps
-                for _ in 0..params.iterations {
-                    if let Err(e) = gpu.step() {
-                        error!("GPU compute step failed: {}", e);
-                        let error_message = json!({
-                            "type": "error",
-                            "message": format!("GPU compute step failed: {}", e)
-                        });
-                        if let Ok(error_str) = serde_json::to_string(&error_message) {
-                            ctx_addr.do_send(SendText(error_str));
+            match result {
+                Ok(_) => {
+                    let response = json!({
+                        "type": "layout_update",
+                        "graph_data": &*graph_data
+                    });
+                    if let Ok(response_str) = serde_json::to_string(&response) {
+                        if let Ok(compressed) = compress_message(&response_str) {
+                            ctx_addr.do_send(SendCompressedMessage(compressed));
                         }
-                        return;
                     }
-                }
-
-                // Get final positions after layout
-                match gpu.get_node_positions().await {
-                    Ok(nodes) => {
-                        // Convert GPU nodes to position arrays
-                        let positions: Vec<[f32; 3]> = nodes.iter()
-                            .map(|node| [node.x, node.y, node.z])
-                            .collect();
-
-                        // Convert positions to binary Float32Array data
-                        let binary_data = positions_to_binary(&positions);
-
-                        // Send binary data
-                        ctx_addr.do_send(SendBinary(binary_data));
-                    },
-                    Err(e) => {
-                        error!("Failed to get GPU node positions: {}", e);
-                        let error_message = json!({
-                            "type": "error",
-                            "message": format!("Failed to get GPU node positions: {}", e)
-                        });
-                        if let Ok(error_str) = serde_json::to_string(&error_message) {
-                            ctx_addr.do_send(SendText(error_str));
+                },
+                Err(e) => {
+                    error!("Failed to recalculate layout: {}", e);
+                    let error_message = json!({
+                        "type": "error",
+                        "message": format!("Layout calculation failed: {}", e)
+                    });
+                    if let Ok(error_str) = serde_json::to_string(&error_message) {
+                        if let Ok(compressed) = compress_message(&error_str) {
+                            ctx_addr.do_send(SendCompressedMessage(compressed));
                         }
                     }
                 }
-            } else {
-                error!("GPU compute service not available");
-                let error_message = json!({
-                    "type": "error",
-                    "message": "GPU compute service not available"
-                });
-                if let Ok(error_str) = serde_json::to_string(&error_message) {
-                    ctx_addr.do_send(SendText(error_str));
-                }
             }
         }.into_actor(self));
     }
 
-    fn start_gpu_updates(&self, ctx: &mut ws::WebsocketContext<Self>) {
-        let state = self.state.clone();
-        let ctx_addr = ctx.address();
-
-        // Start a timer to periodically fetch and broadcast GPU positions
-        ctx.run_interval(GPU_UPDATE_INTERVAL, move |_act, _ctx| {
-            let state_clone = state.clone();
-            let addr_clone = ctx_addr.clone();
-
-            actix::spawn(async move {
-                if let Some(gpu_compute) = &state_clone.gpu_compute {
-                    let mut gpu = gpu_compute.write().await;
-                    
-                    // Run one step of GPU computation
-                    if let Err(e) = gpu.step() {
-                        error!("GPU compute step failed: {}", e);
-                        return;
-                    }
-
-                    // Get updated positions
-                    match gpu.get_node_positions().await {
-                        Ok(nodes) => {
-                            // Convert GPU nodes to position arrays
-                            let positions: Vec<[f32; 3]> = nodes.iter()
-                                .map(|node| [node.x, node.y, node.z])
-                                .collect();
-
-                            // Convert positions to binary Float32Array data
-                            let binary_data = positions_to_binary(&positions);
-
-                            // Send binary data
-                            addr_clone.do_send(SendBinary(binary_data));
-                        },
-                        Err(e) => {
-                            error!("Failed to get GPU node positions: {}", e);
-                        }
-                    }
-                }
-            });
-        });
-    }
-
     fn handle_initial_data(&mut self, ctx: &mut ws::WebsocketContext<Self>) {
         let state = self.state.clone();
         let ctx_addr = ctx.address();
@@ -553,36 +483,10 @@ impl WebSocketSession {
             debug!("Sending initial data response: {:?}", response);
 
             if let Ok(response_str) = serde_json::to_string(&response) {
-                ctx_addr.do_send(SendText(response_str));
+                if let Ok(compressed) = compress_message(&response_str) {
+                    ctx_addr.do_send(SendCompressedMessage(compressed));
+                }
             }
         }.into_actor(self));
     }
 }
-
-// Implement Handler traits for WebSocketSession
-impl Handler<OpenAIMessage> for WebSocketSession {
-    type Result = ();
-
-    fn handle(&mut self, msg: OpenAIMessage, _ctx: &mut Self::Context) {
-        if let Some(ref ws) = self.openai_ws {
-            ws.do_send(msg);
-        }
-    }
-}
-
-impl Handler<OpenAIConnected> for WebSocketSession {
-    type Result = ();
-
-    fn handle(&mut self, _: OpenAIConnected, _ctx: &mut Self::Context) {
-        debug!("OpenAI WebSocket connected");
-    }
-}
-
-impl Handler<OpenAIConnectionFailed> for WebSocketSession {
-    type Result = ();
-
-    fn handle(&mut self, _: OpenAIConnectionFailed, _ctx: &mut Self::Context) {
-        error!("OpenAI WebSocket connection failed");
-        self.openai_ws = None;
-    }
-}
diff --git a/src/utils/websocket_messages.rs b/src/utils/websocket_messages.rs
index 94cd1510..6420a9fb 100644
--- a/src/utils/websocket_messages.rs
+++ b/src/utils/websocket_messages.rs
@@ -4,8 +4,7 @@ use serde_json::{json, Value};
 use crate::models::simulation_params::SimulationParams;
 use actix_web_actors::ws;
 use log::{error, debug};
-use actix_web::web::Bytes;
-use bytestring::ByteString;
+use crate::utils::compression::compress_message;
 
 /// Helper function to convert hex color to proper format
 fn format_color(color: &str) -> String {
@@ -15,57 +14,31 @@ fn format_color(color: &str) -> String {
     format!("#{}", color)
 }
 
-/// GPU-computed node positions
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub struct GPUPositionUpdate {
-    pub positions: Vec<[f32; 3]>
-}
-
-/// Message for sending text data
-#[derive(Message)]
-#[rtype(result = "()")]
-pub struct SendText(pub String);
-
-/// Message for sending binary data
+/// Represents messages sent to the client as compressed binary data.
 #[derive(Message)]
 #[rtype(result = "()")]
-pub struct SendBinary(pub Vec<u8>);
-
-/// Message for OpenAI text-to-speech
-#[derive(Message)]
-#[rtype(result = "()")]
-pub struct OpenAIMessage(pub String);
-
-/// Message indicating OpenAI connection success
-#[derive(Message)]
-#[rtype(result = "()")]
-pub struct OpenAIConnected;
-
-/// Message indicating OpenAI connection failure
-#[derive(Message)]
-#[rtype(result = "()")]
-pub struct OpenAIConnectionFailed;
+pub struct SendCompressedMessage(pub Vec<u8>);
 
 /// Represents messages sent from the client.
 #[derive(Serialize, Deserialize, Debug)]
 #[serde(tag = "type")]
 pub enum ClientMessage {
-    #[serde(rename = "setTtsMethod")]
+    #[serde(rename = "set_tts_method")]
     SetTTSMethod { method: String },
     
-    #[serde(rename = "chatMessage")]
+    #[serde(rename = "chat_message")]
     ChatMessage { 
         message: String, 
         use_openai: bool 
     },
     
-    #[serde(rename = "getInitialData")]
+    #[serde(rename = "get_initial_data")]
     GetInitialData,
     
-    #[serde(rename = "setSimulationMode")]
+    #[serde(rename = "set_simulation_mode")]
     SetSimulationMode { mode: String },
     
-    #[serde(rename = "recalculateLayout")]
+    #[serde(rename = "recalculate_layout")]
     RecalculateLayout { params: SimulationParams },
     
     #[serde(rename = "ragflowQuery")]
@@ -91,17 +64,17 @@ pub enum ClientMessage {
 #[derive(Serialize, Deserialize, Debug)]
 #[serde(tag = "type")]
 pub enum ServerMessage {
-    #[serde(rename = "audioData")]
+    #[serde(rename = "audio_data")]
     AudioData {
         audio_data: String // base64 encoded audio
     },
     
-    #[serde(rename = "ragflowResponse")]
+    #[serde(rename = "ragflow_response")]
     RagflowResponse {
         answer: String
     },
     
-    #[serde(rename = "openaiResponse")]
+    #[serde(rename = "openai_response")]
     OpenAIResponse {
         response: String,
         audio: Option<String> // base64 encoded audio
@@ -113,35 +86,54 @@ pub enum ServerMessage {
         code: Option<String>
     },
     
-    #[serde(rename = "graphUpdate")]
+    #[serde(rename = "graph_update")]
     GraphUpdate {
         graph_data: Value
     },
     
-    #[serde(rename = "simulationModeSet")]
+    #[serde(rename = "simulation_mode_set")]
     SimulationModeSet {
         mode: String,
         gpu_enabled: bool
     },
 
-    #[serde(rename = "fisheyeSettingsUpdated")]
+    #[serde(rename = "fisheye_settings_updated")]
     FisheyeSettingsUpdated {
         enabled: bool,
         strength: f32,
         focus_point: [f32; 3],
         radius: f32,
-    },
-
-    #[serde(rename = "gpuPositions")]
-    GPUPositions(GPUPositionUpdate)
+    }
 }
 
+#[derive(Message)]
+#[rtype(result = "()")]
+pub struct OpenAIConnected;
+
+#[derive(Message)]
+#[rtype(result = "()")]
+pub struct OpenAIConnectionFailed;
+
+#[derive(Message)]
+#[rtype(result = "()")]
+pub struct OpenAIMessage(pub String);
+
 pub trait MessageHandler: Actor<Context = ws::WebsocketContext<Self>> {
     fn send_json_response(&self, response: Value, ctx: &mut ws::WebsocketContext<Self>) {
         match serde_json::to_string(&response) {
             Ok(json_string) => {
                 debug!("Sending JSON response: {}", json_string);
-                ctx.text(ByteString::from(json_string));
+                match compress_message(&json_string) {
+                    Ok(compressed) => {
+                        debug!("Compressed response size: {} bytes", compressed.len());
+                        ctx.binary(compressed)
+                    },
+                    Err(e) => {
+                        error!("Failed to compress JSON response: {}", e);
+                        // Fallback to uncompressed JSON if compression fails
+                        ctx.text(json_string);
+                    }
+                }
             },
             Err(e) => {
                 error!("Failed to serialize JSON response: {}", e);
@@ -151,7 +143,7 @@ pub trait MessageHandler: Actor<Context = ws::WebsocketContext<Self>> {
                     "code": "SERIALIZATION_ERROR"
                 });
                 if let Ok(error_string) = serde_json::to_string(&error_message) {
-                    ctx.text(ByteString::from(error_string));
+                    ctx.text(error_string);
                 }
             }
         }
@@ -213,7 +205,7 @@ mod tests {
             use_openai: true
         };
         let serialized = serde_json::to_string(&message).unwrap();
-        assert!(serialized.contains("chatMessage"));
+        assert!(serialized.contains("chat_message"));
         assert!(serialized.contains("Hello"));
 
         let fisheye_message = ClientMessage::UpdateFisheyeSettings {
@@ -233,7 +225,7 @@ mod tests {
             answer: "Test answer".to_string()
         };
         let serialized = serde_json::to_string(&message).unwrap();
-        assert!(serialized.contains("ragflowResponse"));
+        assert!(serialized.contains("ragflow_response"));
         assert!(serialized.contains("Test answer"));
 
         let fisheye_message = ServerMessage::FisheyeSettingsUpdated {
@@ -243,7 +235,7 @@ mod tests {
             radius: 100.0,
         };
         let serialized = serde_json::to_string(&fisheye_message).unwrap();
-        assert!(serialized.contains("fisheyeSettingsUpdated"));
+        assert!(serialized.contains("fisheye_settings_updated"));
         assert!(serialized.contains("strength"));
     }
 
diff --git a/src/utils/websocket_openai.rs b/src/utils/websocket_openai.rs
index 81e68752..5f093db4 100644
--- a/src/utils/websocket_openai.rs
+++ b/src/utils/websocket_openai.rs
@@ -15,8 +15,9 @@ use tokio::net::TcpStream;
 use std::time::Instant;
 
 use crate::config::Settings;
-use crate::utils::websocket_messages::{OpenAIMessage, OpenAIConnected, OpenAIConnectionFailed, SendText};
+use crate::utils::websocket_messages::{OpenAIMessage, OpenAIConnected, OpenAIConnectionFailed, SendCompressedMessage};
 use crate::utils::websocket_manager::WebSocketSession;
+use crate::utils::compression;
 
 const KEEPALIVE_INTERVAL: Duration = Duration::from_secs(30);
 const CONNECTION_WAIT: Duration = Duration::from_millis(500);
@@ -196,15 +197,17 @@ impl OpenAIWebSocket {
         let start_time = Instant::now();
         debug!("Preparing to send audio data to client");
 
-        // Send audio data as JSON
+        // Send audio data directly without compression
         let audio_message = json!({
             "type": "audio",
             "audio": audio_data
         });
 
-        // Convert to string and send
+        // Convert to string first
         let message_str = audio_message.to_string();
-        if let Err(e) = self.client_addr.try_send(SendText(message_str)) {
+        let compressed = compression::compress_message(&message_str)?;
+        
+        if let Err(e) = self.client_addr.try_send(SendCompressedMessage(compressed)) {
             error!("Failed to send audio data to client: {}", e);
             return Err(Box::new(WebSocketError::SendFailed(format!(
                 "Failed to send audio data to client: {}", e
@@ -224,9 +227,11 @@ impl OpenAIWebSocket {
             "message": error_msg
         });
 
-        // Convert to string and send
+        // Convert to string first
         let message_str = error_message.to_string();
-        if let Err(e) = self.client_addr.try_send(SendText(message_str)) {
+        let compressed = compression::compress_message(&message_str)?;
+        
+        if let Err(e) = self.client_addr.try_send(SendCompressedMessage(compressed)) {
             error!("Failed to send error message to client: {}", e);
             return Err(Box::new(WebSocketError::SendFailed(format!(
                 "Failed to send error message to client: {}", e
