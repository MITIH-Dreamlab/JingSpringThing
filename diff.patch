diff --git a/README.md b/README.md
index 0a448d91..9c7881b0 100644
--- a/README.md
+++ b/README.md
@@ -77,31 +77,39 @@ classDiagram
 
     class WebXRVisualization {
         - graphDataManager: GraphDataManager
-        - scene: THREE.Scene
-        - camera: THREE.PerspectiveCamera
-        - renderer: THREE.WebGLRenderer
-        - controls: OrbitControls
-        - composer: EffectComposer
-        - gpu: GPUUtilities (optional)
+        - nodeManager: NodeManager
+        - layoutManager: LayoutManager
+        - effectsManager: EffectManager
+        - lastPositionUpdate: number
+        - positionUpdateThreshold: number
+        + handleBinaryPositionUpdate(buffer: ArrayBuffer)
+        + handleNodeDrag(nodeId: string, position: Vector3)
+        + updateSettings(settings: object)
+        + animate()
+    }
+
+    class NodeManager {
         - nodeMeshes: Map<string, THREE.Mesh>
+        - nodeLabels: Map<string, THREE.Sprite>
         - edgeMeshes: Map<string, THREE.Line>
-        - hologramGroup: THREE.Group
-        - particleSystem: THREE.Points
-        + initialize()
-        + updateVisualization()
-        - initThreeJS()
-        - setupGPU()
-        - initPostProcessing()
-        - addLights()
-        - createHologramStructure()
-        - createParticleSystem()
-        - onSelect(selectedObject: THREE.Object3D)
-        - animate()
-        - rotateHologram()
-        - updateParticles()
-        - onWindowResize()
-        - getNodeColor(node: Node): THREE.Color
-        - updateNodes(nodes: Node[])
+        - oldestDate: number
+        - newestDate: number
+        + updateNodePositions(updates: PositionUpdate[])
+        + updateNodePosition(nodeId: string, position: Vector3)
+        + getNodePositions(): PositionUpdate[]
+        + calculateNodeColor(lastModified: Date): THREE.Color
+    }
+
+    class LayoutManager {
+        - lastPositions: Position[]
+        - updateThreshold: number
+        - lastUpdateTime: number
+        - updateInterval: number
+        - currentGraphData: GraphData
+        + performLayout(graphData: GraphData)
+        + updateNodePosition(nodeId: string, position: Vector3)
+        + sendPositionUpdates(nodes: Node[])
+        + applyPositionUpdates(buffer: ArrayBuffer)
     }
 
     class ChatManager {
@@ -129,8 +137,9 @@ classDiagram
     }
 
     class GraphService {
-        + build_graph(app_state: AppState): Result<GraphData, Box<dyn std::error::Error + Send + Sync>>
-        + calculate_layout(gpu_compute: &GPUCompute, graph: &mut GraphData): Result<(), Box<dyn std::error::Error + Send + Sync>>
+        + build_graph_from_metadata(metadata: Map): GraphData
+        + calculate_layout(gpu_compute: GPUCompute, graph: GraphData)
+        - initialize_random_positions(graph: GraphData)
     }
 
     class PerplexityService {
@@ -147,6 +156,16 @@ classDiagram
         + count_topics(content: &str, metadata_map: &HashMap<String, Metadata>): HashMap<String, usize>
     }
 
+    class GPUCompute {
+        - device: GPUDevice
+        - nodes_buffer: GPUBuffer
+        - position_update_buffer: GPUBuffer
+        - position_pipeline: GPUComputePipeline
+        + update_positions(binary_data: Uint8Array)
+        + get_position_updates(): ArrayBuffer
+        + step()
+    }
+
     App --> WebsocketService
     App --> GraphDataManager
     App --> WebXRVisualization
@@ -161,176 +180,79 @@ classDiagram
     App --> GraphService
     App --> PerplexityService
     App --> FileService
+    WebXRVisualization --> NodeManager
+    WebXRVisualization --> LayoutManager
+    WebXRVisualization --> WebSocketService
+    LayoutManager --> WebSocketService
+    WebSocketService --> GPUCompute
+    GraphService --> GPUCompute
 ```
 
 ### Sequence Diagram
 
 ```mermaid
 sequenceDiagram
-    participant User
-    participant Interface
-    participant App
-    participant WebsocketService
-    participant GraphDataManager
+    participant Client
     participant WebXRVisualization
-    participant ChatManager
-    participant RAGFlowService
-    participant PerplexityService
-    participant FileService
-    participant GraphService
-    participant APIClient
-    participant GPUCompute
+    participant NodeManager
+    participant LayoutManager
+    participant WebSocket
     participant Server
+    participant GPUCompute
 
-    rect rgba(200, 255, 200, 0.1)
-        activate Server
-        Server->>Server: Load env vars & settings (config.rs)
-        alt Settings Load Error
-            note right of Server: Error handling in main.rs
-            Server-->>User: Error Response (500)
-            deactivate Server
-        else Settings Loaded
-            Server->>Server: Initialize AppState (app_state.rs)
-            Server->>Server: Initialize GPUCompute (utils/gpu_compute.rs)
-            alt GPU Initialization Error
-                note right of Server: Fallback to CPU calculation
-            end
-            Server->>Server: initialize_graph_data (main.rs)
-            Server->>FileService: fetch_and_process_files (services/file_service.rs)
-            activate FileService
-                FileService->>GitHub: fetch_files (RealGitHubService::fetch_files)
-                activate GitHub
-                    GitHub-->>FileService: Files or Error
-                deactivate GitHub
-                alt GitHub Error
-                    FileService-->>Server: Error
-                else Files Fetched
-                    loop For each file
-                        FileService->>FileService: should_process_file
-                        alt File needs processing
-                            FileService->>PerplexityService: process_file (services/perplexity_service.rs)
-                            activate PerplexityService
-                                PerplexityService->>PerplexityService: process_markdown (splits into blocks, calls API)
-                                PerplexityService->>PerplexityService: call_perplexity_api (multiple times)
-                                PerplexityService-->>FileService: Processed content or Error
-                            deactivate PerplexityService
-                            alt Perplexity Error
-                                FileService-->>Server: Error
-                            else Content Processed
-                                FileService->>FileService: save_file_metadata (writes to /app/data/markdown)
-                            end
-                        end
-                    end
-                    FileService-->>Server: Processed files or Error
-                end
-            deactivate FileService
-            alt File Processing Error
-                Server-->>Server: Error
-            else Files Processed Successfully
-                Server->>GraphService: build_graph (services/graph_service.rs)
-                activate GraphService
-                    GraphService->>GraphService: Create nodes and edges
-                    GraphService->>GPUCompute: calculate_layout (or CPU fallback)
-                    activate GPUCompute
-                        GPUCompute->>GPUCompute: set_graph_data
-                        GPUCompute->>GPUCompute: compute_forces
-                        GPUCompute->>GPUCompute: get_updated_positions
-                        GPUCompute-->>GraphService: Updated node positions
-                    deactivate GPUCompute
-                    GraphService-->>Server: GraphData
-                deactivate GraphService
-                Server->>WebsocketService: broadcast_graph_update (utils/websocket_manager.rs)
-                activate WebsocketService
-                    WebsocketService-->>User: graph_update_message
-                deactivate WebsocketService
-                Server-->>User: Success Response
-            end
-        end
-    end
-
-    note right of User: Initial load
+    Note over Client,GPUCompute: Initial Setup Phase
 
-    User->>WebXRVisualization: initialize()
+    Client->>WebXRVisualization: initialize()
     activate WebXRVisualization
-        WebXRVisualization->>GraphDataManager: requestInitialData()
-        activate GraphDataManager
-            GraphDataManager->>WebsocketService: subscribe()
-            WebsocketService-->>GraphDataManager: Initial GraphData
-            GraphDataManager-->>WebXRVisualization: Provide GraphData
-        deactivate GraphDataManager
-        WebXRVisualization->>WebXRVisualization: setupThreeJS()
-        WebXRVisualization->>WebXRVisualization: renderScene()
+        WebXRVisualization->>WebSocket: connect()
+        WebSocket->>Server: establish connection
+        Server->>GPUCompute: initialize()
+        Server-->>Client: connection established
+        
+        WebXRVisualization->>WebSocket: request initial data
+        WebSocket->>Server: getInitialData
+        Server->>GPUCompute: calculate_initial_layout()
+        GPUCompute-->>Server: initial positions
+        Server-->>Client: graph data + binary positions
+        
+        WebXRVisualization->>NodeManager: initialize(graphData)
+        WebXRVisualization->>LayoutManager: initialize(graphData)
     deactivate WebXRVisualization
-    WebXRVisualization-->>User: Render 3D Graph
-
-    note right of User: User interactions
-
-    User->>Interface: handleUserInput(input)
-    Interface->>ChatManager: sendMessage(input)
-    ChatManager->>RAGFlowService: sendQuery(input)
-    RAGFlowService-->>ChatManager: AI Response
-    ChatManager-->>Interface: Display AI Response
-    Interface->>WebXRVisualization: updateGraphData(newData)
-    WebXRVisualization-->>User: Update Visualization
-
-    note right of User: User clicks "Refresh Graph"
-
-    User->>Server: POST /api/files/fetch (handlers/file_handler.rs)
-    activate Server
-        Server->>FileService: fetch_and_process_files (services/file_service.rs)
-        activate FileService
-            FileService->>GitHub: fetch_files (RealGitHubService::fetch_files)
-            activate GitHub
-                GitHub-->>FileService: Files or Error
-            deactivate GitHub
-            alt GitHub Error
-                FileService-->>Server: Error
-            else Files Fetched
-                loop For each file
-                    FileService->>FileService: should_process_file
-                    alt File needs processing
-                        FileService->>PerplexityService: process_file (services/perplexity_service.rs)
-                        activate PerplexityService
-                            PerplexityService->>PerplexityService: process_markdown (splits into blocks, calls API)
-                            PerplexityService->>PerplexityService: call_perplexity_api (multiple times)
-                            PerplexityService-->>FileService: Processed content or Error
-                        deactivate PerplexityService
-                        alt Perplexity Error
-                            FileService-->>Server: Error
-                        else Content Processed
-                            FileService->>FileService: save_file_metadata (writes to /app/data/markdown)
-                        end
-                    end
-                end
-                FileService-->>Server: Processed files or Error
-            end
-        deactivate FileService
-        alt File Processing Error
-            Server->>WebsocketService: broadcast_error_message (utils/websocket_manager.rs)
-            activate WebsocketService
-                WebsocketService-->>User: error_message
-            deactivate WebsocketService
-            Server-->>User: Error Response
-        else Files Processed Successfully
-            Server->>GraphService: build_graph (services/graph_service.rs)
-            activate GraphService
-                GraphService->>GraphService: Create nodes and edges
-                GraphService->>GPUCompute: calculate_layout (or CPU fallback)
-                activate GPUCompute
-                    GPUCompute->>GPUCompute: set_graph_data
-                    GPUCompute->>GPUCompute: compute_forces
-                    GPUCompute->>GPUCompute: get_updated_positions
-                    GPUCompute-->>GraphService: Updated node positions
-                deactivate GPUCompute
-                GraphService-->>Server: GraphData
-            deactivate GraphService
-            Server->>WebsocketService: broadcast_graph_update (utils/websocket_manager.rs)
-            activate WebsocketService
-                WebsocketService-->>User: graph_update_message
-            deactivate WebsocketService
-            Server-->>User: Success Response
+
+    Note over Client,GPUCompute: Real-time Position Update Flow (60fps)
+
+    Client->>WebXRVisualization: nodeDragged event
+    activate WebXRVisualization
+        WebXRVisualization->>NodeManager: updateNodePosition()
+        WebXRVisualization->>LayoutManager: handleNodeDrag()
+        
+        alt Time since last update >= 16.67ms
+            LayoutManager->>LayoutManager: prepare binary position data
+            LayoutManager->>WebSocket: send binary position update
+            WebSocket->>Server: binary message
+            
+            Server->>GPUCompute: update_positions(binary)
+            GPUCompute->>GPUCompute: validate positions
+            GPUCompute-->>Server: validated positions
+            
+            Server->>Server: broadcast to other clients
+            Server-->>Client: binary position update
+            
+            WebXRVisualization->>NodeManager: handleBinaryPositionUpdate()
+            NodeManager->>NodeManager: update visual positions
         end
-    deactivate Server
+    deactivate WebXRVisualization
+
+    Note over Client,GPUCompute: Continuous Physics Simulation
+
+    loop Every animation frame
+        GPUCompute->>GPUCompute: step()
+        GPUCompute-->>Server: new positions
+        Server-->>Client: binary position broadcast
+        
+        WebXRVisualization->>NodeManager: updateNodePositions()
+        WebXRVisualization->>WebXRVisualization: render()
+    end
 ```
 
 ## Installation
diff --git a/data/public/js/components/visualization/core.js b/data/public/js/components/visualization/core.js
index 57cd9f15..8eae3f9f 100644
--- a/data/public/js/components/visualization/core.js
+++ b/data/public/js/components/visualization/core.js
@@ -45,18 +45,46 @@ export class WebXRVisualization {
         // Initialize settings
         this.initializeSettings();
 
-        // Add event listener for graph data updates
+        // Add event listeners for graph data and position updates
         window.addEventListener('graphDataUpdated', (event) => {
             console.log('Received graphDataUpdated event:', event.detail);
             this.updateVisualization();
         });
 
-        // Add event listener for settings updates
         window.addEventListener('visualizationSettingsUpdated', (event) => {
             console.log('Received visualizationSettingsUpdated event:', event.detail);
             this.updateSettings(event.detail);
         });
 
+        // Handle position updates from layout manager
+        window.addEventListener('positionUpdate', (event) => {
+            console.log('Received position update');
+            if (this.graphDataManager.websocketService && this.graphDataManager.websocketService.socket) {
+                // Send binary position data directly through websocket
+                this.graphDataManager.websocketService.socket.send(event.detail);
+            }
+        });
+
+        // Handle incoming position updates from other clients
+        window.addEventListener('graphPositionsUpdated', (event) => {
+            console.log('Received position update from server');
+            if (this.layoutManager && event.detail instanceof ArrayBuffer) {
+                this.layoutManager.applyPositionUpdates(event.detail);
+                
+                // Extract positions from binary data for node manager
+                const dataView = new DataView(event.detail);
+                const positions = [];
+                for (let i = 0; i < event.detail.byteLength; i += 24) { // 24 bytes per node
+                    positions.push({
+                        x: dataView.getFloat32(i, true),
+                        y: dataView.getFloat32(i + 4, true),
+                        z: dataView.getFloat32(i + 8, true)
+                    });
+                }
+                this.nodeManager.updateNodePositions(positions);
+            }
+        });
+
         console.log('WebXRVisualization constructor completed');
     }
 
@@ -255,4 +283,52 @@ export class WebXRVisualization {
 
         console.log('WebXRVisualization disposed');
     }
+
+    handleNodeDrag(nodeId, position) {
+        // Update local node position
+        this.nodeManager.updateNodePosition(nodeId, position);
+
+        const now = Date.now();
+        if (now - this.lastPositionUpdate >= this.positionUpdateThreshold) {
+            this.lastPositionUpdate = now;
+            
+            // Get all node positions for synchronization
+            const positions = this.nodeManager.getNodePositions();
+            
+            // Create binary position data - only x,y,z per node (12 bytes)
+            const buffer = new ArrayBuffer(positions.length * 12); 
+            const view = new Float32Array(buffer);
+            
+            positions.forEach((pos, index) => {
+                const offset = index * 3;
+                view[offset] = pos.position.x;
+                view[offset + 1] = pos.position.y;
+                view[offset + 2] = pos.position.z;
+            });
+
+            // Dispatch binary position update
+            window.dispatchEvent(new CustomEvent('positionUpdate', {
+                detail: buffer
+            }));
+        }
+    }
+
+    handleBinaryPositionUpdate(buffer) {
+        const positions = new Float32Array(buffer);
+        const updates = [];
+        
+        // Each position update contains 3 float values (x,y,z)
+        for (let i = 0; i < positions.length; i += 3) {
+            updates.push({
+                position: new THREE.Vector3(
+                    positions[i],
+                    positions[i + 1],
+                    positions[i + 2]
+                )
+            });
+        }
+
+        // Fast update through node manager
+        this.nodeManager.updateNodePositions(updates);
+    }
 }
diff --git a/data/public/js/components/visualization/layout.js b/data/public/js/components/visualization/layout.js
index 50974f63..161554ee 100644
--- a/data/public/js/components/visualization/layout.js
+++ b/data/public/js/components/visualization/layout.js
@@ -3,8 +3,6 @@ export class LayoutManager {
         // Configuration
         this.initialIterations = 250;    // High iteration count for initial layout
         this.updateIterations = 1;       // Single iteration for smooth continuous updates
-        this.forceDirectedSpring = 2.0;
-        this.forceDirectedDamping = 0.8;
         this.targetRadius = 200;
         this.naturalLength = 100;
         
@@ -12,6 +10,11 @@ export class LayoutManager {
         this.isInitialized = false;
         this.isSimulating = false;
         this.animationFrameId = null;
+        this.lastPositions = null;       // Store previous positions for change detection
+        this.updateThreshold = 0.001;    // Minimum position change to trigger update
+        this.lastUpdateTime = 0;         // Last time positions were sent to server
+        this.updateInterval = 16.67;     // Exactly 60fps
+        this.positionBuffer = null;
     }
 
     initializePositions(nodes) {
@@ -31,131 +34,101 @@ export class LayoutManager {
             if (!node.vy) node.vy = 0;
             if (!node.vz) node.vz = 0;
         });
-    }
-
-    calculateSpringForce(pos1, pos2, mass1, mass2, isConnected) {
-        const dx = pos2.x - pos1.x;
-        const dy = pos2.y - pos1.y;
-        const dz = pos2.z - pos1.z;
-        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz) || 0.1;
-
-        let forceMagnitude;
-        if (isConnected) {
-            forceMagnitude = this.forceDirectedSpring * (distance - this.naturalLength);
-        } else {
-            forceMagnitude = -this.forceDirectedSpring * mass1 * mass2 / (distance * distance + 0.1);
-        }
 
-        const maxForce = 50.0;
-        forceMagnitude = Math.min(Math.max(forceMagnitude, -maxForce), maxForce);
+        // Initialize last positions
+        this.lastPositions = nodes.map(node => ({
+            x: node.x,
+            y: node.y,
+            z: node.z
+        }));
+    }
 
-        return {
-            fx: (dx / distance) * forceMagnitude,
-            fy: (dy / distance) * forceMagnitude,
-            fz: (dz / distance) * forceMagnitude
-        };
+    initializePositionBuffer(nodeCount) {
+        // Pre-allocate buffer for position updates
+        this.positionBuffer = new ArrayBuffer(nodeCount * 12);
+        this.positionView = new Float32Array(this.positionBuffer);
     }
 
-    applyForceDirectedLayout(graphData, onComplete) {
-        const nodes = graphData.nodes;
+    // Update position of a node (e.g., from VR interaction)
+    updateNodePosition(nodeId, position) {
+        const offset = nodeId * 3;
+        this.positionView[offset] = position.x;
+        this.positionView[offset + 1] = position.y;
+        this.positionView[offset + 2] = position.z;
         
-        // Initialize positions if needed
-        if (!this.isInitialized) {
-            this.initializePositions(nodes);
-            this.isInitialized = true;
-            // Start continuous refinement
-            this.startContinuousSimulation(graphData);
-        }
+        // Mark for update
+        this.needsUpdate = true;
+    }
 
-        // Perform a single iteration of force-directed layout
-        this.performLayout(graphData, this.updateIterations);
-        
-        if (onComplete) {
-            onComplete();
+    performLayout(graphData) {
+        const now = Date.now();
+        if (now - this.lastUpdateTime >= this.updateInterval) {
+            this.sendPositionUpdates(graphData.nodes);
+            this.lastUpdateTime = now;
         }
     }
 
-    performLayout(graphData, iterations) {
-        const nodes = graphData.nodes;
-        const edges = graphData.edges;
-
-        for (let iteration = 0; iteration < iterations; iteration++) {
-            // Calculate forces between all nodes
-            for (let i = 0; i < nodes.length; i++) {
-                for (let j = i + 1; j < nodes.length; j++) {
-                    const force = this.calculateSpringForce(
-                        nodes[i], nodes[j],
-                        nodes[i].mass || 1, nodes[j].mass || 1,
-                        false
-                    );
-
-                    nodes[i].vx -= force.fx;
-                    nodes[i].vy -= force.fy;
-                    nodes[i].vz -= force.fz;
-                    nodes[j].vx += force.fx;
-                    nodes[j].vy += force.fy;
-                    nodes[j].vz += force.fz;
-                }
-            }
+    sendPositionUpdates(nodes) {
+        if (!this.lastPositions) return;
 
-            // Calculate forces along edges
-            edges.forEach(edge => {
-                const source = nodes.find(node => node.id === edge.source);
-                const target = nodes.find(node => node.id === edge.target_node);
-                if (source && target) {
-                    const force = this.calculateSpringForce(
-                        source, target,
-                        source.mass || 1, target.mass || 1,
-                        true
-                    );
-
-                    source.vx += force.fx;
-                    source.vy += force.fy;
-                    source.vz += force.fz;
-                    target.vx -= force.fx;
-                    target.vy -= force.fy;
-                    target.vz -= force.fz;
-                }
-            });
-
-            // Apply centering force and update positions
-            const maxVelocity = 10.0;
-            nodes.forEach(node => {
-                // Centering force
-                const distance = Math.sqrt(node.x * node.x + node.y * node.y + node.z * node.z);
-                if (distance > this.targetRadius) {
-                    const centerForce = 0.05 * (distance - this.targetRadius); // Reduced strength
-                    node.vx -= (node.x / distance) * centerForce;
-                    node.vy -= (node.y / distance) * centerForce;
-                    node.vz -= (node.z / distance) * centerForce;
-                }
+        // Create binary buffer for all node positions (24 bytes per node)
+        const buffer = new ArrayBuffer(nodes.length * 24);
+        const dataView = new DataView(buffer);
+        let hasChanges = false;
+
+        nodes.forEach((node, index) => {
+            const offset = index * 24;
+            const lastPos = this.lastPositions[index];
 
-                // Apply damping
-                node.vx *= this.forceDirectedDamping;
-                node.vy *= this.forceDirectedDamping;
-                node.vz *= this.forceDirectedDamping;
-
-                // Limit velocity
-                const speed = Math.sqrt(node.vx * node.vx + node.vy * node.vy + node.vz * node.vz);
-                if (speed > maxVelocity) {
-                    const scale = maxVelocity / speed;
-                    node.vx *= scale;
-                    node.vy *= scale;
-                    node.vz *= scale;
+            if (!lastPos || 
+                Math.abs(node.x - lastPos.x) > this.updateThreshold ||
+                Math.abs(node.y - lastPos.y) > this.updateThreshold ||
+                Math.abs(node.z - lastPos.z) > this.updateThreshold) {
+                
+                hasChanges = true;
+                
+                // Update last position
+                if (lastPos) {
+                    lastPos.x = node.x;
+                    lastPos.y = node.y;
+                    lastPos.z = node.z;
                 }
 
-                // Update positions with smaller step size for smoother motion
-                const stepSize = 0.5;
-                node.x += node.vx * stepSize;
-                node.y += node.vy * stepSize;
-                node.z += node.vz * stepSize;
-
-                // Ensure positions stay within bounds
-                const maxCoord = 100.0;
-                node.x = Math.max(Math.min(node.x, maxCoord), -maxCoord);
-                node.y = Math.max(Math.min(node.y, maxCoord), -maxCoord);
-                node.z = Math.max(Math.min(node.z, maxCoord), -maxCoord);
-            });
+                // Position (vec3<f32>)
+                dataView.setFloat32(offset, node.x, true);
+                dataView.setFloat32(offset + 4, node.y, true);
+                dataView.setFloat32(offset + 8, node.z, true);
+
+                // Velocity (vec3<f32>)
+                dataView.setFloat32(offset + 12, node.vx || 0, true);
+                dataView.setFloat32(offset + 16, node.vy || 0, true);
+                dataView.setFloat32(offset + 20, node.vz || 0, true);
+            }
+        });
+
+        if (hasChanges) {
+            // Dispatch binary data event
+            window.dispatchEvent(new CustomEvent('positionUpdate', {
+                detail: buffer
+            }));
+        }
+    }
+
+    // Handle incoming position updates from server
+    applyPositionUpdates(positions) {
+        if (!this.lastPositions) return;
+
+        // Handle binary data format (24 bytes per node)
+        if (positions instanceof ArrayBuffer) {
+            const dataView = new DataView(positions);
+            for (let i = 0; i < this.lastPositions.length; i++) {
+                const offset = i * 24;
+                this.lastPositions[i] = {
+                    x: dataView.getFloat32(offset, true),
+                    y: dataView.getFloat32(offset + 4, true),
+                    z: dataView.getFloat32(offset + 8, true)
+                };
+            }
         }
     }
 
@@ -166,8 +139,8 @@ export class LayoutManager {
         const animate = () => {
             if (!this.isSimulating) return;
             
-            // Perform continuous gentle refinement
-            this.performLayout(graphData, 1);
+            // Send position updates at regular intervals
+            this.performLayout(graphData);
             this.animationFrameId = requestAnimationFrame(animate);
         };
         
@@ -182,14 +155,19 @@ export class LayoutManager {
         }
     }
 
-    updateFeature(control, value) {
-        switch (control) {
-            case 'force_directed_spring':
-                this.forceDirectedSpring = value;
-                break;
-            case 'force_directed_damping':
-                this.forceDirectedDamping = value;
-                break;
+    update() {
+        if (!this.needsUpdate) return;
+        
+        const now = Date.now();
+        if (now - this.lastUpdateTime >= this.updateInterval) {
+            this.lastUpdateTime = now;
+            
+            // Send position updates
+            window.dispatchEvent(new CustomEvent('positionUpdate', {
+                detail: this.positionBuffer
+            }));
+            
+            this.needsUpdate = false;
         }
     }
 }
diff --git a/data/public/js/components/visualization/nodes.js b/data/public/js/components/visualization/nodes.js
index f658fdd1..8aa782b7 100644
--- a/data/public/js/components/visualization/nodes.js
+++ b/data/public/js/components/visualization/nodes.js
@@ -347,6 +347,88 @@ export class NodeManager {
         }
     }
 
+    updateNodePositions(positions) {
+        // Handle array-based format (new binary format)
+        if (Array.isArray(positions)) {
+            positions.forEach((position, index) => {
+                const nodeId = Array.from(this.nodeMeshes.keys())[index];
+                if (!nodeId) return;
+
+                const mesh = this.nodeMeshes.get(nodeId);
+                const label = this.nodeLabels.get(nodeId);
+                
+                if (mesh) {
+                    const [x, y, z] = position;
+                    mesh.position.set(x, y, z);
+                    
+                    if (label) {
+                        const size = mesh.geometry.parameters.radius || 
+                                   mesh.geometry.parameters.width || 
+                                   1; // fallback size
+                        label.position.set(x, y + size + 2, z);
+                    }
+
+                    // Update connected edges
+                    this.updateEdgesForNode(nodeId);
+                }
+            });
+        }
+        // Handle legacy object-based format
+        else if (typeof positions === 'object') {
+            Object.entries(positions).forEach(([index, position]) => {
+                const nodeId = Array.from(this.nodeMeshes.keys())[index];
+                if (!nodeId) return;
+
+                const mesh = this.nodeMeshes.get(nodeId);
+                const label = this.nodeLabels.get(nodeId);
+                
+                if (mesh) {
+                    mesh.position.set(position.x, position.y, position.z);
+                    
+                    if (label) {
+                        const size = mesh.geometry.parameters.radius || 
+                                   mesh.geometry.parameters.width || 
+                                   1; // fallback size
+                        label.position.set(position.x, position.y + size + 2, position.z);
+                    }
+
+                    // Update connected edges
+                    this.updateEdgesForNode(nodeId);
+                }
+            });
+        }
+    }
+
+    // Helper method to update edges for a specific node
+    updateEdgesForNode(nodeId) {
+        this.edgeMeshes.forEach((line, edgeKey) => {
+            const [source, target] = edgeKey.split('-');
+            if (source === nodeId || target === nodeId) {
+                const positions = line.geometry.attributes.position.array;
+                const sourceMesh = this.nodeMeshes.get(source);
+                const targetMesh = this.nodeMeshes.get(target);
+
+                if (sourceMesh && targetMesh) {
+                    positions[0] = sourceMesh.position.x;
+                    positions[1] = sourceMesh.position.y;
+                    positions[2] = sourceMesh.position.z;
+                    positions[3] = targetMesh.position.x;
+                    positions[4] = targetMesh.position.y;
+                    positions[5] = targetMesh.position.z;
+                    line.geometry.attributes.position.needsUpdate = true;
+                }
+            }
+        });
+    }
+
+    getNodePositions() {
+        return Array.from(this.nodeMeshes.values()).map(mesh => [
+            mesh.position.x,
+            mesh.position.y,
+            mesh.position.z
+        ]);
+    }
+
     dispose() {
         // Dispose node resources
         this.nodeMeshes.forEach(mesh => {
diff --git a/data/public/js/services/graphDataManager.js b/data/public/js/services/graphDataManager.js
index 1c062b06..7cd1df06 100644
--- a/data/public/js/services/graphDataManager.js
+++ b/data/public/js/services/graphDataManager.js
@@ -13,14 +13,15 @@ export class GraphDataManager {
         this.graphData = null;
         this.forceDirectedParams = {
             iterations: 100,
-            repulsion_strength: 1.0,
-            attraction_strength: 0.01,
+            repulsionStrength: 1.0,
+            attractionStrength: 0.01,
             damping: 0.9
         };
         console.log('GraphDataManager initialized');
         
-        // Set up WebSocket graph update listener
+        // Set up WebSocket message listeners
         this.websocketService.on('graphUpdate', this.handleGraphUpdate.bind(this));
+        this.websocketService.on('gpuPositions', this.handleGPUPositions.bind(this));
     }
 
     /**
@@ -32,7 +33,39 @@ export class GraphDataManager {
     }
 
     /**
-     * Handles incoming graph update messages.
+     * Handles GPU-computed position updates from the server.
+     * @param {object} update - The position update data.
+     */
+    handleGPUPositions(update) {
+        if (!this.graphData || !this.graphData.nodes) {
+            console.error('Cannot apply GPU position update: No graph data exists');
+            return;
+        }
+
+        const { positions } = update;
+        
+        // Update node positions from GPU computation
+        this.graphData.nodes.forEach((node, index) => {
+            if (positions[index]) {
+                const [x, y, z] = positions[index];
+                node.x = x;
+                node.y = y;
+                node.z = z;
+                // Clear velocities since GPU is handling movement
+                node.vx = 0;
+                node.vy = 0;
+                node.vz = 0;
+            }
+        });
+
+        // Notify visualization of position updates
+        window.dispatchEvent(new CustomEvent('graphDataUpdated', { 
+            detail: this.graphData 
+        }));
+    }
+
+    /**
+     * Handles graph update messages.
      * @param {object} data - The received graph data.
      */
     handleGraphUpdate(data) {
@@ -129,14 +162,6 @@ export class GraphDataManager {
 
         console.log(`Graph data updated: ${this.graphData.nodes.length} nodes, ${this.graphData.edges.length} edges`);
         
-        // Log some sample data
-        if (this.graphData.nodes.length > 0) {
-            console.log('Sample node:', this.graphData.nodes[0]);
-        }
-        if (this.graphData.edges.length > 0) {
-            console.log('Sample edge:', this.graphData.edges[0]);
-        }
-        
         // Dispatch an event to notify that the graph data has been updated
         window.dispatchEvent(new CustomEvent('graphDataUpdated', { detail: this.graphData }));
     }
@@ -174,16 +199,14 @@ export class GraphDataManager {
         console.log(`Updating force-directed parameter: ${name} = ${value}`);
         const paramMap = {
             'iterations': 'iterations',
-            'repulsion_strength': 'repulsion_strength',
-            'attraction_strength': 'attraction_strength'
+            'repulsionStrength': 'repulsionStrength',
+            'attractionStrength': 'attractionStrength'
         };
 
         const serverParamName = paramMap[name];
         if (serverParamName) {
             this.forceDirectedParams[serverParamName] = value;
             console.log('Force-directed parameters updated:', this.forceDirectedParams);
-            
-            // Request server recalculation with new parameters
             this.recalculateLayout();
         } else {
             console.warn(`Unknown force-directed parameter: ${name}`);
@@ -200,8 +223,7 @@ export class GraphDataManager {
                 type: 'recalculateLayout',
                 params: {
                     iterations: this.forceDirectedParams.iterations,
-                    repulsion_strength: this.forceDirectedParams.repulsion_strength,
-                    attraction_strength: this.forceDirectedParams.attraction_strength,
+                    springStrength: this.forceDirectedParams.attractionStrength,
                     damping: this.forceDirectedParams.damping
                 }
             });
diff --git a/data/public/js/services/websocketService.js b/data/public/js/services/websocketService.js
index 05cb09f0..7cce19ed 100644
--- a/data/public/js/services/websocketService.js
+++ b/data/public/js/services/websocketService.js
@@ -1,6 +1,4 @@
 // WebSocket service for handling real-time communication
-import pako from 'pako';
-
 export default class WebsocketService {
     constructor() {
         // Initialize with environment variables from .env_template
@@ -33,7 +31,13 @@ export default class WebsocketService {
         this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
         this.audioQueue = [];
         this.isPlaying = false;
-        this.COMPRESSION_MAGIC = new Uint8Array([67, 79, 77, 80]); // "COMP" in ASCII
+        
+        // Force-directed parameters
+        this.forceDirectedParams = {
+            iterations: 100,
+            attraction_strength: 0.01,
+            damping: 0.9
+        };
         
         this.connect();
     }
@@ -48,7 +52,6 @@ export default class WebsocketService {
         const url = this.getWebSocketUrl();
         console.log('Attempting to connect to WebSocket at:', url);
         this.socket = new WebSocket(url);
-        this.socket.binaryType = 'arraybuffer';  // Set to handle binary data
 
         this.socket.onopen = () => {
             console.log('WebSocket connection established');
@@ -62,17 +65,30 @@ export default class WebsocketService {
 
         this.socket.onmessage = async (event) => {
             try {
-                let data;
-                if (event.data instanceof ArrayBuffer) {
-                    // Handle binary data (might be compressed)
-                    const decompressed = this.decompressMessage(event.data);
-                    data = JSON.parse(decompressed);
-                    console.log('Received message:', data);
-                } else {
-                    // Handle regular JSON messages
-                    data = JSON.parse(event.data);
-                    console.log('Received JSON message:', data);
+                // Handle binary messages (GPU position updates)
+                if (event.data instanceof Blob) {
+                    const arrayBuffer = await event.data.arrayBuffer();
+                    const positions = new Float32Array(arrayBuffer);
+                    const positionArray = [];
+                    
+                    // Each position is 3 float values (x, y, z)
+                    for (let i = 0; i < positions.length; i += 3) {
+                        positionArray.push([
+                            positions[i],
+                            positions[i + 1],
+                            positions[i + 2]
+                        ]);
+                    }
+                    
+                    this.emit('gpuPositions', {
+                        positions: positionArray
+                    });
+                    return;
                 }
+
+                // Handle JSON messages
+                const data = JSON.parse(event.data);
+                console.log('Received message:', data);
                 this.handleServerMessage(data);
             } catch (error) {
                 console.error('Error processing WebSocket message:', error);
@@ -151,77 +167,6 @@ export default class WebsocketService {
         }
     }
 
-    hasCompressionHeader(data) {
-        if (data.length < this.COMPRESSION_MAGIC.length) return false;
-        for (let i = 0; i < this.COMPRESSION_MAGIC.length; i++) {
-            if (data[i] !== this.COMPRESSION_MAGIC[i]) return false;
-        }
-        return true;
-    }
-
-    logBytes(data, label) {
-        const hex = Array.from(data)
-            .map(b => b.toString(16).padStart(2, '0'))
-            .join(' ');
-        const ascii = Array.from(data)
-            .map(b => b >= 32 && b <= 126 ? String.fromCharCode(b) : '.')
-            .join('');
-        console.log(`${label} (${data.length} bytes):`);
-        console.log('Hex:', hex);
-        console.log('ASCII:', ascii);
-    }
-
-    decompressMessage(compressed) {
-        try {
-            const data = new Uint8Array(compressed);
-            this.logBytes(data.slice(0, Math.min(32, data.length)), 'First 32 bytes of message');
-            
-            // Try parsing as JSON first (uncompressed message)
-            try {
-                const text = new TextDecoder().decode(data);
-                const json = JSON.parse(text);
-                console.log('Successfully parsed as uncompressed JSON:', json);
-                return text;
-            } catch (e) {
-                console.log('Not valid JSON, trying decompression...');
-            }
-
-            // Check for compression magic header
-            const headerBytes = data.slice(0, this.COMPRESSION_MAGIC.length);
-            this.logBytes(headerBytes, 'Header bytes');
-            
-            if (!this.hasCompressionHeader(data)) {
-                console.log('No compression header found, trying raw decompression');
-                try {
-                    // Use raw inflate to match miniz_oxide format
-                    const decompressed = pako.inflate(data, { raw: true });
-                    const text = new TextDecoder().decode(decompressed);
-                    console.log('Successfully decompressed without header:', text);
-                    return text;
-                } catch (e) {
-                    console.error('Failed to decompress without header:', e);
-                    throw e;
-                }
-            }
-
-            // Skip the magic header and decompress the rest
-            const compressedData = data.slice(this.COMPRESSION_MAGIC.length);
-            this.logBytes(compressedData.slice(0, Math.min(32, compressedData.length)), 'First 32 bytes of compressed data');
-            
-            // Use raw inflate to match miniz_oxide format
-            const decompressed = pako.inflate(compressedData, { raw: true });
-            const text = new TextDecoder().decode(decompressed);
-            console.log('Successfully decompressed with header:', text);
-            return text;
-        } catch (error) {
-            console.error('Error in decompressMessage:', error);
-            // Log the entire buffer for debugging
-            const fullData = new Uint8Array(compressed);
-            this.logBytes(fullData, 'Full message content');
-            throw error;
-        }
-    }
-
     handleServerMessage(data) {
         console.log('Handling server message:', data);
         
@@ -265,15 +210,15 @@ export default class WebsocketService {
                 }
                 break;
                 
-            case 'graph_update':
+            case 'graphUpdate':
                 console.log('Received graph update:', data.graph_data);
                 if (data.graph_data) {
                     this.emit('graphUpdate', { graphData: data.graph_data });
                 }
                 break;
                 
-            case 'audio':
-                this.handleAudioData(data.audio);
+            case 'audioData':
+                this.handleAudioData(data.audio_data);
                 break;
                 
             case 'answer':
@@ -293,12 +238,12 @@ export default class WebsocketService {
                 this.emit('openaiResponse', data.response);
                 break;
                 
-            case 'simulation_mode_set':
+            case 'simulationModeSet':
                 console.log('Simulation mode set:', data.mode);
                 this.emit('simulationModeSet', data.mode);
                 break;
 
-            case 'fisheye_settings_updated':
+            case 'fisheyeSettingsUpdated':
                 console.log('Fisheye settings updated:', data);
                 // Convert focus_point to focusPoint for client-side consistency
                 const settings = {
@@ -431,7 +376,7 @@ export default class WebsocketService {
         this.send({
             type: 'chatMessage',
             message,
-            tts_provider: useOpenAI ? 'openai' : 'sonata'
+            use_openai: useOpenAI
         });
     }
 
@@ -443,7 +388,7 @@ export default class WebsocketService {
             type: 'updateFisheyeSettings',
             enabled: settings.enabled,
             strength: settings.strength,
-            focus_point: focus_point, // Use snake_case to match Rust struct
+            focus_point: focus_point,
             radius: settings.radius || 100.0
         });
     }
diff --git a/diff.patch b/diff.patch
new file mode 100644
index 00000000..f0a95b17
--- /dev/null
+++ b/diff.patch
@@ -0,0 +1,2411 @@
+diff --git a/data/public/js/components/visualization/core.js b/data/public/js/components/visualization/core.js
+index 5d5cfee3..f1203c4d 100644
+--- a/data/public/js/components/visualization/core.js
++++ b/data/public/js/components/visualization/core.js
+@@ -28,6 +28,8 @@ export class WebXRVisualization {
+ 
+         this.controls = null;
+         this.animationFrameId = null;
++        this.lastPositionUpdate = 0;
++        this.positionUpdateThreshold = 16; // ~60fps for smooth updates
+ 
+         // Get initial settings
+         const settings = visualizationSettings.getSettings();
+@@ -45,7 +47,7 @@ export class WebXRVisualization {
+         // Initialize settings
+         this.initializeSettings();
+ 
+-        // Add event listeners for graph data and position updates
++        // Add event listeners for updates
+         window.addEventListener('graphDataUpdated', (event) => {
+             console.log('Received graphDataUpdated event:', event.detail);
+             this.updateVisualization();
+@@ -56,27 +58,79 @@ export class WebXRVisualization {
+             this.updateSettings(event.detail);
+         });
+ 
+-        // Handle position updates from layout manager
+-        window.addEventListener('positionUpdate', (event) => {
+-            console.log('Received position update:', event.detail);
+-            if (this.graphDataManager.websocketService) {
+-                this.graphDataManager.websocketService.sendGraphMessage(event.detail);
++        // Add event listener for node position updates from server
++        window.addEventListener('nodePositionsUpdated', (event) => {
++            if (event.detail instanceof ArrayBuffer) {
++                this.handleBinaryPositionUpdate(event.detail);
+             }
+         });
+ 
+-        // Handle incoming position updates from other clients
+-        window.addEventListener('graphPositionsUpdated', (event) => {
+-            console.log('Received position update from server:', event.detail);
+-            const { positions } = event.detail;
+-            if (this.layoutManager) {
+-                this.layoutManager.applyPositionUpdates(positions);
+-                this.nodeManager.updateNodePositions(positions);
+-            }
++        // Add event listener for node drag events
++        window.addEventListener('nodeDragged', (event) => {
++            const { nodeId, position } = event.detail;
++            this.handleNodeDrag(nodeId, position);
+         });
+ 
+         console.log('WebXRVisualization constructor completed');
+     }
+ 
++    handleBinaryPositionUpdate(buffer) {
++        const positions = new Float32Array(buffer);
++        const updates = [];
++        
++        // Each position update contains 6 float values (x,y,z, vx,vy,vz)
++        for (let i = 0; i < positions.length; i += 6) {
++            updates.push({
++                position: new THREE.Vector3(
++                    positions[i],
++                    positions[i + 1],
++                    positions[i + 2]
++                ),
++                velocity: new THREE.Vector3(
++                    positions[i + 3],
++                    positions[i + 4],
++                    positions[i + 5]
++                )
++            });
++        }
++
++        // Update node positions through the node manager
++        this.nodeManager.updateNodePositions(updates);
++    }
++
++    handleNodeDrag(nodeId, position) {
++        // Update local node position
++        this.nodeManager.updateNodePosition(nodeId, position);
++
++        // Send position update to server if enough time has passed
++        const now = Date.now();
++        if (now - this.lastPositionUpdate >= this.positionUpdateThreshold) {
++            this.lastPositionUpdate = now;
++            
++            // Get all node positions for synchronization
++            const positions = this.nodeManager.getNodePositions();
++            
++            // Create binary position data
++            const buffer = new ArrayBuffer(positions.length * 24); // 6 floats per node (x,y,z, vx,vy,vz)
++            const view = new Float32Array(buffer);
++            
++            positions.forEach((pos, index) => {
++                const offset = index * 6;
++                view[offset] = pos.position.x;
++                view[offset + 1] = pos.position.y;
++                view[offset + 2] = pos.position.z;
++                view[offset + 3] = pos.velocity.x;
++                view[offset + 4] = pos.velocity.y;
++                view[offset + 5] = pos.velocity.z;
++            });
++
++            // Dispatch binary position update
++            window.dispatchEvent(new CustomEvent('positionUpdate', {
++                detail: buffer
++            }));
++        }
++    }
++
+     updateSettings(settings) {
+         console.log('Updating settings:', settings);
+         if (!settings) return;
+@@ -172,8 +226,12 @@ export class WebXRVisualization {
+ 
+     animate() {
+         this.animationFrameId = requestAnimationFrame(this.animate.bind(this));
++        
++        // Update controls and layout
+         this.controls.update();
++        this.layoutManager.update();
+ 
++        // Update visuals
+         this.effectsManager.animate();
+         this.nodeManager.updateLabelOrientations(this.camera);
+         this.effectsManager.render();
+diff --git a/data/public/js/components/visualization/layout.js b/data/public/js/components/visualization/layout.js
+index 4ffb4963..9f7c3083 100644
+--- a/data/public/js/components/visualization/layout.js
++++ b/data/public/js/components/visualization/layout.js
+@@ -15,7 +15,8 @@ export class LayoutManager {
+         this.lastPositions = null;       // Store previous positions for change detection
+         this.updateThreshold = 0.001;    // Minimum position change to trigger update
+         this.lastUpdateTime = 0;         // Last time positions were sent to server
+-        this.updateInterval = 50;        // Minimum ms between position updates
++        this.updateInterval = 16;        // ~60fps for smooth updates
++        this.currentGraphData = null;    // Store current graph data
+     }
+ 
+     initializePositions(nodes) {
+@@ -36,7 +37,7 @@ export class LayoutManager {
+             if (!node.vz) node.vz = 0;
+         });
+ 
+-        // Initialize last positions
++        // Initialize last positions for change detection
+         this.lastPositions = nodes.map(node => ({
+             x: node.x,
+             y: node.y,
+@@ -44,7 +45,26 @@ export class LayoutManager {
+         }));
+     }
+ 
+-    calculateSpringForce(pos1, pos2, mass1, mass2, isConnected) {
++    // Update position of a node (e.g., from VR interaction)
++    updateNodePosition(nodeId, position, nodes) {
++        const node = nodes.find(n => n.id === nodeId);
++        if (!node) return;
++
++        // Update node position
++        node.x = position.x;
++        node.y = position.y;
++        node.z = position.z;
++        
++        // Clear velocity since position was directly set
++        node.vx = 0;
++        node.vy = 0;
++        node.vz = 0;
++
++        // Send immediate update of all positions
++        this.sendPositionUpdates(nodes);
++    }
++
++    calculateSpringForce(pos1, pos2, mass1, mass2, isConnected, weight = 1.0) {
+         const dx = pos2.x - pos1.x;
+         const dy = pos2.y - pos1.y;
+         const dz = pos2.z - pos1.z;
+@@ -52,8 +72,10 @@ export class LayoutManager {
+ 
+         let forceMagnitude;
+         if (isConnected) {
+-            forceMagnitude = this.forceDirectedSpring * (distance - this.naturalLength);
++            // Use edge weight to scale the spring force
++            forceMagnitude = this.forceDirectedSpring * (distance - this.naturalLength) * weight;
+         } else {
++            // Use node masses for repulsion
+             forceMagnitude = -this.forceDirectedSpring * mass1 * mass2 / (distance * distance + 0.1);
+         }
+ 
+@@ -68,6 +90,7 @@ export class LayoutManager {
+     }
+ 
+     applyForceDirectedLayout(graphData, onComplete) {
++        this.currentGraphData = graphData;
+         const nodes = graphData.nodes;
+         
+         // Initialize positions if needed
+@@ -79,18 +102,19 @@ export class LayoutManager {
+         }
+ 
+         // Perform a single iteration of force-directed layout
+-        this.performLayout(graphData, this.updateIterations);
++        this.performLayout(graphData);
+         
+         if (onComplete) {
+             onComplete();
+         }
+     }
+ 
+-    performLayout(graphData, iterations) {
+-        const nodes = graphData.nodes;
+-        const edges = graphData.edges;
++    performLayout(graphData) {
++        const now = Date.now();
++        if (now - this.lastUpdateTime >= this.updateInterval) {
++            const nodes = graphData.nodes;
++            const edges = graphData.edges;
+ 
+-        for (let iteration = 0; iteration < iterations; iteration++) {
+             // Calculate forces between all nodes
+             for (let i = 0; i < nodes.length; i++) {
+                 for (let j = i + 1; j < nodes.length; j++) {
+@@ -117,7 +141,8 @@ export class LayoutManager {
+                     const force = this.calculateSpringForce(
+                         source, target,
+                         source.mass || 1, target.mass || 1,
+-                        true
++                        true,
++                        edge.weight || 1.0
+                     );
+ 
+                     source.vx += force.fx;
+@@ -129,13 +154,15 @@ export class LayoutManager {
+                 }
+             });
+ 
+-            // Apply centering force and update positions
++            // Apply forces and update positions
+             const maxVelocity = 10.0;
+-            nodes.forEach(node => {
++            let hasChanges = false;
++
++            nodes.forEach((node, index) => {
+                 // Centering force
+                 const distance = Math.sqrt(node.x * node.x + node.y * node.y + node.z * node.z);
+                 if (distance > this.targetRadius) {
+-                    const centerForce = 0.05 * (distance - this.targetRadius); // Reduced strength
++                    const centerForce = 0.05 * (distance - this.targetRadius);
+                     node.vx -= (node.x / distance) * centerForce;
+                     node.vy -= (node.y / distance) * centerForce;
+                     node.vz -= (node.z / distance) * centerForce;
+@@ -155,60 +182,93 @@ export class LayoutManager {
+                     node.vz *= scale;
+                 }
+ 
+-                // Update positions with smaller step size for smoother motion
++                // Update positions
++                const oldPos = this.lastPositions[index];
+                 const stepSize = 0.5;
+-                node.x += node.vx * stepSize;
+-                node.y += node.vy * stepSize;
+-                node.z += node.vz * stepSize;
+-
+-                // Ensure positions stay within bounds
+-                const maxCoord = 100.0;
+-                node.x = Math.max(Math.min(node.x, maxCoord), -maxCoord);
+-                node.y = Math.max(Math.min(node.y, maxCoord), -maxCoord);
+-                node.z = Math.max(Math.min(node.z, maxCoord), -maxCoord);
++                const newX = node.x + node.vx * stepSize;
++                const newY = node.y + node.vy * stepSize;
++                const newZ = node.z + node.vz * stepSize;
++
++                // Check if position changed significantly
++                if (Math.abs(newX - oldPos.x) > this.updateThreshold ||
++                    Math.abs(newY - oldPos.y) > this.updateThreshold ||
++                    Math.abs(newZ - oldPos.z) > this.updateThreshold) {
++                    hasChanges = true;
++                    
++                    // Update position with bounds checking
++                    const maxCoord = 100.0;
++                    node.x = Math.max(Math.min(newX, maxCoord), -maxCoord);
++                    node.y = Math.max(Math.min(newY, maxCoord), -maxCoord);
++                    node.z = Math.max(Math.min(newZ, maxCoord), -maxCoord);
++                    
++                    // Update last position
++                    oldPos.x = node.x;
++                    oldPos.y = node.y;
++                    oldPos.z = node.z;
++                }
+             });
+-        }
+ 
+-        // Check if we should send position updates
+-        const now = Date.now();
+-        if (now - this.lastUpdateTime >= this.updateInterval) {
+-            this.sendPositionUpdates(nodes);
+-            this.lastUpdateTime = now;
++            // Send position updates if there were significant changes
++            if (hasChanges) {
++                this.sendPositionUpdates(nodes);
++                this.lastUpdateTime = now;
++            }
+         }
+     }
+ 
+     sendPositionUpdates(nodes) {
+-        if (!this.lastPositions) return;
++        // Create binary buffer for position updates
++        const buffer = new ArrayBuffer(nodes.length * 24); // 6 floats per node (x,y,z, vx,vy,vz)
++        const dataView = new DataView(buffer);
+ 
+-        // Convert to array format for binary transmission
+-        const positions = nodes.map((node, index) => {
+-            const lastPos = this.lastPositions[index];
+-            if (!lastPos) return [node.x, node.y, node.z];
++        nodes.forEach((node, index) => {
++            const offset = index * 24;
++            
++            // Position (vec3<f32>)
++            dataView.setFloat32(offset, node.x, true);
++            dataView.setFloat32(offset + 4, node.y, true);
++            dataView.setFloat32(offset + 8, node.z, true);
+ 
+-            // Check if position has changed significantly
+-            if (Math.abs(node.x - lastPos.x) > this.updateThreshold ||
+-                Math.abs(node.y - lastPos.y) > this.updateThreshold ||
+-                Math.abs(node.z - lastPos.z) > this.updateThreshold) {
+-                
+-                // Update last position
+-                lastPos.x = node.x;
+-                lastPos.y = node.y;
+-                lastPos.z = node.z;
+-                
+-                return [node.x, node.y, node.z];
+-            }
+-            return [lastPos.x, lastPos.y, lastPos.z];
++            // Velocity (vec3<f32>)
++            dataView.setFloat32(offset + 12, node.vx || 0, true);
++            dataView.setFloat32(offset + 16, node.vy || 0, true);
++            dataView.setFloat32(offset + 20, node.vz || 0, true);
+         });
+ 
+-        // Send position update event
++        // Dispatch binary data event
+         window.dispatchEvent(new CustomEvent('positionUpdate', {
+-            detail: {
+-                type: 'PositionUpdate',
+-                positions: positions
+-            }
++            detail: buffer
+         }));
+     }
+ 
++    // Handle incoming position updates from server
++    applyPositionUpdates(buffer) {
++        if (!this.lastPositions || !this.currentGraphData) return;
++
++        const dataView = new DataView(buffer);
++        const nodes = this.currentGraphData.nodes;
++
++        for (let i = 0; i < nodes.length; i++) {
++            const offset = i * 24;
++            const node = nodes[i];
++            
++            // Update position and velocity
++            node.x = dataView.getFloat32(offset, true);
++            node.y = dataView.getFloat32(offset + 4, true);
++            node.z = dataView.getFloat32(offset + 8, true);
++            node.vx = dataView.getFloat32(offset + 12, true);
++            node.vy = dataView.getFloat32(offset + 16, true);
++            node.vz = dataView.getFloat32(offset + 20, true);
++
++            // Update last positions
++            this.lastPositions[i] = {
++                x: node.x,
++                y: node.y,
++                z: node.z
++            };
++        }
++    }
++
+     startContinuousSimulation(graphData) {
+         if (this.isSimulating) return;
+         
+@@ -216,8 +276,8 @@ export class LayoutManager {
+         const animate = () => {
+             if (!this.isSimulating) return;
+             
+-            // Perform continuous gentle refinement
+-            this.performLayout(graphData, 1);
++            // Send position updates at regular intervals
++            this.performLayout(graphData);
+             this.animationFrameId = requestAnimationFrame(animate);
+         };
+         
+@@ -242,28 +302,4 @@ export class LayoutManager {
+                 break;
+         }
+     }
+-
+-    // Handle incoming position updates from server
+-    applyPositionUpdates(positions) {
+-        if (!this.lastPositions) return;
+-
+-        // Handle array-based format (new binary format)
+-        if (Array.isArray(positions)) {
+-            positions.forEach((position, index) => {
+-                if (this.lastPositions[index]) {
+-                    const [x, y, z] = position;
+-                    this.lastPositions[index] = { x, y, z };
+-                }
+-            });
+-        }
+-        // Handle legacy object-based format
+-        else if (typeof positions === 'object') {
+-            Object.entries(positions).forEach(([index, position]) => {
+-                const idx = parseInt(index);
+-                if (this.lastPositions[idx]) {
+-                    this.lastPositions[idx] = position;
+-                }
+-            });
+-        }
+-    }
+ }
+diff --git a/data/public/js/components/visualization/nodes.js b/data/public/js/components/visualization/nodes.js
+index 8aa782b7..e3ddaa64 100644
+--- a/data/public/js/components/visualization/nodes.js
++++ b/data/public/js/components/visualization/nodes.js
+@@ -4,12 +4,9 @@ import * as THREE from 'three';
+ export const BLOOM_LAYER = 1;
+ export const NORMAL_LAYER = 0;
+ 
+-export const NODE_COLORS = {
+-    NEW: new THREE.Color(0x00ff88),      // Bright green for very recent files (< 3 days)
+-    RECENT: new THREE.Color(0x4444ff),    // Blue for recent files (< 7 days)
+-    MEDIUM: new THREE.Color(0xffaa00),    // Orange for medium-age files (< 30 days)
+-    OLD: new THREE.Color(0xff4444)        // Red for old files (>= 30 days)
+-};
++// Base colors for age interpolation
++const NEW_COLOR = new THREE.Color(0x00ff00); // Green for newest
++const OLD_COLOR = new THREE.Color(0xff0000); // Red for oldest
+ 
+ export const NODE_SHAPES = {
+     FEW_LINKS: 'sphere',      // 0-5 links
+@@ -26,45 +23,155 @@ export class NodeManager {
+         this.edgeMeshes = new Map();
+         
+         // Node settings
+-        this.minNodeSize = 0.1;  // Minimum node size in visualization
+-        this.maxNodeSize = 5;    // Maximum node size in visualization
+-        this.nodeSizeScalingFactor = 1;  // Global scaling factor
++        this.minNodeSize = 0.1;
++        this.maxNodeSize = 5;
++        this.nodeSizeScalingFactor = 1;
+         this.labelFontSize = 18;
+-        this.nodeColor = new THREE.Color(0x4444ff);  // Initialize as THREE.Color
++        this.colorSaturation = 1.0;
++        this.colorBrightness = 1.0;
+ 
+         // Edge settings
+-        this.edgeColor = new THREE.Color(0x4444ff);  // Initialize as THREE.Color
++        this.edgeColor = new THREE.Color(0x4444ff);
+         this.edgeOpacity = 0.6;
+ 
+-        // Server-side node size range (must match constants in file_service.rs)
++        // Server-side node size range
+         this.serverMinNodeSize = 5.0;
+         this.serverMaxNodeSize = 50.0;
++
++        // Track oldest and newest dates for normalization
++        this.oldestDate = new Date().getTime();
++        this.newestDate = 0;
++    }
++
++    updateDateRange(nodes) {
++        let oldest = new Date().getTime();
++        let newest = 0;
++
++        nodes.forEach(node => {
++            const metadata = node.metadata || {};
++            const lastModified = new Date(metadata.last_modified || new Date()).getTime();
++            oldest = Math.min(oldest, lastModified);
++            newest = Math.max(newest, lastModified);
++        });
++
++        this.oldestDate = oldest;
++        this.newestDate = newest;
++    }
++
++    calculateNodeColor(lastModified) {
++        const timestamp = new Date(lastModified).getTime();
++        
++        // Normalize age to 0-1 range
++        const ageRange = this.newestDate - this.oldestDate;
++        const normalizedAge = ageRange === 0 ? 0 : 
++            (timestamp - this.oldestDate) / ageRange;
++
++        // Create interpolated color
++        const color = new THREE.Color();
++        color.copy(OLD_COLOR).lerp(NEW_COLOR, normalizedAge);
++
++        // Apply saturation and brightness
++        const hsl = {};
++        color.getHSL(hsl);
++        color.setHSL(
++            hsl.h, // Keep the interpolated hue
++            hsl.s * this.colorSaturation, // Apply saturation control
++            hsl.l * this.colorBrightness  // Apply brightness control
++        );
++
++        return color;
++    }
++
++    updateNodePositions(updates) {
++        updates.forEach((update, index) => {
++            const nodeId = Array.from(this.nodeMeshes.keys())[index];
++            if (!nodeId) return;
++
++            const mesh = this.nodeMeshes.get(nodeId);
++            const label = this.nodeLabels.get(nodeId);
++            
++            if (mesh) {
++                mesh.position.copy(update.position);
++                
++                if (label) {
++                    const size = mesh.geometry.parameters.radius || 
++                               mesh.geometry.parameters.width || 
++                               1;
++                    label.position.set(
++                        update.position.x,
++                        update.position.y + size + 2,
++                        update.position.z
++                    );
++                }
++
++                this.updateEdgesForNode(nodeId);
++            }
++        });
++    }
++
++    updateNodePosition(nodeId, position) {
++        const mesh = this.nodeMeshes.get(nodeId);
++        const label = this.nodeLabels.get(nodeId);
++        
++        if (mesh) {
++            mesh.position.copy(position);
++            
++            if (label) {
++                const size = mesh.geometry.parameters.radius || 
++                           mesh.geometry.parameters.width || 
++                           1;
++                label.position.set(
++                    position.x,
++                    position.y + size + 2,
++                    position.z
++                );
++            }
++
++            this.updateEdgesForNode(nodeId);
++        }
++    }
++
++    updateEdgesForNode(nodeId) {
++        this.edgeMeshes.forEach((line, edgeKey) => {
++            const [source, target] = edgeKey.split('-');
++            if (source === nodeId || target === nodeId) {
++                const positions = line.geometry.attributes.position.array;
++                const sourceMesh = this.nodeMeshes.get(source);
++                const targetMesh = this.nodeMeshes.get(target);
++
++                if (sourceMesh && targetMesh) {
++                    positions[0] = sourceMesh.position.x;
++                    positions[1] = sourceMesh.position.y;
++                    positions[2] = sourceMesh.position.z;
++                    positions[3] = targetMesh.position.x;
++                    positions[4] = targetMesh.position.y;
++                    positions[5] = targetMesh.position.z;
++                    line.geometry.attributes.position.needsUpdate = true;
++                }
++            }
++        });
++    }
++
++    getNodePositions() {
++        return Array.from(this.nodeMeshes.values()).map(mesh => ({
++            position: mesh.position.clone(),
++            velocity: new THREE.Vector3(0, 0, 0)
++        }));
+     }
+ 
+     getNodeSize(metadata) {
+-        // Use the node_size from metadata if available
+         if (metadata.node_size) {
+-            // Convert from server's range (5.0-50.0) to visualization range (0.1-5.0)
+             const serverSize = parseFloat(metadata.node_size);
+-            const normalizedSize = (serverSize - this.serverMinNodeSize) / (this.serverMaxNodeSize - this.serverMinNodeSize);
+-            return this.minNodeSize + (this.maxNodeSize - this.minNodeSize) * normalizedSize * this.nodeSizeScalingFactor;
++            const normalizedSize = (serverSize - this.serverMinNodeSize) / 
++                                 (this.serverMaxNodeSize - this.serverMinNodeSize);
++            return this.minNodeSize + 
++                   (this.maxNodeSize - this.minNodeSize) * 
++                   normalizedSize * 
++                   this.nodeSizeScalingFactor;
+         }
+-        
+-        // Fallback to a default size if node_size is not available
+         return this.minNodeSize;
+     }
+ 
+-    calculateNodeColor(lastModified) {
+-        const now = Date.now();
+-        const age = now - new Date(lastModified).getTime();
+-        const dayInMs = 24 * 60 * 60 * 1000;
+-        
+-        if (age < 3 * dayInMs) return NODE_COLORS.NEW;        // Less than 3 days old
+-        if (age < 7 * dayInMs) return NODE_COLORS.RECENT;     // Less than 7 days old
+-        if (age < 30 * dayInMs) return NODE_COLORS.MEDIUM;    // Less than 30 days old
+-        return NODE_COLORS.OLD;                               // 30 days or older
+-    }
+-
+     createNodeGeometry(size, hyperlinkCount) {
+         if (hyperlinkCount < 6) {
+             return new THREE.SphereGeometry(size, 32, 32);
+@@ -136,7 +243,6 @@ export class NodeManager {
+     }
+ 
+     centerNodes(nodes) {
+-        // Calculate center of mass
+         let centerX = 0, centerY = 0, centerZ = 0;
+         nodes.forEach(node => {
+             centerX += node.x;
+@@ -147,21 +253,19 @@ export class NodeManager {
+         centerY /= nodes.length;
+         centerZ /= nodes.length;
+ 
+-        // Subtract center from all positions to center around origin
+         nodes.forEach(node => {
+             node.x -= centerX;
+             node.y -= centerY;
+             node.z -= centerZ;
+         });
+ 
+-        // Scale positions to reasonable range
+         const maxDist = nodes.reduce((max, node) => {
+             const dist = Math.sqrt(node.x * node.x + node.y * node.y + node.z * node.z);
+             return Math.max(max, dist);
+         }, 0);
+ 
+         if (maxDist > 0) {
+-            const scale = 100 / maxDist; // Scale to fit in 100 unit radius
++            const scale = 100 / maxDist;
+             nodes.forEach(node => {
+                 node.x *= scale;
+                 node.y *= scale;
+@@ -173,9 +277,10 @@ export class NodeManager {
+     updateNodes(nodes) {
+         console.log(`Updating nodes: ${nodes.length}`);
+         
+-        // Center and scale nodes
+-        this.centerNodes(nodes);
++        // Update date range for color normalization
++        this.updateDateRange(nodes);
+         
++        this.centerNodes(nodes);
+         const existingNodeIds = new Set(nodes.map(node => node.id));
+ 
+         // Remove non-existent nodes
+@@ -212,14 +317,15 @@ export class NodeManager {
+                 const geometry = this.createNodeGeometry(size, hyperlinkCount);
+                 const material = new THREE.MeshStandardMaterial({
+                     color: color,
+-                    metalness: 0.2,  // Reduced for more glow
+-                    roughness: 0.2,  // Reduced for more glow
++                    metalness: 0.2,
++                    roughness: 0.2,
+                     emissive: color,
+-                    emissiveIntensity: 1.0  // Increased from 0.5 to 1.0 for stronger glow
++                    emissiveIntensity: 1.0
+                 });
+ 
+                 mesh = new THREE.Mesh(geometry, material);
+                 mesh.layers.enable(BLOOM_LAYER);
++                mesh.userData.lastModified = lastModified; // Store for color updates
+                 this.scene.add(mesh);
+                 this.nodeMeshes.set(node.id, mesh);
+ 
+@@ -231,7 +337,8 @@ export class NodeManager {
+                 mesh.geometry = this.createNodeGeometry(size, hyperlinkCount);
+                 mesh.material.color.copy(color);
+                 mesh.material.emissive.copy(color);
+-                mesh.material.emissiveIntensity = 1.0; // Ensure updated nodes also have strong glow
++                mesh.material.emissiveIntensity = 1.0;
++                mesh.userData.lastModified = lastModified;
+             }
+ 
+             mesh.position.set(node.x, node.y, node.z);
+@@ -246,7 +353,6 @@ export class NodeManager {
+         console.log(`Updating edges: ${edges.length}`);
+         const existingEdgeKeys = new Set(edges.map(edge => `${edge.source}-${edge.target_node}`));
+ 
+-        // Remove non-existent edges
+         this.edgeMeshes.forEach((line, edgeKey) => {
+             if (!existingEdgeKeys.has(edgeKey)) {
+                 this.scene.remove(line);
+@@ -254,7 +360,6 @@ export class NodeManager {
+             }
+         });
+ 
+-        // Update or create edges
+         edges.forEach(edge => {
+             if (!edge.source || !edge.target_node) {
+                 console.warn('Invalid edge data:', edge);
+@@ -306,17 +411,27 @@ export class NodeManager {
+     updateFeature(control, value) {
+         console.log(`Updating feature: ${control} = ${value}`);
+         switch (control) {
+-            // Node features
+-            case 'nodeColor':
+-                if (typeof value === 'number' || typeof value === 'string') {
+-                    this.nodeColor = new THREE.Color(value);
+-                    this.nodeMeshes.forEach(mesh => {
+-                        if (mesh.material) {
+-                            mesh.material.color.copy(this.nodeColor);
+-                            mesh.material.emissive.copy(this.nodeColor);
+-                        }
+-                    });
+-                }
++            case 'nodeSaturation':
++                this.colorSaturation = value;
++                // Update all node colors
++                this.nodeMeshes.forEach((mesh) => {
++                    if (mesh.material && mesh.userData.lastModified) {
++                        const color = this.calculateNodeColor(mesh.userData.lastModified);
++                        mesh.material.color.copy(color);
++                        mesh.material.emissive.copy(color);
++                    }
++                });
++                break;
++            case 'nodeBrightness':
++                this.colorBrightness = value;
++                // Update all node colors
++                this.nodeMeshes.forEach((mesh) => {
++                    if (mesh.material && mesh.userData.lastModified) {
++                        const color = this.calculateNodeColor(mesh.userData.lastModified);
++                        mesh.material.color.copy(color);
++                        mesh.material.emissive.copy(color);
++                    }
++                });
+                 break;
+             case 'nodeSizeScalingFactor':
+                 this.nodeSizeScalingFactor = value;
+@@ -324,8 +439,6 @@ export class NodeManager {
+             case 'labelFontSize':
+                 this.labelFontSize = value;
+                 break;
+-
+-            // Edge features
+             case 'edgeColor':
+                 if (typeof value === 'number' || typeof value === 'string') {
+                     this.edgeColor = new THREE.Color(value);
+@@ -347,90 +460,7 @@ export class NodeManager {
+         }
+     }
+ 
+-    updateNodePositions(positions) {
+-        // Handle array-based format (new binary format)
+-        if (Array.isArray(positions)) {
+-            positions.forEach((position, index) => {
+-                const nodeId = Array.from(this.nodeMeshes.keys())[index];
+-                if (!nodeId) return;
+-
+-                const mesh = this.nodeMeshes.get(nodeId);
+-                const label = this.nodeLabels.get(nodeId);
+-                
+-                if (mesh) {
+-                    const [x, y, z] = position;
+-                    mesh.position.set(x, y, z);
+-                    
+-                    if (label) {
+-                        const size = mesh.geometry.parameters.radius || 
+-                                   mesh.geometry.parameters.width || 
+-                                   1; // fallback size
+-                        label.position.set(x, y + size + 2, z);
+-                    }
+-
+-                    // Update connected edges
+-                    this.updateEdgesForNode(nodeId);
+-                }
+-            });
+-        }
+-        // Handle legacy object-based format
+-        else if (typeof positions === 'object') {
+-            Object.entries(positions).forEach(([index, position]) => {
+-                const nodeId = Array.from(this.nodeMeshes.keys())[index];
+-                if (!nodeId) return;
+-
+-                const mesh = this.nodeMeshes.get(nodeId);
+-                const label = this.nodeLabels.get(nodeId);
+-                
+-                if (mesh) {
+-                    mesh.position.set(position.x, position.y, position.z);
+-                    
+-                    if (label) {
+-                        const size = mesh.geometry.parameters.radius || 
+-                                   mesh.geometry.parameters.width || 
+-                                   1; // fallback size
+-                        label.position.set(position.x, position.y + size + 2, position.z);
+-                    }
+-
+-                    // Update connected edges
+-                    this.updateEdgesForNode(nodeId);
+-                }
+-            });
+-        }
+-    }
+-
+-    // Helper method to update edges for a specific node
+-    updateEdgesForNode(nodeId) {
+-        this.edgeMeshes.forEach((line, edgeKey) => {
+-            const [source, target] = edgeKey.split('-');
+-            if (source === nodeId || target === nodeId) {
+-                const positions = line.geometry.attributes.position.array;
+-                const sourceMesh = this.nodeMeshes.get(source);
+-                const targetMesh = this.nodeMeshes.get(target);
+-
+-                if (sourceMesh && targetMesh) {
+-                    positions[0] = sourceMesh.position.x;
+-                    positions[1] = sourceMesh.position.y;
+-                    positions[2] = sourceMesh.position.z;
+-                    positions[3] = targetMesh.position.x;
+-                    positions[4] = targetMesh.position.y;
+-                    positions[5] = targetMesh.position.z;
+-                    line.geometry.attributes.position.needsUpdate = true;
+-                }
+-            }
+-        });
+-    }
+-
+-    getNodePositions() {
+-        return Array.from(this.nodeMeshes.values()).map(mesh => [
+-            mesh.position.x,
+-            mesh.position.y,
+-            mesh.position.z
+-        ]);
+-    }
+-
+     dispose() {
+-        // Dispose node resources
+         this.nodeMeshes.forEach(mesh => {
+             if (mesh.geometry) mesh.geometry.dispose();
+             if (mesh.material) mesh.material.dispose();
+@@ -439,8 +469,6 @@ export class NodeManager {
+             if (label.material.map) label.material.map.dispose();
+             if (label.material) label.material.dispose();
+         });
+-
+-        // Dispose edge resources
+         this.edgeMeshes.forEach(line => {
+             if (line.geometry) line.geometry.dispose();
+             if (line.material) line.material.dispose();
+diff --git a/data/public/js/services/graphDataManager.js b/data/public/js/services/graphDataManager.js
+index 7cd1df06..1c062b06 100644
+--- a/data/public/js/services/graphDataManager.js
++++ b/data/public/js/services/graphDataManager.js
+@@ -13,15 +13,14 @@ export class GraphDataManager {
+         this.graphData = null;
+         this.forceDirectedParams = {
+             iterations: 100,
+-            repulsionStrength: 1.0,
+-            attractionStrength: 0.01,
++            repulsion_strength: 1.0,
++            attraction_strength: 0.01,
+             damping: 0.9
+         };
+         console.log('GraphDataManager initialized');
+         
+-        // Set up WebSocket message listeners
++        // Set up WebSocket graph update listener
+         this.websocketService.on('graphUpdate', this.handleGraphUpdate.bind(this));
+-        this.websocketService.on('gpuPositions', this.handleGPUPositions.bind(this));
+     }
+ 
+     /**
+@@ -33,39 +32,7 @@ export class GraphDataManager {
+     }
+ 
+     /**
+-     * Handles GPU-computed position updates from the server.
+-     * @param {object} update - The position update data.
+-     */
+-    handleGPUPositions(update) {
+-        if (!this.graphData || !this.graphData.nodes) {
+-            console.error('Cannot apply GPU position update: No graph data exists');
+-            return;
+-        }
+-
+-        const { positions } = update;
+-        
+-        // Update node positions from GPU computation
+-        this.graphData.nodes.forEach((node, index) => {
+-            if (positions[index]) {
+-                const [x, y, z] = positions[index];
+-                node.x = x;
+-                node.y = y;
+-                node.z = z;
+-                // Clear velocities since GPU is handling movement
+-                node.vx = 0;
+-                node.vy = 0;
+-                node.vz = 0;
+-            }
+-        });
+-
+-        // Notify visualization of position updates
+-        window.dispatchEvent(new CustomEvent('graphDataUpdated', { 
+-            detail: this.graphData 
+-        }));
+-    }
+-
+-    /**
+-     * Handles graph update messages.
++     * Handles incoming graph update messages.
+      * @param {object} data - The received graph data.
+      */
+     handleGraphUpdate(data) {
+@@ -162,6 +129,14 @@ export class GraphDataManager {
+ 
+         console.log(`Graph data updated: ${this.graphData.nodes.length} nodes, ${this.graphData.edges.length} edges`);
+         
++        // Log some sample data
++        if (this.graphData.nodes.length > 0) {
++            console.log('Sample node:', this.graphData.nodes[0]);
++        }
++        if (this.graphData.edges.length > 0) {
++            console.log('Sample edge:', this.graphData.edges[0]);
++        }
++        
+         // Dispatch an event to notify that the graph data has been updated
+         window.dispatchEvent(new CustomEvent('graphDataUpdated', { detail: this.graphData }));
+     }
+@@ -199,14 +174,16 @@ export class GraphDataManager {
+         console.log(`Updating force-directed parameter: ${name} = ${value}`);
+         const paramMap = {
+             'iterations': 'iterations',
+-            'repulsionStrength': 'repulsionStrength',
+-            'attractionStrength': 'attractionStrength'
++            'repulsion_strength': 'repulsion_strength',
++            'attraction_strength': 'attraction_strength'
+         };
+ 
+         const serverParamName = paramMap[name];
+         if (serverParamName) {
+             this.forceDirectedParams[serverParamName] = value;
+             console.log('Force-directed parameters updated:', this.forceDirectedParams);
++            
++            // Request server recalculation with new parameters
+             this.recalculateLayout();
+         } else {
+             console.warn(`Unknown force-directed parameter: ${name}`);
+@@ -223,7 +200,8 @@ export class GraphDataManager {
+                 type: 'recalculateLayout',
+                 params: {
+                     iterations: this.forceDirectedParams.iterations,
+-                    springStrength: this.forceDirectedParams.attractionStrength,
++                    repulsion_strength: this.forceDirectedParams.repulsion_strength,
++                    attraction_strength: this.forceDirectedParams.attraction_strength,
+                     damping: this.forceDirectedParams.damping
+                 }
+             });
+diff --git a/data/public/js/services/websocketService.js b/data/public/js/services/websocketService.js
+index 7cce19ed..79d86a73 100644
+--- a/data/public/js/services/websocketService.js
++++ b/data/public/js/services/websocketService.js
+@@ -1,4 +1,6 @@
+ // WebSocket service for handling real-time communication
++import pako from 'pako';
++
+ export default class WebsocketService {
+     constructor() {
+         // Initialize with environment variables from .env_template
+@@ -32,18 +34,10 @@ export default class WebsocketService {
+         this.audioQueue = [];
+         this.isPlaying = false;
+         
+-        // Force-directed parameters
+-        this.forceDirectedParams = {
+-            iterations: 100,
+-            attraction_strength: 0.01,
+-            damping: 0.9
+-        };
+-        
+         this.connect();
+     }
+ 
+     getWebSocketUrl() {
+-        // Always use wss:// since nginx is handling SSL on 8443
+         const host = window.location.hostname;
+         return `wss://${host}:8443/ws`;
+     }
+@@ -52,44 +46,30 @@ export default class WebsocketService {
+         const url = this.getWebSocketUrl();
+         console.log('Attempting to connect to WebSocket at:', url);
+         this.socket = new WebSocket(url);
++        this.socket.binaryType = 'arraybuffer';
+ 
+         this.socket.onopen = () => {
+             console.log('WebSocket connection established');
+             this.reconnectAttempts = 0;
+             this.emit('open');
+             
+-            // Request initial graph data and settings
+             console.log('Requesting initial data');
+             this.send({ type: 'getInitialData' });
+         };
+ 
+         this.socket.onmessage = async (event) => {
+             try {
+-                // Handle binary messages (GPU position updates)
+-                if (event.data instanceof Blob) {
+-                    const arrayBuffer = await event.data.arrayBuffer();
+-                    const positions = new Float32Array(arrayBuffer);
+-                    const positionArray = [];
+-                    
+-                    // Each position is 3 float values (x, y, z)
+-                    for (let i = 0; i < positions.length; i += 3) {
+-                        positionArray.push([
+-                            positions[i],
+-                            positions[i + 1],
+-                            positions[i + 2]
+-                        ]);
+-                    }
+-                    
+-                    this.emit('gpuPositions', {
+-                        positions: positionArray
+-                    });
+-                    return;
++                if (event.data instanceof ArrayBuffer) {
++                    // Handle binary position updates
++                    window.dispatchEvent(new CustomEvent('nodePositionsUpdated', {
++                        detail: event.data
++                    }));
++                } else {
++                    // Handle JSON messages
++                    const data = JSON.parse(event.data);
++                    console.log('Received JSON message:', data);
++                    this.handleServerMessage(data);
+                 }
+-
+-                // Handle JSON messages
+-                const data = JSON.parse(event.data);
+-                console.log('Received message:', data);
+-                this.handleServerMessage(data);
+             } catch (error) {
+                 console.error('Error processing WebSocket message:', error);
+                 console.error('Raw message:', event.data);
+@@ -126,8 +106,14 @@ export default class WebsocketService {
+ 
+     send(data) {
+         if (this.socket && this.socket.readyState === WebSocket.OPEN) {
+-            console.log('Sending WebSocket message:', data);
+-            this.socket.send(JSON.stringify(data));
++            if (data instanceof ArrayBuffer) {
++                // Send binary data directly
++                this.socket.send(data);
++            } else {
++                // Send JSON data
++                console.log('Sending WebSocket message:', data);
++                this.socket.send(JSON.stringify(data));
++            }
+         } else {
+             console.warn('WebSocket is not open. Unable to send message:', data);
+             this.emit('error', { type: 'send_error', message: 'WebSocket is not open' });
+@@ -170,10 +156,8 @@ export default class WebsocketService {
+     handleServerMessage(data) {
+         console.log('Handling server message:', data);
+         
+-        // First emit the raw message for any listeners that need it
+         this.emit('message', data);
+         
+-        // Then handle specific message types
+         switch (data.type) {
+             case 'getInitialData':
+                 console.log('Received initial data:', data);
+@@ -183,20 +167,16 @@ export default class WebsocketService {
+                 }
+                 if (data.settings) {
+                     console.log('Dispatching server settings:', data.settings);
+-                    // Clean up color values before dispatching
+                     if (data.settings.visualization) {
+                         const viz = data.settings.visualization;
+-                        // Convert color values to proper hex format
+                         ['nodeColor', 'edgeColor', 'hologramColor'].forEach(key => {
+                             if (viz[key]) {
+-                                // Remove quotes and 0x prefix, ensure proper hex format
+-                                let color = viz[key].replace(/['"]/g, '');  // Remove quotes
++                                let color = viz[key].replace(/['"]/g, '');
+                                 if (color.startsWith('0x')) {
+-                                    color = color.slice(2);  // Remove 0x prefix
++                                    color = color.slice(2);
+                                 } else if (color.startsWith('#')) {
+-                                    color = color.slice(1);  // Remove # prefix
++                                    color = color.slice(1);
+                                 }
+-                                // Ensure 6 characters for hex color
+                                 color = color.padStart(6, '0');
+                                 viz[key] = '#' + color;
+                             }
+@@ -210,15 +190,15 @@ export default class WebsocketService {
+                 }
+                 break;
+                 
+-            case 'graphUpdate':
++            case 'graph_update':
+                 console.log('Received graph update:', data.graph_data);
+                 if (data.graph_data) {
+                     this.emit('graphUpdate', { graphData: data.graph_data });
+                 }
+                 break;
+                 
+-            case 'audioData':
+-                this.handleAudioData(data.audio_data);
++            case 'audio':
++                this.handleAudioData(data.audio);
+                 break;
+                 
+             case 'answer':
+@@ -238,14 +218,13 @@ export default class WebsocketService {
+                 this.emit('openaiResponse', data.response);
+                 break;
+                 
+-            case 'simulationModeSet':
++            case 'simulation_mode_set':
+                 console.log('Simulation mode set:', data.mode);
+                 this.emit('simulationModeSet', data.mode);
+                 break;
+ 
+-            case 'fisheyeSettingsUpdated':
++            case 'fisheye_settings_updated':
+                 console.log('Fisheye settings updated:', data);
+-                // Convert focus_point to focusPoint for client-side consistency
+                 const settings = {
+                     enabled: data.enabled,
+                     strength: data.strength,
+@@ -376,13 +355,12 @@ export default class WebsocketService {
+         this.send({
+             type: 'chatMessage',
+             message,
+-            use_openai: useOpenAI
++            tts_provider: useOpenAI ? 'openai' : 'sonata'
+         });
+     }
+ 
+     updateFisheyeSettings(settings) {
+         console.log('Updating fisheye settings:', settings);
+-        // Convert focusPoint to focus_point to match Rust struct field name
+         const focus_point = settings.focusPoint || [0, 0, 0];
+         this.send({
+             type: 'updateFisheyeSettings',
+diff --git a/src/config.rs b/src/config.rs
+index ca726187..bf9d1547 100644
+--- a/src/config.rs
++++ b/src/config.rs
+@@ -256,7 +256,6 @@ impl fmt::Display for VisualizationSettings {
+ #[cfg(test)]
+ mod tests {
+     use super::*;
+-    use crate::models::simulation_params::{SimulationParams, SimulationPhase};
+ 
+     #[test]
+     fn test_simulation_params_from_config() {
+@@ -277,63 +276,39 @@ mod tests {
+             force_directed_damping: 0.8,
+         };
+ 
+-        let params = SimulationParams::from_config(&config, SimulationPhase::Initial);
++        let params = crate::models::simulation_params::SimulationParams::from_config(&config);
+         assert_eq!(params.iterations, 100);
+-        assert_eq!(params.spring_strength, 0.1);
+         assert_eq!(params.repulsion_strength, 1000.0);
+         assert_eq!(params.attraction_strength, 0.01);
+         assert_eq!(params.damping, 0.8);
+-        assert!(params.is_initial_layout);
+     }
+ 
+     #[test]
+     fn test_simulation_params_clamping() {
+-        let params = SimulationParams::new(
+-            5,
+-            0.0001, // spring_strength
+-            0.5,    // repulsion_strength
+-            0.0001, // attraction_strength
+-            0.3,    // damping
+-            false   // is_initial
+-        );
+-        assert_eq!(params.iterations, 5);
+-        assert_eq!(params.spring_strength, 0.001); // Clamped to min
+-        assert_eq!(params.repulsion_strength, 1.0); // Clamped to min
+-        assert_eq!(params.attraction_strength, 0.001); // Clamped to min
+-        assert_eq!(params.damping, 0.5); // Clamped to min
+-        assert!(!params.is_initial_layout);
++        let params = crate::models::simulation_params::SimulationParams::new(5, 50.0, 0.001, 0.05);
++        assert_eq!(params.iterations, 10); // Clamped to min
++        assert_eq!(params.repulsion_strength, 100.0); // Clamped to min
++        assert_eq!(params.attraction_strength, 0.01); // Clamped to min
++        assert_eq!(params.damping, 0.1); // Clamped to min
+ 
+-        let params = SimulationParams::new(
+-            1000,
+-            2.0,     // spring_strength
+-            20000.0, // repulsion_strength
+-            2.0,     // attraction_strength
+-            1.0,     // damping
+-            true     // is_initial
+-        );
++        let params = crate::models::simulation_params::SimulationParams::new(1000, 10000.0, 2.0, 1.0);
+         assert_eq!(params.iterations, 500); // Clamped to max
+-        assert_eq!(params.spring_strength, 1.0); // Clamped to max
+-        assert_eq!(params.repulsion_strength, 10000.0); // Clamped to max
++        assert_eq!(params.repulsion_strength, 5000.0); // Clamped to max
+         assert_eq!(params.attraction_strength, 1.0); // Clamped to max
+-        assert_eq!(params.damping, 0.95); // Clamped to max
+-        assert!(params.is_initial_layout);
++        assert_eq!(params.damping, 0.9); // Clamped to max
+     }
+ 
+     #[test]
+     fn test_simulation_params_builder() {
+-        let params = SimulationParams::default()
++        let params = crate::models::simulation_params::SimulationParams::default()
+             .with_iterations(200)
+-            .with_spring_strength(0.5)
+-            .with_repulsion_strength(5000.0)
+-            .with_attraction_strength(0.05)
+-            .with_damping(0.7)
+-            .with_time_step(0.8);
++            .with_repulsion(2000.0)
++            .with_attraction(0.05)
++            .with_damping(0.7);
+ 
+-        assert_eq!(params.iterations, 10); // Clamped to interactive max since not initial
+-        assert_eq!(params.spring_strength, 0.5);
+-        assert_eq!(params.repulsion_strength, 5000.0);
++        assert_eq!(params.iterations, 200);
++        assert_eq!(params.repulsion_strength, 2000.0);
+         assert_eq!(params.attraction_strength, 0.05);
+         assert_eq!(params.damping, 0.7);
+-        assert_eq!(params.time_step, 0.8);
+     }
+ }
+diff --git a/src/models/position_update.rs b/src/models/position_update.rs
+deleted file mode 100644
+index ec6d58fc..00000000
+--- a/src/models/position_update.rs
++++ /dev/null
+@@ -1,70 +0,0 @@
+-use serde::{Serialize, Deserialize};
+-use std::collections::HashMap;
+-
+-/// Represents a minimal position update for a node
+-#[derive(Debug, Clone, Serialize, Deserialize)]
+-pub struct NodePosition {
+-    pub x: f32,
+-    pub y: f32,
+-    pub z: f32,
+-}
+-
+-/// Represents a batch of position updates for multiple nodes
+-#[derive(Debug, Clone, Serialize, Deserialize)]
+-pub struct PositionUpdate {
+-    /// Maps node indices to their new positions
+-    pub positions: HashMap<usize, NodePosition>,
+-    /// Optional timestamp for synchronization
+-    pub timestamp: Option<u64>,
+-}
+-
+-impl PositionUpdate {
+-    pub fn new() -> Self {
+-        Self {
+-            positions: HashMap::new(),
+-            timestamp: Some(std::time::SystemTime::now()
+-                .duration_since(std::time::UNIX_EPOCH)
+-                .unwrap()
+-                .as_millis() as u64),
+-        }
+-    }
+-
+-    /// Adds a position update for a node
+-    pub fn add_position(&mut self, index: usize, x: f32, y: f32, z: f32) {
+-        self.positions.insert(index, NodePosition { x, y, z });
+-    }
+-
+-    /// Creates a position update from changes only
+-    pub fn from_changes(old_positions: &[(f32, f32, f32)], new_positions: &[(f32, f32, f32)]) -> Self {
+-        let mut update = Self::new();
+-        
+-        for (i, (old, new)) in old_positions.iter().zip(new_positions.iter()).enumerate() {
+-            if (old.0 - new.0).abs() > 0.001 || 
+-               (old.1 - new.1).abs() > 0.001 || 
+-               (old.2 - new.2).abs() > 0.001 {
+-                update.add_position(i, new.0, new.1, new.2);
+-            }
+-        }
+-        
+-        update
+-    }
+-}
+-
+-/// Message types for WebSocket communication
+-#[derive(Debug, Clone, Serialize, Deserialize)]
+-pub enum GraphMessage {
+-    /// Complete graph initialization
+-    InitialGraph {
+-        nodes: Vec<String>,  // Node IDs only
+-        edges: Vec<(String, String, f32)>,  // (source, target, weight)
+-        metadata: serde_json::Value,
+-    },
+-    /// Position updates only
+-    PositionUpdate(PositionUpdate),
+-    /// Parameter updates
+-    ParameterUpdate {
+-        spring_strength: Option<f32>,
+-        damping: Option<f32>,
+-        iterations: Option<u32>,
+-    },
+-}
+diff --git a/src/models/simulation_params.rs b/src/models/simulation_params.rs
+index f430edc3..d1a4e775 100644
+--- a/src/models/simulation_params.rs
++++ b/src/models/simulation_params.rs
+@@ -16,57 +16,50 @@ pub enum SimulationPhase {
+ }
+ 
+ /// Parameters controlling the force-directed graph layout simulation
+-#[derive(Serialize, Deserialize, Clone, Debug)]
++#[derive(Serialize, Deserialize)]
+ #[repr(C)]
+ pub struct SimulationParams {
+     pub iterations: u32,           // Range: 1-500, Default: varies by phase
+-    pub spring_strength: f32,      // Range: 0.001-1.0, Default: 0.01
+-    pub repulsion_strength: f32,   // Range: 1.0-10000.0, Default: 1000.0
+-    pub attraction_strength: f32,  // Range: 0.001-1.0, Default: 0.01
++    pub spring_strength: f32,      // Range: 0.001-1.0, Default: 0.01 (reduced for stability)
+     pub damping: f32,             // Range: 0.5-0.95, Default: 0.8
+-    pub is_initial_layout: bool,   // true for initial layout, false for interactive
++    pub is_initial_layout: u32,   // 1 for initial layout, 0 for interactive
+     pub time_step: f32,           // Animation time step (0.1-1.0)
+-    pub padding: u32,             // Complete 32-byte alignment
++    pub padding2: u32,            // Padding for alignment
++    pub padding3: u32,            // Padding for alignment
++    pub padding4: u32,            // Complete 32-byte alignment
+ }
+ 
+ impl Default for SimulationParams {
+     fn default() -> Self {
+         Self {
+-            iterations: 5,
+-            spring_strength: 0.01,
+-            repulsion_strength: 1000.0,
+-            attraction_strength: 0.01,
+-            damping: 0.8,
+-            is_initial_layout: false,
+-            time_step: 0.5,
+-            padding: 0,
++            iterations: 5,          // Default to interactive mode iterations
++            spring_strength: 0.01,  // Reduced default strength for better stability
++            damping: 0.8,          // Balanced damping for smooth movement
++            is_initial_layout: 0,   // Default to interactive mode
++            time_step: 0.5,        // Reduced time step for smoother animation
++            padding2: 0,
++            padding3: 0,
++            padding4: 0,
+         }
+     }
+ }
+ 
+ impl SimulationParams {
+     /// Creates new simulation parameters with validation
+-    pub fn new(
+-        iterations: u32,
+-        spring_strength: f32,
+-        repulsion_strength: f32,
+-        attraction_strength: f32,
+-        damping: f32,
+-        is_initial: bool
+-    ) -> Self {
++    pub fn new(iterations: u32, spring_strength: f32, damping: f32, is_initial: bool) -> Self {
+         Self {
+             iterations: if is_initial { 
+                 iterations.clamp(200, 500) // More iterations for initial layout
+             } else {
+                 iterations.clamp(1, 10)    // Fewer iterations for interactive updates
+             },
+-            spring_strength: spring_strength.clamp(0.001, 1.0),
+-            repulsion_strength: repulsion_strength.clamp(1.0, 10000.0),
+-            attraction_strength: attraction_strength.clamp(0.001, 1.0),
+-            damping: damping.clamp(0.5, 0.95),
+-            is_initial_layout: is_initial,
+-            time_step: 0.5,
+-            padding: 0,
++            spring_strength: spring_strength.clamp(0.001, 1.0), // Reduced range for better control
++            damping: damping.clamp(0.5, 0.95), // Increased minimum damping for stability
++            is_initial_layout: if is_initial { 1 } else { 0 },
++            time_step: 0.5, // Default to moderate time step
++            padding2: 0,
++            padding3: 0,
++            padding4: 0,
+         }
+     }
+ 
+@@ -76,8 +69,6 @@ impl SimulationParams {
+         Self::new(
+             if is_initial { config.force_directed_iterations } else { 5 },
+             config.force_directed_spring,
+-            config.force_directed_repulsion,
+-            config.force_directed_attraction,
+             config.force_directed_damping,
+             is_initial
+         )
+@@ -85,7 +76,7 @@ impl SimulationParams {
+ 
+     /// Updates iterations with phase-appropriate validation
+     pub fn with_iterations(mut self, iterations: u32) -> Self {
+-        self.iterations = if self.is_initial_layout {
++        self.iterations = if self.is_initial_layout == 1 {
+             iterations.clamp(200, 500)
+         } else {
+             iterations.clamp(1, 10)
+@@ -99,18 +90,6 @@ impl SimulationParams {
+         self
+     }
+ 
+-    /// Updates repulsion strength with validation
+-    pub fn with_repulsion_strength(mut self, strength: f32) -> Self {
+-        self.repulsion_strength = strength.clamp(1.0, 10000.0);
+-        self
+-    }
+-
+-    /// Updates attraction strength with validation
+-    pub fn with_attraction_strength(mut self, strength: f32) -> Self {
+-        self.attraction_strength = strength.clamp(0.001, 1.0);
+-        self
+-    }
+-
+     /// Updates damping with validation
+     pub fn with_damping(mut self, damping: f32) -> Self {
+         self.damping = damping.clamp(0.5, 0.95);
+@@ -125,8 +104,26 @@ impl SimulationParams {
+ }
+ 
+ // Manual implementations for required GPU traits
++impl Clone for SimulationParams {
++    fn clone(&self) -> Self {
++        *self
++    }
++}
++
+ impl Copy for SimulationParams {}
+ 
++impl std::fmt::Debug for SimulationParams {
++    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
++        f.debug_struct("SimulationParams")
++            .field("iterations", &self.iterations)
++            .field("spring_strength", &self.spring_strength)
++            .field("damping", &self.damping)
++            .field("is_initial_layout", &self.is_initial_layout)
++            .field("time_step", &self.time_step)
++            .finish()
++    }
++}
++
+ // SAFETY: This type is #[repr(C)], contains only Pod types (u32 and f32),
+ // and has explicit padding for proper alignment. All bit patterns are valid.
+ unsafe impl bytemuck::Pod for SimulationParams {}
+@@ -143,29 +140,26 @@ mod tests {
+         let params = SimulationParams::default();
+         assert_eq!(params.iterations, 5);
+         assert_eq!(params.spring_strength, 0.01);
+-        assert_eq!(params.repulsion_strength, 1000.0);
+-        assert_eq!(params.attraction_strength, 0.01);
+         assert_eq!(params.damping, 0.8);
+-        assert!(!params.is_initial_layout);
++        assert_eq!(params.is_initial_layout, 0);
++        assert_eq!(params.time_step, 0.5);
+     }
+ 
+     #[test]
+     fn test_simulation_params_validation() {
+-        let params = SimulationParams::new(20, 0.0001, 0.5, 0.0001, 0.3, false);
++        // Test interactive mode limits
++        let params = SimulationParams::new(20, 0.0001, 0.3, false);
+         assert_eq!(params.iterations, 10); // Clamped to interactive max
+         assert_eq!(params.spring_strength, 0.001); // Clamped to min
+-        assert_eq!(params.repulsion_strength, 1.0); // Clamped to min
+-        assert_eq!(params.attraction_strength, 0.001); // Clamped to min
+         assert_eq!(params.damping, 0.5); // Clamped to min
+-        assert!(!params.is_initial_layout);
++        assert_eq!(params.is_initial_layout, 0);
+ 
+-        let params = SimulationParams::new(600, 2.0, 20000.0, 2.0, 1.0, true);
++        // Test initial layout mode limits
++        let params = SimulationParams::new(600, 2.0, 1.0, true);
+         assert_eq!(params.iterations, 500); // Clamped to max
+         assert_eq!(params.spring_strength, 1.0); // Clamped to max
+-        assert_eq!(params.repulsion_strength, 10000.0); // Clamped to max
+-        assert_eq!(params.attraction_strength, 1.0); // Clamped to max
+         assert_eq!(params.damping, 0.95); // Clamped to max
+-        assert!(params.is_initial_layout);
++        assert_eq!(params.is_initial_layout, 1);
+     }
+ 
+     #[test]
+@@ -173,15 +167,11 @@ mod tests {
+         let params = SimulationParams::default()
+             .with_iterations(200)
+             .with_spring_strength(0.5)
+-            .with_repulsion_strength(5000.0)
+-            .with_attraction_strength(0.05)
+             .with_damping(0.7)
+             .with_time_step(0.8);
+ 
+         assert_eq!(params.iterations, 10); // Clamped to interactive max
+         assert_eq!(params.spring_strength, 0.5);
+-        assert_eq!(params.repulsion_strength, 5000.0);
+-        assert_eq!(params.attraction_strength, 0.05);
+         assert_eq!(params.damping, 0.7);
+         assert_eq!(params.time_step, 0.8);
+     }
+diff --git a/src/services/graph_service.rs b/src/services/graph_service.rs
+index c003f741..eca019e3 100644
+--- a/src/services/graph_service.rs
++++ b/src/services/graph_service.rs
+@@ -55,14 +55,17 @@ impl GraphService {
+         for (file_name, file_metadata) in &metadata {
+             let source_id = file_name.trim_end_matches(".md").to_string();
+             
++            // Look through all references in topic_counts
+             for (target_id, reference_count) in &file_metadata.topic_counts {
+                 if source_id != *target_id {
++                    // Create a canonical edge key (alphabetically ordered)
+                     let edge_key = if source_id < *target_id {
+                         (source_id.clone(), target_id.clone())
+                     } else {
+                         (target_id.clone(), source_id.clone())
+                     };
+ 
++                    // Update edge weight
+                     edge_map.entry(edge_key)
+                         .and_modify(|weight| *weight += *reference_count as f32)
+                         .or_insert(*reference_count as f32);
+@@ -76,26 +79,31 @@ impl GraphService {
+         }).collect();
+         
+         info!("Graph data built with {} nodes and {} edges", graph.nodes.len(), graph.edges.len());
++        debug!("Sample node data: {:?}", graph.nodes.first());
++        debug!("Sample edge data: {:?}", graph.edges.first());
+ 
+-        // Calculate initial layout
++        // Calculate layout using GPU if available, otherwise fall back to CPU
+         let settings = app_state.settings.read().await;
+         let params = SimulationParams::new(
+             settings.visualization.force_directed_iterations as u32,
+             settings.visualization.force_directed_spring,
+-            settings.visualization.force_directed_repulsion,
+-            settings.visualization.force_directed_attraction,
+             settings.visualization.force_directed_damping,
+             true // Initial layout
+         );
+ 
+         Self::calculate_layout(&app_state.gpu_compute, &mut graph, &params).await?;
+         
++        debug!("Final sample node data after layout calculation: {:?}", graph.nodes.first());
++        
+         Ok(graph)
+     }
+ 
++    /// Initializes random positions for nodes in a spherical distribution
+     fn initialize_random_positions(graph: &mut GraphData) {
+         use rand::Rng;
+         let mut rng = rand::thread_rng();
++        
++        // Use a smaller initial radius to prevent nodes from spreading too far
+         let initial_radius = 30.0;
+         
+         for node in &mut graph.nodes {
+@@ -106,57 +114,63 @@ impl GraphService {
+             node.x = r * theta.cos() * phi.sin();
+             node.y = r * theta.sin() * phi.sin();
+             node.z = r * phi.cos();
++            
++            // Initialize velocities to 0
+             node.vx = 0.0;
+             node.vy = 0.0;
+             node.vz = 0.0;
+         }
+     }
+ 
++    /// Calculates the force-directed layout using GPUCompute if available, otherwise falls back to CPU.
+     pub async fn calculate_layout(
+         gpu_compute: &Option<Arc<RwLock<GPUCompute>>>,
+         graph: &mut GraphData,
+         params: &SimulationParams,
+     ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
++        // Initialize random positions before layout calculation
++        Self::initialize_random_positions(graph);
++        
+         match gpu_compute {
+             Some(gpu) => {
+                 info!("Using GPU for layout calculation");
+                 let mut gpu_compute = gpu.write().await;
+-                
+-                // Only initialize positions for new graphs
+-                if graph.nodes.iter().all(|n| n.x == 0.0 && n.y == 0.0 && n.z == 0.0) {
+-                    Self::initialize_random_positions(graph);
+-                }
+-                
+                 gpu_compute.update_graph_data(graph)?;
+                 gpu_compute.update_simulation_params(params)?;
+                 
+-                // Run iterations with more frequent updates
+-                for _ in 0..params.iterations {
++                // Run multiple iterations with position updates
++                for i in 0..params.iterations {
+                     gpu_compute.step()?;
+                     
+-                    // Update positions every iteration for smoother motion
+-                    let updated_nodes = gpu_compute.get_node_positions().await?;
+-                    for (i, node) in graph.nodes.iter_mut().enumerate() {
+-                        node.update_from_gpu_node(&updated_nodes[i]);
+-                        
+-                        // Apply bounds
+-                        let max_coord = 100.0;
+-                        node.x = node.x.clamp(-max_coord, max_coord);
+-                        node.y = node.y.clamp(-max_coord, max_coord);
+-                        node.z = node.z.clamp(-max_coord, max_coord);
++                    // Update positions every few iterations to maintain stability
++                    if i % 10 == 0 {
++                        let updated_nodes = gpu_compute.get_node_positions().await?;
++                        for (i, node) in graph.nodes.iter_mut().enumerate() {
++                            node.update_from_gpu_node(&updated_nodes[i]);
++                            
++                            // Add bounds checking
++                            let max_coord = 100.0;
++                            node.x = node.x.clamp(-max_coord, max_coord);
++                            node.y = node.y.clamp(-max_coord, max_coord);
++                            node.z = node.z.clamp(-max_coord, max_coord);
++                        }
+                     }
+                 }
++                
++                debug!("GPU layout calculation complete. Sample updated node: {:?}", graph.nodes.first());
+             },
+             None => {
+                 warn!("GPU not available. Falling back to CPU-based layout calculation.");
+                 Self::calculate_layout_cpu(graph, params.iterations, params.spring_strength, params.damping);
++                debug!("CPU layout calculation complete. Sample updated node: {:?}", graph.nodes.first());
+             }
+         }
+         Ok(())
+     }
+ 
++    /// Calculates the force-directed layout using CPU.
+     fn calculate_layout_cpu(graph: &mut GraphData, iterations: u32, spring_strength: f32, damping: f32) {
+-        let repulsion_strength = spring_strength * 10000.0;
++        let repulsion_strength = spring_strength * 10000.0; // Increase repulsion for better spacing
+         
+         for _ in 0..iterations {
+             // Calculate repulsive forces
+@@ -171,6 +185,7 @@ impl GraphService {
+                     let fy = force * dy / distance;
+                     let fz = force * dz / distance;
+ 
++                    // Apply force with a maximum limit
+                     let max_force = 50.0;
+                     let force_magnitude = (fx * fx + fy * fy + fz * fz).sqrt();
+                     let scale = if force_magnitude > max_force {
+@@ -197,11 +212,13 @@ impl GraphService {
+                 let dz = graph.nodes[target].z - graph.nodes[source].z;
+                 let distance = (dx * dx + dy * dy + dz * dz).sqrt().max(0.1);
+                 
++                // Use spring strength and weight for attraction
+                 let force = spring_strength * distance * edge.weight;
+                 let fx = force * dx / distance;
+                 let fy = force * dy / distance;
+                 let fz = force * dz / distance;
+ 
++                // Apply force with a maximum limit
+                 let max_force = 50.0;
+                 let force_magnitude = (fx * fx + fy * fy + fz * fz).sqrt();
+                 let scale = if force_magnitude > max_force {
+@@ -218,8 +235,9 @@ impl GraphService {
+                 graph.nodes[target].vz -= fz * scale;
+             }
+ 
+-            // Update positions
++            // Update positions with bounds checking
+             for node in &mut graph.nodes {
++                // Apply velocity limits
+                 let max_velocity = 10.0;
+                 let velocity_magnitude = (node.vx * node.vx + node.vy * node.vy + node.vz * node.vz).sqrt();
+                 if velocity_magnitude > max_velocity {
+@@ -229,15 +247,18 @@ impl GraphService {
+                     node.vz *= scale;
+                 }
+ 
++                // Update position
+                 node.x += node.vx;
+                 node.y += node.vy;
+                 node.z += node.vz;
+ 
++                // Apply position bounds
+                 let max_coord = 100.0;
+                 node.x = node.x.clamp(-max_coord, max_coord);
+                 node.y = node.y.clamp(-max_coord, max_coord);
+                 node.z = node.z.clamp(-max_coord, max_coord);
+ 
++                // Apply damping
+                 node.vx *= damping;
+                 node.vy *= damping;
+                 node.vz *= damping;
+@@ -245,6 +266,7 @@ impl GraphService {
+         }
+     }
+ 
++    /// Finds the shortest path between two nodes in the graph.
+     pub fn find_shortest_path(graph: &GraphData, start: &str, end: &str) -> Result<Vec<String>, String> {
+         let mut distances: HashMap<String, f32> = HashMap::new();
+         let mut previous: HashMap<String, Option<String>> = HashMap::new();
+@@ -283,6 +305,7 @@ impl GraphService {
+             }
+         }
+     
++        // Reconstruct path
+         let mut path = Vec::new();
+         let mut current = end.to_string();
+         while let Some(prev) = previous[&current].clone() {
+diff --git a/src/utils/mod.rs b/src/utils/mod.rs
+index 4bc04eaa..170c1c1b 100644
+--- a/src/utils/mod.rs
++++ b/src/utils/mod.rs
+@@ -1,4 +1,5 @@
+ pub mod audio_processor;
++pub mod compression;
+ pub mod gpu_compute;
+ pub mod websocket_manager;
+ pub mod websocket_messages;
+diff --git a/src/utils/websocket_manager.rs b/src/utils/websocket_manager.rs
+index 3e22b618..9a8dccff 100644
+--- a/src/utils/websocket_manager.rs
++++ b/src/utils/websocket_manager.rs
+@@ -5,21 +5,20 @@ use log::{info, error, debug};
+ use std::sync::{Mutex, Arc};
+ use serde_json::json;
+ use futures::stream::StreamExt;
++use futures::future::join_all;
++use std::error::Error as StdError;
++use bytestring::ByteString;
+ use serde::Deserialize;
+ use tokio::time::Duration;
+-use actix_web::web::Bytes;
+-use bytestring::ByteString;
+ 
+ use crate::AppState;
+ use crate::models::simulation_params::{SimulationMode, SimulationParams};
+-use crate::utils::websocket_messages::{
+-    MessageHandler, OpenAIMessage, ServerMessage,
+-    OpenAIConnected, OpenAIConnectionFailed, SendText, SendBinary
+-};
++use crate::utils::compression::{compress_message, decompress_message};
++use crate::utils::websocket_messages::{SendCompressedMessage, MessageHandler, OpenAIMessage};
+ use crate::utils::websocket_openai::OpenAIWebSocket;
++use crate::services::graph_service::GraphService;
+ 
+ const OPENAI_CONNECT_TIMEOUT: Duration = Duration::from_secs(5);
+-const GPU_UPDATE_INTERVAL: Duration = Duration::from_millis(50); // 20 fps
+ 
+ #[derive(Deserialize, Debug)]
+ #[serde(tag = "type")]
+@@ -57,18 +56,6 @@ fn format_color(color: &str) -> String {
+     format!("#{}", color)
+ }
+ 
+-/// Helper function to convert positions to binary Float32Array data
+-fn positions_to_binary(positions: &Vec<[f32; 3]>) -> Vec<u8> {
+-    let mut binary_data = Vec::with_capacity(positions.len() * 12); // 3 floats * 4 bytes each
+-    for pos in positions {
+-        // Ensure little-endian byte order for JavaScript Float32Array compatibility
+-        binary_data.extend_from_slice(&pos[0].to_le_bytes());
+-        binary_data.extend_from_slice(&pos[1].to_le_bytes());
+-        binary_data.extend_from_slice(&pos[2].to_le_bytes());
+-    }
+-    binary_data
+-}
+-
+ /// Manages WebSocket sessions and communication.
+ pub struct WebSocketManager {
+     pub sessions: Mutex<Vec<Addr<WebSocketSession>>>,
+@@ -85,7 +72,7 @@ impl WebSocketManager {
+     }
+ 
+     /// Initializes the WebSocketManager with a conversation ID.
+-    pub async fn initialize(&self, ragflow_service: &crate::services::ragflow_service::RAGFlowService) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
++    pub async fn initialize(&self, ragflow_service: &crate::services::ragflow_service::RAGFlowService) -> Result<(), Box<dyn StdError + Send + Sync>> {
+         let conversation_id = ragflow_service.create_conversation("default_user".to_string()).await?;
+         let mut conv_id_lock = self.conversation_id.lock().unwrap();
+         *conv_id_lock = Some(conversation_id.clone());
+@@ -107,16 +94,26 @@ impl WebSocketManager {
+     }
+ 
+     /// Broadcasts a message to all connected WebSocket sessions.
+-    pub async fn broadcast_message(&self, message: &str) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
++    pub async fn broadcast_message(&self, message: &str) -> Result<(), Box<dyn StdError + Send + Sync>> {
+         let sessions = self.sessions.lock().unwrap().clone();
+-        for session in sessions {
+-            session.do_send(SendText(message.to_string()));
++        let futures: Vec<_> = sessions.iter()
++            .map(|session| {
++                let compressed = compress_message(message).unwrap_or_default();
++                session.send(SendCompressedMessage(compressed))
++            })
++            .collect();
++        
++        let results = join_all(futures).await;
++        for result in results {
++            if let Err(e) = result {
++                error!("Failed to broadcast message: {}", e);
++            }
+         }
+         Ok(())
+     }
+ 
+     /// Broadcasts graph update to all connected WebSocket sessions.
+-    pub async fn broadcast_graph_update(&self, graph_data: &crate::models::graph::GraphData) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
++    pub async fn broadcast_graph_update(&self, graph_data: &crate::models::graph::GraphData) -> Result<(), Box<dyn StdError + Send + Sync>> {
+         let json_data = json!({
+             "type": "graph_update",
+             "graph_data": graph_data
+@@ -145,13 +142,6 @@ impl Actor for WebSocketSession {
+             "WebSocket session started. Total sessions: {}",
+             self.state.websocket_manager.sessions.lock().unwrap().len()
+         );
+-
+-        // Start GPU updates if in remote mode
+-        if matches!(self.simulation_mode, SimulationMode::Remote) {
+-            if let Some(_) = &self.state.gpu_compute {
+-                self.start_gpu_updates(ctx);
+-            }
+-        }
+     }
+ 
+     fn stopped(&mut self, ctx: &mut Self::Context) {
+@@ -166,19 +156,11 @@ impl Actor for WebSocketSession {
+ 
+ impl MessageHandler for WebSocketSession {}
+ 
+-impl Handler<SendText> for WebSocketSession {
+-    type Result = ();
+-
+-    fn handle(&mut self, msg: SendText, ctx: &mut Self::Context) {
+-        ctx.text(ByteString::from(msg.0));
+-    }
+-}
+-
+-impl Handler<SendBinary> for WebSocketSession {
++impl Handler<SendCompressedMessage> for WebSocketSession {
+     type Result = ();
+ 
+-    fn handle(&mut self, msg: SendBinary, ctx: &mut Self::Context) {
+-        ctx.binary(Bytes::from(msg.0));
++    fn handle(&mut self, msg: SendCompressedMessage, ctx: &mut Self::Context) {
++        ctx.binary(msg.0);
+     }
+ }
+ 
+@@ -219,7 +201,9 @@ impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for WebSocketSession
+                                         "radius": radius
+                                     });
+                                     if let Ok(response_str) = serde_json::to_string(&response) {
+-                                        ctx_addr.do_send(SendText(response_str));
++                                        if let Ok(compressed) = compress_message(&response_str) {
++                                            ctx_addr.do_send(SendCompressedMessage(compressed));
++                                        }
+                                     }
+                                 } else {
+                                     error!("GPU compute service not available");
+@@ -228,7 +212,9 @@ impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for WebSocketSession
+                                         "message": "GPU compute service not available"
+                                     });
+                                     if let Ok(error_str) = serde_json::to_string(&error_message) {
+-                                        ctx_addr.do_send(SendText(error_str));
++                                        if let Ok(compressed) = compress_message(&error_str) {
++                                            ctx_addr.do_send(SendCompressedMessage(compressed));
++                                        }
+                                     }
+                                 }
+                             }.into_actor(self));
+@@ -245,12 +231,11 @@ impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for WebSocketSession
+                 }
+             },
+             Ok(ws::Message::Binary(bin)) => {
+-                error!("Unexpected binary message received");
+-                let error_message = json!({
+-                    "type": "error",
+-                    "message": "Unexpected binary message"
+-                });
+-                self.send_json_response(error_message, ctx);
++                if let Ok(text) = decompress_message(&bin) {
++                    StreamHandler::handle(self, Ok(ws::Message::Text(ByteString::from(text))), ctx);
++                } else {
++                    error!("Failed to decompress binary message");
++                }
+             },
+             Ok(ws::Message::Close(reason)) => {
+                 ctx.close(reason);
+@@ -324,7 +309,9 @@ impl WebSocketSession {
+                                             "message": format!("Failed to generate speech: {}", e)
+                                         });
+                                         if let Ok(error_str) = serde_json::to_string(&error_message) {
+-                                            ctx_addr.do_send(SendText(error_str));
++                                            if let Ok(compressed) = compress_message(&error_str) {
++                                                ctx_addr.do_send(SendCompressedMessage(compressed));
++                                            }
+                                         }
+                                     }
+                                 }
+@@ -336,7 +323,9 @@ impl WebSocketSession {
+                                     "message": format!("Error processing RAGFlow response: {}", e)
+                                 });
+                                 if let Ok(error_str) = serde_json::to_string(&error_message) {
+-                                    ctx_addr.do_send(SendText(error_str));
++                                    if let Ok(compressed) = compress_message(&error_str) {
++                                        ctx_addr.do_send(SendCompressedMessage(compressed));
++                                    }
+                                 }
+                             }
+                         }
+@@ -349,7 +338,9 @@ impl WebSocketSession {
+                         "message": format!("Failed to send message to RAGFlow: {}", e)
+                     });
+                     if let Ok(error_str) = serde_json::to_string(&error_message) {
+-                        ctx_addr.do_send(SendText(error_str));
++                        if let Ok(compressed) = compress_message(&error_str) {
++                            ctx_addr.do_send(SendCompressedMessage(compressed));
++                        }
+                     }
+                 }
+             }
+@@ -360,10 +351,6 @@ impl WebSocketSession {
+         self.simulation_mode = match mode {
+             "remote" => {
+                 info!("Simulation mode set to Remote (GPU-accelerated)");
+-                // Start GPU position updates when switching to remote mode
+-                if let Some(_) = &self.state.gpu_compute {
+-                    self.start_gpu_updates(ctx);
+-                }
+                 SimulationMode::Remote
+             },
+             "gpu" => {
+@@ -390,120 +377,63 @@ impl WebSocketSession {
+ 
+     fn handle_layout(&mut self, ctx: &mut ws::WebsocketContext<Self>, params: SimulationParams) {
+         let state = self.state.clone();
++        let simulation_mode = self.simulation_mode.clone();
+         let ctx_addr = ctx.address();
+         
+         ctx.spawn(async move {
+-            if let Some(gpu_compute) = &state.gpu_compute {
+-                let mut gpu = gpu_compute.write().await;
+-                
+-                // Update simulation parameters
+-                if let Err(e) = gpu.update_simulation_params(&params) {
+-                    error!("Failed to update simulation parameters: {}", e);
+-                    let error_message = json!({
+-                        "type": "error",
+-                        "message": format!("Failed to update simulation parameters: {}", e)
+-                    });
+-                    if let Ok(error_str) = serde_json::to_string(&error_message) {
+-                        ctx_addr.do_send(SendText(error_str));
++            let mut graph_data = state.graph_data.write().await;
++            
++            let result = match simulation_mode {
++                SimulationMode::Remote => {
++                    if let Some(gpu_compute) = &state.gpu_compute {
++                        GraphService::calculate_layout(
++                            &Some(gpu_compute.clone()),
++                            &mut *graph_data,
++                            &params
++                        ).await
++                    } else {
++                        GraphService::calculate_layout(
++                            &None,
++                            &mut *graph_data,
++                            &params
++                        ).await
+                     }
+-                    return;
+-                }
++                },
++                _ => GraphService::calculate_layout(
++                    &None,
++                    &mut *graph_data,
++                    &params
++                ).await,
++            };
+ 
+-                // Run initial GPU computation steps
+-                for _ in 0..params.iterations {
+-                    if let Err(e) = gpu.step() {
+-                        error!("GPU compute step failed: {}", e);
+-                        let error_message = json!({
+-                            "type": "error",
+-                            "message": format!("GPU compute step failed: {}", e)
+-                        });
+-                        if let Ok(error_str) = serde_json::to_string(&error_message) {
+-                            ctx_addr.do_send(SendText(error_str));
++            match result {
++                Ok(_) => {
++                    let response = json!({
++                        "type": "layout_update",
++                        "graph_data": &*graph_data
++                    });
++                    if let Ok(response_str) = serde_json::to_string(&response) {
++                        if let Ok(compressed) = compress_message(&response_str) {
++                            ctx_addr.do_send(SendCompressedMessage(compressed));
+                         }
+-                        return;
+                     }
+-                }
+-
+-                // Get final positions after layout
+-                match gpu.get_node_positions().await {
+-                    Ok(nodes) => {
+-                        // Convert GPU nodes to position arrays
+-                        let positions: Vec<[f32; 3]> = nodes.iter()
+-                            .map(|node| [node.x, node.y, node.z])
+-                            .collect();
+-
+-                        // Convert positions to binary Float32Array data
+-                        let binary_data = positions_to_binary(&positions);
+-
+-                        // Send binary data
+-                        ctx_addr.do_send(SendBinary(binary_data));
+-                    },
+-                    Err(e) => {
+-                        error!("Failed to get GPU node positions: {}", e);
+-                        let error_message = json!({
+-                            "type": "error",
+-                            "message": format!("Failed to get GPU node positions: {}", e)
+-                        });
+-                        if let Ok(error_str) = serde_json::to_string(&error_message) {
+-                            ctx_addr.do_send(SendText(error_str));
++                },
++                Err(e) => {
++                    error!("Failed to recalculate layout: {}", e);
++                    let error_message = json!({
++                        "type": "error",
++                        "message": format!("Layout calculation failed: {}", e)
++                    });
++                    if let Ok(error_str) = serde_json::to_string(&error_message) {
++                        if let Ok(compressed) = compress_message(&error_str) {
++                            ctx_addr.do_send(SendCompressedMessage(compressed));
+                         }
+                     }
+                 }
+-            } else {
+-                error!("GPU compute service not available");
+-                let error_message = json!({
+-                    "type": "error",
+-                    "message": "GPU compute service not available"
+-                });
+-                if let Ok(error_str) = serde_json::to_string(&error_message) {
+-                    ctx_addr.do_send(SendText(error_str));
+-                }
+             }
+         }.into_actor(self));
+     }
+ 
+-    fn start_gpu_updates(&self, ctx: &mut ws::WebsocketContext<Self>) {
+-        let state = self.state.clone();
+-        let ctx_addr = ctx.address();
+-
+-        // Start a timer to periodically fetch and broadcast GPU positions
+-        ctx.run_interval(GPU_UPDATE_INTERVAL, move |_act, _ctx| {
+-            let state_clone = state.clone();
+-            let addr_clone = ctx_addr.clone();
+-
+-            actix::spawn(async move {
+-                if let Some(gpu_compute) = &state_clone.gpu_compute {
+-                    let mut gpu = gpu_compute.write().await;
+-                    
+-                    // Run one step of GPU computation
+-                    if let Err(e) = gpu.step() {
+-                        error!("GPU compute step failed: {}", e);
+-                        return;
+-                    }
+-
+-                    // Get updated positions
+-                    match gpu.get_node_positions().await {
+-                        Ok(nodes) => {
+-                            // Convert GPU nodes to position arrays
+-                            let positions: Vec<[f32; 3]> = nodes.iter()
+-                                .map(|node| [node.x, node.y, node.z])
+-                                .collect();
+-
+-                            // Convert positions to binary Float32Array data
+-                            let binary_data = positions_to_binary(&positions);
+-
+-                            // Send binary data
+-                            addr_clone.do_send(SendBinary(binary_data));
+-                        },
+-                        Err(e) => {
+-                            error!("Failed to get GPU node positions: {}", e);
+-                        }
+-                    }
+-                }
+-            });
+-        });
+-    }
+-
+     fn handle_initial_data(&mut self, ctx: &mut ws::WebsocketContext<Self>) {
+         let state = self.state.clone();
+         let ctx_addr = ctx.address();
+@@ -553,36 +483,10 @@ impl WebSocketSession {
+             debug!("Sending initial data response: {:?}", response);
+ 
+             if let Ok(response_str) = serde_json::to_string(&response) {
+-                ctx_addr.do_send(SendText(response_str));
++                if let Ok(compressed) = compress_message(&response_str) {
++                    ctx_addr.do_send(SendCompressedMessage(compressed));
++                }
+             }
+         }.into_actor(self));
+     }
+ }
+-
+-// Implement Handler traits for WebSocketSession
+-impl Handler<OpenAIMessage> for WebSocketSession {
+-    type Result = ();
+-
+-    fn handle(&mut self, msg: OpenAIMessage, _ctx: &mut Self::Context) {
+-        if let Some(ref ws) = self.openai_ws {
+-            ws.do_send(msg);
+-        }
+-    }
+-}
+-
+-impl Handler<OpenAIConnected> for WebSocketSession {
+-    type Result = ();
+-
+-    fn handle(&mut self, _: OpenAIConnected, _ctx: &mut Self::Context) {
+-        debug!("OpenAI WebSocket connected");
+-    }
+-}
+-
+-impl Handler<OpenAIConnectionFailed> for WebSocketSession {
+-    type Result = ();
+-
+-    fn handle(&mut self, _: OpenAIConnectionFailed, _ctx: &mut Self::Context) {
+-        error!("OpenAI WebSocket connection failed");
+-        self.openai_ws = None;
+-    }
+-}
+diff --git a/src/utils/websocket_messages.rs b/src/utils/websocket_messages.rs
+index 94cd1510..6420a9fb 100644
+--- a/src/utils/websocket_messages.rs
++++ b/src/utils/websocket_messages.rs
+@@ -4,8 +4,7 @@ use serde_json::{json, Value};
+ use crate::models::simulation_params::SimulationParams;
+ use actix_web_actors::ws;
+ use log::{error, debug};
+-use actix_web::web::Bytes;
+-use bytestring::ByteString;
++use crate::utils::compression::compress_message;
+ 
+ /// Helper function to convert hex color to proper format
+ fn format_color(color: &str) -> String {
+@@ -15,57 +14,31 @@ fn format_color(color: &str) -> String {
+     format!("#{}", color)
+ }
+ 
+-/// GPU-computed node positions
+-#[derive(Debug, Clone, Serialize, Deserialize)]
+-pub struct GPUPositionUpdate {
+-    pub positions: Vec<[f32; 3]>
+-}
+-
+-/// Message for sending text data
+-#[derive(Message)]
+-#[rtype(result = "()")]
+-pub struct SendText(pub String);
+-
+-/// Message for sending binary data
++/// Represents messages sent to the client as compressed binary data.
+ #[derive(Message)]
+ #[rtype(result = "()")]
+-pub struct SendBinary(pub Vec<u8>);
+-
+-/// Message for OpenAI text-to-speech
+-#[derive(Message)]
+-#[rtype(result = "()")]
+-pub struct OpenAIMessage(pub String);
+-
+-/// Message indicating OpenAI connection success
+-#[derive(Message)]
+-#[rtype(result = "()")]
+-pub struct OpenAIConnected;
+-
+-/// Message indicating OpenAI connection failure
+-#[derive(Message)]
+-#[rtype(result = "()")]
+-pub struct OpenAIConnectionFailed;
++pub struct SendCompressedMessage(pub Vec<u8>);
+ 
+ /// Represents messages sent from the client.
+ #[derive(Serialize, Deserialize, Debug)]
+ #[serde(tag = "type")]
+ pub enum ClientMessage {
+-    #[serde(rename = "setTtsMethod")]
++    #[serde(rename = "set_tts_method")]
+     SetTTSMethod { method: String },
+     
+-    #[serde(rename = "chatMessage")]
++    #[serde(rename = "chat_message")]
+     ChatMessage { 
+         message: String, 
+         use_openai: bool 
+     },
+     
+-    #[serde(rename = "getInitialData")]
++    #[serde(rename = "get_initial_data")]
+     GetInitialData,
+     
+-    #[serde(rename = "setSimulationMode")]
++    #[serde(rename = "set_simulation_mode")]
+     SetSimulationMode { mode: String },
+     
+-    #[serde(rename = "recalculateLayout")]
++    #[serde(rename = "recalculate_layout")]
+     RecalculateLayout { params: SimulationParams },
+     
+     #[serde(rename = "ragflowQuery")]
+@@ -91,17 +64,17 @@ pub enum ClientMessage {
+ #[derive(Serialize, Deserialize, Debug)]
+ #[serde(tag = "type")]
+ pub enum ServerMessage {
+-    #[serde(rename = "audioData")]
++    #[serde(rename = "audio_data")]
+     AudioData {
+         audio_data: String // base64 encoded audio
+     },
+     
+-    #[serde(rename = "ragflowResponse")]
++    #[serde(rename = "ragflow_response")]
+     RagflowResponse {
+         answer: String
+     },
+     
+-    #[serde(rename = "openaiResponse")]
++    #[serde(rename = "openai_response")]
+     OpenAIResponse {
+         response: String,
+         audio: Option<String> // base64 encoded audio
+@@ -113,35 +86,54 @@ pub enum ServerMessage {
+         code: Option<String>
+     },
+     
+-    #[serde(rename = "graphUpdate")]
++    #[serde(rename = "graph_update")]
+     GraphUpdate {
+         graph_data: Value
+     },
+     
+-    #[serde(rename = "simulationModeSet")]
++    #[serde(rename = "simulation_mode_set")]
+     SimulationModeSet {
+         mode: String,
+         gpu_enabled: bool
+     },
+ 
+-    #[serde(rename = "fisheyeSettingsUpdated")]
++    #[serde(rename = "fisheye_settings_updated")]
+     FisheyeSettingsUpdated {
+         enabled: bool,
+         strength: f32,
+         focus_point: [f32; 3],
+         radius: f32,
+-    },
+-
+-    #[serde(rename = "gpuPositions")]
+-    GPUPositions(GPUPositionUpdate)
++    }
+ }
+ 
++#[derive(Message)]
++#[rtype(result = "()")]
++pub struct OpenAIConnected;
++
++#[derive(Message)]
++#[rtype(result = "()")]
++pub struct OpenAIConnectionFailed;
++
++#[derive(Message)]
++#[rtype(result = "()")]
++pub struct OpenAIMessage(pub String);
++
+ pub trait MessageHandler: Actor<Context = ws::WebsocketContext<Self>> {
+     fn send_json_response(&self, response: Value, ctx: &mut ws::WebsocketContext<Self>) {
+         match serde_json::to_string(&response) {
+             Ok(json_string) => {
+                 debug!("Sending JSON response: {}", json_string);
+-                ctx.text(ByteString::from(json_string));
++                match compress_message(&json_string) {
++                    Ok(compressed) => {
++                        debug!("Compressed response size: {} bytes", compressed.len());
++                        ctx.binary(compressed)
++                    },
++                    Err(e) => {
++                        error!("Failed to compress JSON response: {}", e);
++                        // Fallback to uncompressed JSON if compression fails
++                        ctx.text(json_string);
++                    }
++                }
+             },
+             Err(e) => {
+                 error!("Failed to serialize JSON response: {}", e);
+@@ -151,7 +143,7 @@ pub trait MessageHandler: Actor<Context = ws::WebsocketContext<Self>> {
+                     "code": "SERIALIZATION_ERROR"
+                 });
+                 if let Ok(error_string) = serde_json::to_string(&error_message) {
+-                    ctx.text(ByteString::from(error_string));
++                    ctx.text(error_string);
+                 }
+             }
+         }
+@@ -213,7 +205,7 @@ mod tests {
+             use_openai: true
+         };
+         let serialized = serde_json::to_string(&message).unwrap();
+-        assert!(serialized.contains("chatMessage"));
++        assert!(serialized.contains("chat_message"));
+         assert!(serialized.contains("Hello"));
+ 
+         let fisheye_message = ClientMessage::UpdateFisheyeSettings {
+@@ -233,7 +225,7 @@ mod tests {
+             answer: "Test answer".to_string()
+         };
+         let serialized = serde_json::to_string(&message).unwrap();
+-        assert!(serialized.contains("ragflowResponse"));
++        assert!(serialized.contains("ragflow_response"));
+         assert!(serialized.contains("Test answer"));
+ 
+         let fisheye_message = ServerMessage::FisheyeSettingsUpdated {
+@@ -243,7 +235,7 @@ mod tests {
+             radius: 100.0,
+         };
+         let serialized = serde_json::to_string(&fisheye_message).unwrap();
+-        assert!(serialized.contains("fisheyeSettingsUpdated"));
++        assert!(serialized.contains("fisheye_settings_updated"));
+         assert!(serialized.contains("strength"));
+     }
+ 
+diff --git a/src/utils/websocket_openai.rs b/src/utils/websocket_openai.rs
+index 81e68752..5f093db4 100644
+--- a/src/utils/websocket_openai.rs
++++ b/src/utils/websocket_openai.rs
+@@ -15,8 +15,9 @@ use tokio::net::TcpStream;
+ use std::time::Instant;
+ 
+ use crate::config::Settings;
+-use crate::utils::websocket_messages::{OpenAIMessage, OpenAIConnected, OpenAIConnectionFailed, SendText};
++use crate::utils::websocket_messages::{OpenAIMessage, OpenAIConnected, OpenAIConnectionFailed, SendCompressedMessage};
+ use crate::utils::websocket_manager::WebSocketSession;
++use crate::utils::compression;
+ 
+ const KEEPALIVE_INTERVAL: Duration = Duration::from_secs(30);
+ const CONNECTION_WAIT: Duration = Duration::from_millis(500);
+@@ -196,15 +197,17 @@ impl OpenAIWebSocket {
+         let start_time = Instant::now();
+         debug!("Preparing to send audio data to client");
+ 
+-        // Send audio data as JSON
++        // Send audio data directly without compression
+         let audio_message = json!({
+             "type": "audio",
+             "audio": audio_data
+         });
+ 
+-        // Convert to string and send
++        // Convert to string first
+         let message_str = audio_message.to_string();
+-        if let Err(e) = self.client_addr.try_send(SendText(message_str)) {
++        let compressed = compression::compress_message(&message_str)?;
++        
++        if let Err(e) = self.client_addr.try_send(SendCompressedMessage(compressed)) {
+             error!("Failed to send audio data to client: {}", e);
+             return Err(Box::new(WebSocketError::SendFailed(format!(
+                 "Failed to send audio data to client: {}", e
+@@ -224,9 +227,11 @@ impl OpenAIWebSocket {
+             "message": error_msg
+         });
+ 
+-        // Convert to string and send
++        // Convert to string first
+         let message_str = error_message.to_string();
+-        if let Err(e) = self.client_addr.try_send(SendText(message_str)) {
++        let compressed = compression::compress_message(&message_str)?;
++        
++        if let Err(e) = self.client_addr.try_send(SendCompressedMessage(compressed)) {
+             error!("Failed to send error message to client: {}", e);
+             return Err(Box::new(WebSocketError::SendFailed(format!(
+                 "Failed to send error message to client: {}", e
diff --git a/src/config.rs b/src/config.rs
index bf9d1547..ca726187 100644
--- a/src/config.rs
+++ b/src/config.rs
@@ -256,6 +256,7 @@ impl fmt::Display for VisualizationSettings {
 #[cfg(test)]
 mod tests {
     use super::*;
+    use crate::models::simulation_params::{SimulationParams, SimulationPhase};
 
     #[test]
     fn test_simulation_params_from_config() {
@@ -276,39 +277,63 @@ mod tests {
             force_directed_damping: 0.8,
         };
 
-        let params = crate::models::simulation_params::SimulationParams::from_config(&config);
+        let params = SimulationParams::from_config(&config, SimulationPhase::Initial);
         assert_eq!(params.iterations, 100);
+        assert_eq!(params.spring_strength, 0.1);
         assert_eq!(params.repulsion_strength, 1000.0);
         assert_eq!(params.attraction_strength, 0.01);
         assert_eq!(params.damping, 0.8);
+        assert!(params.is_initial_layout);
     }
 
     #[test]
     fn test_simulation_params_clamping() {
-        let params = crate::models::simulation_params::SimulationParams::new(5, 50.0, 0.001, 0.05);
-        assert_eq!(params.iterations, 10); // Clamped to min
-        assert_eq!(params.repulsion_strength, 100.0); // Clamped to min
-        assert_eq!(params.attraction_strength, 0.01); // Clamped to min
-        assert_eq!(params.damping, 0.1); // Clamped to min
+        let params = SimulationParams::new(
+            5,
+            0.0001, // spring_strength
+            0.5,    // repulsion_strength
+            0.0001, // attraction_strength
+            0.3,    // damping
+            false   // is_initial
+        );
+        assert_eq!(params.iterations, 5);
+        assert_eq!(params.spring_strength, 0.001); // Clamped to min
+        assert_eq!(params.repulsion_strength, 1.0); // Clamped to min
+        assert_eq!(params.attraction_strength, 0.001); // Clamped to min
+        assert_eq!(params.damping, 0.5); // Clamped to min
+        assert!(!params.is_initial_layout);
 
-        let params = crate::models::simulation_params::SimulationParams::new(1000, 10000.0, 2.0, 1.0);
+        let params = SimulationParams::new(
+            1000,
+            2.0,     // spring_strength
+            20000.0, // repulsion_strength
+            2.0,     // attraction_strength
+            1.0,     // damping
+            true     // is_initial
+        );
         assert_eq!(params.iterations, 500); // Clamped to max
-        assert_eq!(params.repulsion_strength, 5000.0); // Clamped to max
+        assert_eq!(params.spring_strength, 1.0); // Clamped to max
+        assert_eq!(params.repulsion_strength, 10000.0); // Clamped to max
         assert_eq!(params.attraction_strength, 1.0); // Clamped to max
-        assert_eq!(params.damping, 0.9); // Clamped to max
+        assert_eq!(params.damping, 0.95); // Clamped to max
+        assert!(params.is_initial_layout);
     }
 
     #[test]
     fn test_simulation_params_builder() {
-        let params = crate::models::simulation_params::SimulationParams::default()
+        let params = SimulationParams::default()
             .with_iterations(200)
-            .with_repulsion(2000.0)
-            .with_attraction(0.05)
-            .with_damping(0.7);
+            .with_spring_strength(0.5)
+            .with_repulsion_strength(5000.0)
+            .with_attraction_strength(0.05)
+            .with_damping(0.7)
+            .with_time_step(0.8);
 
-        assert_eq!(params.iterations, 200);
-        assert_eq!(params.repulsion_strength, 2000.0);
+        assert_eq!(params.iterations, 10); // Clamped to interactive max since not initial
+        assert_eq!(params.spring_strength, 0.5);
+        assert_eq!(params.repulsion_strength, 5000.0);
         assert_eq!(params.attraction_strength, 0.05);
         assert_eq!(params.damping, 0.7);
+        assert_eq!(params.time_step, 0.8);
     }
 }
diff --git a/src/handlers/file_handler.rs b/src/handlers/file_handler.rs
index 353f16fb..8ab2ddd4 100644
--- a/src/handlers/file_handler.rs
+++ b/src/handlers/file_handler.rs
@@ -1,9 +1,10 @@
-use actix_web::{web, HttpResponse};
+use actix_web::{web, Error as ActixError, HttpResponse};
 use serde_json::json;
 use log::{info, error, debug};
+use std::collections::HashMap;
 use crate::AppState;
 use crate::services::file_service::FileService;
-use crate::services::graph_service::GraphService;
+use crate::services::graph_service::{GraphService, FileMetadata};
 
 pub async fn fetch_and_process_files(state: web::Data<AppState>) -> HttpResponse {
     info!("Initiating optimized file fetch and processing");
@@ -141,3 +142,37 @@ pub async fn refresh_graph(state: web::Data<AppState>) -> HttpResponse {
         }
     }
 }
+
+pub async fn update_graph(state: web::Data<AppState>) -> Result<HttpResponse, ActixError> {
+    let metadata = state.file_cache.read().await;
+    
+    // Convert the file cache into the expected metadata format
+    let metadata_map: HashMap<String, FileMetadata> = metadata
+        .iter()
+        .map(|(key, _)| {
+            (key.clone(), FileMetadata {
+                topic_counts: HashMap::new(),
+            })
+        })
+        .collect();
+    
+    match GraphService::build_graph_from_metadata(&metadata_map).await {
+        Ok(graph) => {
+            // Update graph data
+            *state.graph_data.write().await = graph.clone();
+            
+            Ok(HttpResponse::Ok().json(json!({
+                "status": "success",
+                "message": "Graph updated successfully",
+                "data": graph
+            })))
+        },
+        Err(e) => {
+            error!("Failed to build graph: {}", e);
+            Ok(HttpResponse::InternalServerError().json(json!({
+                "status": "error",
+                "message": format!("Failed to build graph: {}", e)
+            })))
+        }
+    }
+}
diff --git a/src/handlers/mod.rs b/src/handlers/mod.rs
index cbf48a86..6bcd189b 100644
--- a/src/handlers/mod.rs
+++ b/src/handlers/mod.rs
@@ -1,9 +1,14 @@
 pub mod file_handler;
 pub mod graph_handler;
 pub mod ragflow_handler;
-pub mod visualization_handler;  // New module for visualization settings
+pub mod visualization_handler;
+pub mod websocket_handlers;
 
 pub use file_handler::*;
 pub use graph_handler::*;
 pub use ragflow_handler::*;
-pub use visualization_handler::*;  // Export visualization handler
+pub use visualization_handler::*;
+pub use websocket_handlers::*;
+
+// Re-export WebSocketSession and related types
+pub use websocket_handlers::{WebSocketSession, WebSocketSessionHandler, GpuUpdate};
diff --git a/src/handlers/websocket_handlers.rs b/src/handlers/websocket_handlers.rs
new file mode 100644
index 00000000..b5db38a6
--- /dev/null
+++ b/src/handlers/websocket_handlers.rs
@@ -0,0 +1,473 @@
+use actix::prelude::*;
+use actix_web::web;
+use actix_web_actors::ws::WebsocketContext;
+use log::{info, error, debug};
+use serde_json::json;
+use tokio::time::Duration;
+use std::sync::{Arc, Mutex};
+use futures::StreamExt;
+use bytes::Bytes;
+use bytestring::ByteString;
+
+use crate::AppState;
+use crate::models::simulation_params::{SimulationMode, SimulationParams};
+use crate::utils::websocket_messages::{SendText, SendBinary, OpenAIMessage, MessageHandler, OpenAIConnected, OpenAIConnectionFailed};
+use crate::utils::websocket_openai::OpenAIWebSocket;
+
+pub const OPENAI_CONNECT_TIMEOUT: Duration = Duration::from_secs(5);
+pub const GPU_UPDATE_INTERVAL: Duration = Duration::from_millis(16); // ~60fps for smooth updates
+
+// Message for GPU updates
+#[derive(Message)]
+#[rtype(result = "()")]
+pub struct GpuUpdate;
+
+/// WebSocket session actor.
+pub struct WebSocketSession {
+    pub state: web::Data<AppState>,
+    pub tts_method: String,
+    pub openai_ws: Option<Addr<OpenAIWebSocket>>,
+    pub simulation_mode: SimulationMode,
+    pub conversation_id: Option<Arc<Mutex<Option<String>>>>,
+}
+
+impl Actor for WebSocketSession {
+    type Context = WebsocketContext<Self>;
+}
+
+impl MessageHandler for WebSocketSession {}
+
+/// Helper function to convert hex color to proper format
+pub fn format_color(color: &str) -> String {
+    let color = color.trim_matches('"')
+        .trim_start_matches("0x")
+        .trim_start_matches('#');
+    format!("#{}", color)
+}
+
+/// Helper function to convert positions to binary Float32Array data
+pub fn positions_to_binary(positions: &Vec<[f32; 3]>) -> Vec<u8> {
+    let mut binary_data = Vec::with_capacity(positions.len() * 12); // 3 floats * 4 bytes each
+    for pos in positions {
+        // Ensure little-endian byte order for JavaScript Float32Array compatibility
+        binary_data.extend_from_slice(&pos[0].to_le_bytes());
+        binary_data.extend_from_slice(&pos[1].to_le_bytes());
+        binary_data.extend_from_slice(&pos[2].to_le_bytes());
+    }
+    binary_data
+}
+
+pub trait WebSocketSessionHandler {
+    fn start_gpu_updates(&self, ctx: &mut WebsocketContext<WebSocketSession>);
+    fn handle_chat_message(&mut self, ctx: &mut WebsocketContext<WebSocketSession>, message: String, use_openai: bool);
+    fn handle_simulation_mode(&mut self, ctx: &mut WebsocketContext<WebSocketSession>, mode: &str);
+    fn handle_layout(&mut self, ctx: &mut WebsocketContext<WebSocketSession>, params: SimulationParams);
+    fn handle_initial_data(&mut self, ctx: &mut WebsocketContext<WebSocketSession>);
+    fn handle_fisheye_settings(&mut self, ctx: &mut WebsocketContext<WebSocketSession>, enabled: bool, strength: f32, focus_point: [f32; 3], radius: f32);
+}
+
+impl Handler<GpuUpdate> for WebSocketSession {
+    type Result = ResponseActFuture<Self, ()>;
+
+    fn handle(&mut self, _: GpuUpdate, ctx: &mut Self::Context) -> Self::Result {
+        let state = self.state.clone();
+        let gpu_compute = if let Some(gpu) = &state.gpu_compute {
+            gpu.clone()
+        } else {
+            return Box::pin(futures::future::ready(()).into_actor(self));
+        };
+        let ctx_addr = ctx.address();
+
+        Box::pin(async move {
+            let mut gpu = gpu_compute.write().await;
+            if let Err(e) = gpu.step() {
+                error!("GPU compute step failed: {}", e);
+                return;
+            }
+
+            if let Ok(nodes) = gpu.get_node_positions().await {
+                let binary_data = nodes.iter()
+                    .flat_map(|node| {
+                        let mut data = Vec::with_capacity(24);
+                        data.extend_from_slice(&node.x.to_le_bytes());
+                        data.extend_from_slice(&node.y.to_le_bytes());
+                        data.extend_from_slice(&node.z.to_le_bytes());
+                        data.extend_from_slice(&node.vx.to_le_bytes());
+                        data.extend_from_slice(&node.vy.to_le_bytes());
+                        data.extend_from_slice(&node.vz.to_le_bytes());
+                        data
+                    })
+                    .collect::<Vec<u8>>();
+
+                if let Ok(sessions) = state.websocket_manager.sessions.lock() {
+                    for session in sessions.iter() {
+                        if session != &ctx_addr {
+                            let _ = session.do_send(SendBinary(binary_data.clone()));
+                        }
+                    }
+                }
+            }
+        }
+        .into_actor(self))
+    }
+}
+
+impl Handler<SendText> for WebSocketSession {
+    type Result = ();
+
+    fn handle(&mut self, msg: SendText, ctx: &mut Self::Context) {
+        ctx.text(ByteString::from(msg.0));
+    }
+}
+
+impl Handler<SendBinary> for WebSocketSession {
+    type Result = ();
+
+    fn handle(&mut self, msg: SendBinary, ctx: &mut Self::Context) {
+        ctx.binary(Bytes::from(msg.0));
+    }
+}
+
+impl Handler<OpenAIMessage> for WebSocketSession {
+    type Result = ();
+
+    fn handle(&mut self, msg: OpenAIMessage, _ctx: &mut Self::Context) {
+        if let Some(ref ws) = self.openai_ws {
+            ws.do_send(msg);
+        }
+    }
+}
+
+impl Handler<OpenAIConnected> for WebSocketSession {
+    type Result = ();
+
+    fn handle(&mut self, _: OpenAIConnected, _ctx: &mut Self::Context) {
+        debug!("OpenAI WebSocket connected");
+    }
+}
+
+impl Handler<OpenAIConnectionFailed> for WebSocketSession {
+    type Result = ();
+
+    fn handle(&mut self, _: OpenAIConnectionFailed, _ctx: &mut Self::Context) {
+        error!("OpenAI WebSocket connection failed");
+        self.openai_ws = None;
+    }
+}
+
+impl WebSocketSessionHandler for WebSocketSession {
+    fn start_gpu_updates(&self, ctx: &mut WebsocketContext<WebSocketSession>) {
+        let addr = ctx.address();
+        ctx.run_interval(GPU_UPDATE_INTERVAL, move |_, _| {
+            addr.do_send(GpuUpdate);
+        });
+    }
+
+    fn handle_chat_message(&mut self, ctx: &mut WebsocketContext<WebSocketSession>, message: String, use_openai: bool) {
+        let state = self.state.clone();
+        let conversation_id = self.conversation_id.clone();
+        let ctx_addr = ctx.address();
+        let settings = self.state.settings.clone();
+        let weak_addr = ctx.address().downgrade();
+
+        let fut = async move {
+            let conv_id = if let Some(conv_arc) = conversation_id {
+                if let Some(id) = conv_arc.lock().unwrap().clone() {
+                    id
+                } else {
+                    match state.ragflow_service.create_conversation("default_user".to_string()).await {
+                        Ok(new_id) => new_id,
+                        Err(e) => {
+                            error!("Failed to create conversation: {}", e);
+                            return;
+                        }
+                    }
+                }
+            } else {
+                error!("No conversation ID available");
+                return;
+            };
+
+            match state.ragflow_service.send_message(
+                conv_id.clone(),
+                message.clone(),
+                false,
+                None,
+                false,
+            ).await {
+                Ok(mut stream) => {
+                    debug!("RAGFlow service initialized for conversation {}", conv_id);
+                    
+                    if let Some(result) = stream.next().await {
+                        match result {
+                            Ok(text) => {
+                                debug!("Received text response from RAGFlow: {}", text);
+                                
+                                if use_openai {
+                                    debug!("Creating OpenAI WebSocket for TTS");
+                                    let openai_ws = OpenAIWebSocket::new(ctx_addr.clone(), settings);
+                                    let addr = openai_ws.start();
+                                    
+                                    debug!("Waiting for OpenAI WebSocket to be ready");
+                                    tokio::time::sleep(OPENAI_CONNECT_TIMEOUT).await;
+                                    
+                                    debug!("Sending text to OpenAI TTS: {}", text);
+                                    addr.do_send(OpenAIMessage(text));
+                                } else {
+                                    debug!("Using local TTS service");
+                                    if let Err(e) = state.speech_service.send_message(text).await {
+                                        error!("Failed to generate speech: {}", e);
+                                        let error_message = json!({
+                                            "type": "error",
+                                            "message": format!("Failed to generate speech: {}", e)
+                                        });
+                                        if let Ok(error_str) = serde_json::to_string(&error_message) {
+                                            ctx_addr.do_send(SendText(error_str));
+                                        }
+                                    }
+                                }
+                            },
+                            Err(e) => {
+                                error!("Error processing RAGFlow response: {}", e);
+                                let error_message = json!({
+                                    "type": "error",
+                                    "message": format!("Error processing RAGFlow response: {}", e)
+                                });
+                                if let Ok(error_str) = serde_json::to_string(&error_message) {
+                                    ctx_addr.do_send(SendText(error_str));
+                                }
+                            }
+                        }
+                    }
+                },
+                Err(e) => {
+                    error!("Failed to send message to RAGFlow: {}", e);
+                    let error_message = json!({
+                        "type": "error",
+                        "message": format!("Failed to send message to RAGFlow: {}", e)
+                    });
+                    if let Ok(error_str) = serde_json::to_string(&error_message) {
+                        ctx_addr.do_send(SendText(error_str));
+                    }
+                }
+            }
+
+            // Only send completion message if the actor is still alive
+            if let Some(addr) = weak_addr.upgrade() {
+                addr.do_send(SendText("Chat message handled".to_string()));
+            }
+        };
+
+        ctx.spawn(fut.into_actor(self));
+    }
+
+    fn handle_simulation_mode(&mut self, ctx: &mut WebsocketContext<WebSocketSession>, mode: &str) {
+        self.simulation_mode = match mode {
+            "remote" => {
+                info!("Simulation mode set to Remote (GPU-accelerated)");
+                // Start GPU position updates when switching to remote mode
+                if let Some(_) = &self.state.gpu_compute {
+                    self.start_gpu_updates(ctx);
+                }
+                SimulationMode::Remote
+            },
+            "gpu" => {
+                info!("Simulation mode set to GPU (local)");
+                SimulationMode::GPU
+            },
+            "local" => {
+                info!("Simulation mode set to Local (CPU)");
+                SimulationMode::Local
+            },
+            _ => {
+                error!("Invalid simulation mode: {}, defaulting to Remote", mode);
+                SimulationMode::Remote
+            }
+        };
+
+        let response = json!({
+            "type": "simulation_mode_set",
+            "mode": mode,
+            "gpu_enabled": matches!(self.simulation_mode, SimulationMode::Remote | SimulationMode::GPU)
+        });
+        <Self as MessageHandler>::send_json_response(self, response, ctx);
+    }
+
+    fn handle_layout(&mut self, ctx: &mut WebsocketContext<WebSocketSession>, params: SimulationParams) {
+        let state = self.state.clone();
+        let ctx_addr = ctx.address();
+        let weak_addr = ctx.address().downgrade();
+
+        let fut = async move {
+            if let Some(gpu_compute) = &state.gpu_compute {
+                let mut gpu = gpu_compute.write().await;
+                
+                if let Err(e) = gpu.update_simulation_params(&params) {
+                    error!("Failed to update simulation parameters: {}", e);
+                    let error_message = json!({
+                        "type": "error",
+                        "message": format!("Failed to update simulation parameters: {}", e)
+                    });
+                    if let Ok(error_str) = serde_json::to_string(&error_message) {
+                        ctx_addr.do_send(SendText(error_str));
+                    }
+                    return;
+                }
+
+                for _ in 0..params.iterations {
+                    if let Err(e) = gpu.step() {
+                        error!("GPU compute step failed: {}", e);
+                        let error_message = json!({
+                            "type": "error",
+                            "message": format!("GPU compute step failed: {}", e)
+                        });
+                        if let Ok(error_str) = serde_json::to_string(&error_message) {
+                            ctx_addr.do_send(SendText(error_str));
+                        }
+                        return;
+                    }
+                }
+
+                match gpu.get_node_positions().await {
+                    Ok(nodes) => {
+                        let positions: Vec<[f32; 3]> = nodes.iter()
+                            .map(|node| [node.x, node.y, node.z])
+                            .collect();
+
+                        let binary_data = positions_to_binary(&positions);
+
+                        ctx_addr.do_send(SendBinary(binary_data));
+                    },
+                    Err(e) => {
+                        error!("Failed to get GPU node positions: {}", e);
+                        let error_message = json!({
+                            "type": "error",
+                            "message": format!("Failed to get GPU node positions: {}", e)
+                        });
+                        if let Ok(error_str) = serde_json::to_string(&error_message) {
+                            ctx_addr.do_send(SendText(error_str));
+                        }
+                    }
+                }
+            } else {
+                error!("GPU compute service not available");
+                let error_message = json!({
+                    "type": "error",
+                    "message": "GPU compute service not available"
+                });
+                if let Ok(error_str) = serde_json::to_string(&error_message) {
+                    ctx_addr.do_send(SendText(error_str));
+                }
+            }
+
+            // Only send completion message if the actor is still alive
+            if let Some(addr) = weak_addr.upgrade() {
+                addr.do_send(SendText("Layout update complete".to_string()));
+            }
+        };
+
+        ctx.spawn(fut.into_actor(self));
+    }
+
+    fn handle_initial_data(&mut self, ctx: &mut WebsocketContext<WebSocketSession>) {
+        let state = self.state.clone();
+        let ctx_addr = ctx.address();
+        let weak_addr = ctx.address().downgrade();
+
+        let fut = async move {
+            let graph_data = state.graph_data.read().await;
+            let settings = state.settings.read().await;
+            
+            let response = json!({
+                "type": "getInitialData",
+                "graph_data": &*graph_data,
+                "settings": {
+                    "visualization": {
+                        "nodeColor": format_color(&settings.visualization.node_color),
+                        "edgeColor": format_color(&settings.visualization.edge_color),
+                        "hologramColor": format_color(&settings.visualization.hologram_color),
+                        "nodeSizeScalingFactor": settings.visualization.node_size_scaling_factor,
+                        "hologramScale": settings.visualization.hologram_scale,
+                        "hologramOpacity": settings.visualization.hologram_opacity,
+                        "edgeOpacity": settings.visualization.edge_opacity,
+                        "labelFontSize": settings.visualization.label_font_size,
+                        "fogDensity": settings.visualization.fog_density,
+                        "forceDirectedIterations": settings.visualization.force_directed_iterations,
+                        "forceDirectedRepulsion": settings.visualization.force_directed_repulsion,
+                        "forceDirectedAttraction": settings.visualization.force_directed_attraction,
+                    },
+                    "bloom": {
+                        "nodeBloomStrength": settings.bloom.node_bloom_strength,
+                        "nodeBloomRadius": settings.bloom.node_bloom_radius,
+                        "nodeBloomThreshold": settings.bloom.node_bloom_threshold,
+                        "edgeBloomStrength": settings.bloom.edge_bloom_strength,
+                        "edgeBloomRadius": settings.bloom.edge_bloom_radius,
+                        "edgeBloomThreshold": settings.bloom.edge_bloom_threshold,
+                        "environmentBloomStrength": settings.bloom.environment_bloom_strength,
+                        "environmentBloomRadius": settings.bloom.environment_bloom_radius,
+                        "environmentBloomThreshold": settings.bloom.environment_bloom_threshold,
+                    },
+                    "fisheye": {
+                        "enabled": settings.fisheye.enabled,
+                        "strength": settings.fisheye.strength,
+                        "focusPoint": settings.fisheye.focus_point,
+                        "radius": settings.fisheye.radius,
+                    }
+                }
+            });
+
+            debug!("Sending initial data response: {:?}", response);
+
+            if let Ok(response_str) = serde_json::to_string(&response) {
+                ctx_addr.do_send(SendText(response_str));
+            }
+
+            // Only send completion message if the actor is still alive
+            if let Some(addr) = weak_addr.upgrade() {
+                addr.do_send(SendText("Initial data sent".to_string()));
+            }
+        };
+
+        ctx.spawn(fut.into_actor(self));
+    }
+
+    fn handle_fisheye_settings(&mut self, ctx: &mut WebsocketContext<WebSocketSession>, enabled: bool, strength: f32, focus_point: [f32; 3], radius: f32) {
+        let state = self.state.clone();
+        let ctx_addr = ctx.address();
+        let weak_addr = ctx.address().downgrade();
+
+        let fut = async move {
+            if let Some(gpu_compute) = &state.gpu_compute {
+                let mut gpu = gpu_compute.write().await;
+                gpu.update_fisheye_params(enabled, strength, focus_point, radius);
+                
+                let response = json!({
+                    "type": "fisheye_settings_updated",
+                    "enabled": enabled,
+                    "strength": strength,
+                    "focus_point": focus_point,
+                    "radius": radius
+                });
+                if let Ok(response_str) = serde_json::to_string(&response) {
+                    ctx_addr.do_send(SendText(response_str));
+                }
+            } else {
+                error!("GPU compute service not available");
+                let error_message = json!({
+                    "type": "error",
+                    "message": "GPU compute service not available"
+                });
+                if let Ok(error_str) = serde_json::to_string(&error_message) {
+                    ctx_addr.do_send(SendText(error_str));
+                }
+            }
+
+            // Only send completion message if the actor is still alive
+            if let Some(addr) = weak_addr.upgrade() {
+                addr.do_send(SendText("Fisheye settings updated".to_string()));
+            }
+        };
+
+        ctx.spawn(fut.into_actor(self));
+    }
+}
diff --git a/src/models/graph.rs b/src/models/graph.rs
index 6476595e..bb6919c8 100644
--- a/src/models/graph.rs
+++ b/src/models/graph.rs
@@ -2,9 +2,9 @@
 
 use super::node::Node;
 use super::edge::Edge;
-use super::metadata::Metadata; // Import Metadata
+use super::metadata::Metadata;
 use serde::{Deserialize, Serialize};
-use std::collections::HashMap; // Import HashMap
+use std::collections::HashMap;
 
 /// Represents the graph data structure containing nodes and edges.
 #[derive(Default, Serialize, Deserialize, Clone, Debug)]
@@ -14,5 +14,15 @@ pub struct GraphData {
     /// List of edges connecting the nodes.
     pub edges: Vec<Edge>,
     /// Metadata associated with the graph.
-    pub metadata: HashMap<String, Metadata>, // Add metadata field
+    pub metadata: HashMap<String, Metadata>,
+}
+
+impl GraphData {
+    pub fn new() -> Self {
+        Self {
+            nodes: Vec::new(),
+            edges: Vec::new(),
+            metadata: HashMap::new(),
+        }
+    }
 }
diff --git a/src/models/node.rs b/src/models/node.rs
index cc89304f..c85069f7 100644
--- a/src/models/node.rs
+++ b/src/models/node.rs
@@ -16,6 +16,81 @@ pub struct Node {
     pub vy: f32,
     #[serde(skip)]
     pub vz: f32,
+    #[serde(skip)]
+    pub file_size: u64, // Used to calculate mass
+}
+
+impl Node {
+    pub fn new(id: String) -> Self {
+        Self {
+            id: id.clone(),
+            label: id,
+            metadata: HashMap::new(),
+            x: 0.0,
+            y: 0.0,
+            z: 0.0,
+            vx: 0.0,
+            vy: 0.0,
+            vz: 0.0,
+            file_size: 0,
+        }
+    }
+
+    /// Convert file size to quantized mass value (0-255)
+    fn calculate_mass(&self) -> u8 {
+        // Scale file size logarithmically to 0-255 range
+        // Assuming file sizes from 0 to ~1GB
+        if self.file_size == 0 {
+            return 127; // Default mass for nodes without size
+        }
+        let log_size = (self.file_size as f64).log2();
+        let max_log = (1024.0 * 1024.0 * 1024.0_f64).log2(); // 1GB
+        let normalized = (log_size / max_log).min(1.0);
+        (normalized * 255.0) as u8
+    }
+
+    pub fn to_gpu_node(&self) -> GPUNode {
+        GPUNode {
+            x: self.x,
+            y: self.y,
+            z: self.z,
+            vx: self.vx,
+            vy: self.vy,
+            vz: self.vz,
+            mass: self.calculate_mass(),
+            flags: 0,
+            padding: [0; 2],
+        }
+    }
+
+    pub fn update_from_gpu_node(&mut self, gpu_node: &GPUNode) {
+        self.x = gpu_node.x;
+        self.y = gpu_node.y;
+        self.z = gpu_node.z;
+        self.vx = gpu_node.vx;
+        self.vy = gpu_node.vy;
+        self.vz = gpu_node.vz;
+    }
+
+    pub fn to_position_update(&self) -> GPUNodePositionUpdate {
+        GPUNodePositionUpdate {
+            x: self.x,
+            y: self.y,
+            z: self.z,
+            vx: self.vx,
+            vy: self.vy,
+            vz: self.vz,
+        }
+    }
+
+    pub fn update_from_position_update(&mut self, update: &GPUNodePositionUpdate) {
+        self.x = update.x;
+        self.y = update.y;
+        self.z = update.z;
+        self.vx = update.vx;
+        self.vy = update.vy;
+        self.vz = update.vz;
+    }
 }
 
 impl Default for Node {
@@ -30,6 +105,7 @@ impl Default for Node {
             vx: 0.0,
             vy: 0.0,
             vz: 0.0,
+            file_size: 0,
         }
     }
 }
@@ -40,9 +116,10 @@ impl Default for Node {
 /// struct Node {
 ///     position: vec3<f32>,  // 12 bytes
 ///     velocity: vec3<f32>,  // 12 bytes
-///     mass: f32,           // 4 bytes
-///     padding1: u32,        // 4 bytes
-/// }                        // Total: 32 bytes
+///     mass: u8,            // 1 byte (quantized from file size)
+///     flags: u8,           // 1 byte (can be used for node state)
+///     padding: vec2<u8>,   // 2 bytes to align to 28 bytes total
+/// }
 /// ```
 #[repr(C)]
 #[derive(Clone, Copy, Pod, Zeroable)]
@@ -55,37 +132,20 @@ pub struct GPUNode {
     pub vx: f32,
     pub vy: f32,
     pub vz: f32,
-    // Additional fields
-    pub mass: f32,
-    pub padding1: u32,  // Final padding to match WGSL struct
+    // Additional fields packed into 4 bytes
+    pub mass: u8,    // Quantized mass from file size
+    pub flags: u8,   // Node state flags
+    pub padding: [u8; 2], // Padding for alignment
 }
 
-impl From<&Node> for GPUNode {
-    fn from(node: &Node) -> Self {
-        Self {
-            x: node.x,
-            y: node.y,
-            z: node.z,
-            vx: node.vx,
-            vy: node.vy,
-            vz: node.vz,
-            mass: 1.0,
-            padding1: 0,
-        }
-    }
-}
-
-impl Node {
-    pub fn to_gpu_node(&self) -> GPUNode {
-        GPUNode::from(self)
-    }
-
-    pub fn update_from_gpu_node(&mut self, gpu_node: &GPUNode) {
-        self.x = gpu_node.x;
-        self.y = gpu_node.y;
-        self.z = gpu_node.z;
-        self.vx = gpu_node.vx;
-        self.vy = gpu_node.vy;
-        self.vz = gpu_node.vz;
-    }
+/// For position-only updates between client/server (24 bytes)
+#[repr(C)]
+#[derive(Clone, Copy, Pod, Zeroable)]
+pub struct GPUNodePositionUpdate {
+    pub x: f32,
+    pub y: f32,
+    pub z: f32,
+    pub vx: f32,
+    pub vy: f32,
+    pub vz: f32,
 }
diff --git a/src/models/position_update.rs b/src/models/position_update.rs
new file mode 100644
index 00000000..ec6d58fc
--- /dev/null
+++ b/src/models/position_update.rs
@@ -0,0 +1,70 @@
+use serde::{Serialize, Deserialize};
+use std::collections::HashMap;
+
+/// Represents a minimal position update for a node
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct NodePosition {
+    pub x: f32,
+    pub y: f32,
+    pub z: f32,
+}
+
+/// Represents a batch of position updates for multiple nodes
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct PositionUpdate {
+    /// Maps node indices to their new positions
+    pub positions: HashMap<usize, NodePosition>,
+    /// Optional timestamp for synchronization
+    pub timestamp: Option<u64>,
+}
+
+impl PositionUpdate {
+    pub fn new() -> Self {
+        Self {
+            positions: HashMap::new(),
+            timestamp: Some(std::time::SystemTime::now()
+                .duration_since(std::time::UNIX_EPOCH)
+                .unwrap()
+                .as_millis() as u64),
+        }
+    }
+
+    /// Adds a position update for a node
+    pub fn add_position(&mut self, index: usize, x: f32, y: f32, z: f32) {
+        self.positions.insert(index, NodePosition { x, y, z });
+    }
+
+    /// Creates a position update from changes only
+    pub fn from_changes(old_positions: &[(f32, f32, f32)], new_positions: &[(f32, f32, f32)]) -> Self {
+        let mut update = Self::new();
+        
+        for (i, (old, new)) in old_positions.iter().zip(new_positions.iter()).enumerate() {
+            if (old.0 - new.0).abs() > 0.001 || 
+               (old.1 - new.1).abs() > 0.001 || 
+               (old.2 - new.2).abs() > 0.001 {
+                update.add_position(i, new.0, new.1, new.2);
+            }
+        }
+        
+        update
+    }
+}
+
+/// Message types for WebSocket communication
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub enum GraphMessage {
+    /// Complete graph initialization
+    InitialGraph {
+        nodes: Vec<String>,  // Node IDs only
+        edges: Vec<(String, String, f32)>,  // (source, target, weight)
+        metadata: serde_json::Value,
+    },
+    /// Position updates only
+    PositionUpdate(PositionUpdate),
+    /// Parameter updates
+    ParameterUpdate {
+        spring_strength: Option<f32>,
+        damping: Option<f32>,
+        iterations: Option<u32>,
+    },
+}
diff --git a/src/models/simulation_params.rs b/src/models/simulation_params.rs
index d1a4e775..f430edc3 100644
--- a/src/models/simulation_params.rs
+++ b/src/models/simulation_params.rs
@@ -16,50 +16,57 @@ pub enum SimulationPhase {
 }
 
 /// Parameters controlling the force-directed graph layout simulation
-#[derive(Serialize, Deserialize)]
+#[derive(Serialize, Deserialize, Clone, Debug)]
 #[repr(C)]
 pub struct SimulationParams {
     pub iterations: u32,           // Range: 1-500, Default: varies by phase
-    pub spring_strength: f32,      // Range: 0.001-1.0, Default: 0.01 (reduced for stability)
+    pub spring_strength: f32,      // Range: 0.001-1.0, Default: 0.01
+    pub repulsion_strength: f32,   // Range: 1.0-10000.0, Default: 1000.0
+    pub attraction_strength: f32,  // Range: 0.001-1.0, Default: 0.01
     pub damping: f32,             // Range: 0.5-0.95, Default: 0.8
-    pub is_initial_layout: u32,   // 1 for initial layout, 0 for interactive
+    pub is_initial_layout: bool,   // true for initial layout, false for interactive
     pub time_step: f32,           // Animation time step (0.1-1.0)
-    pub padding2: u32,            // Padding for alignment
-    pub padding3: u32,            // Padding for alignment
-    pub padding4: u32,            // Complete 32-byte alignment
+    pub padding: u32,             // Complete 32-byte alignment
 }
 
 impl Default for SimulationParams {
     fn default() -> Self {
         Self {
-            iterations: 5,          // Default to interactive mode iterations
-            spring_strength: 0.01,  // Reduced default strength for better stability
-            damping: 0.8,          // Balanced damping for smooth movement
-            is_initial_layout: 0,   // Default to interactive mode
-            time_step: 0.5,        // Reduced time step for smoother animation
-            padding2: 0,
-            padding3: 0,
-            padding4: 0,
+            iterations: 5,
+            spring_strength: 0.01,
+            repulsion_strength: 1000.0,
+            attraction_strength: 0.01,
+            damping: 0.8,
+            is_initial_layout: false,
+            time_step: 0.5,
+            padding: 0,
         }
     }
 }
 
 impl SimulationParams {
     /// Creates new simulation parameters with validation
-    pub fn new(iterations: u32, spring_strength: f32, damping: f32, is_initial: bool) -> Self {
+    pub fn new(
+        iterations: u32,
+        spring_strength: f32,
+        repulsion_strength: f32,
+        attraction_strength: f32,
+        damping: f32,
+        is_initial: bool
+    ) -> Self {
         Self {
             iterations: if is_initial { 
                 iterations.clamp(200, 500) // More iterations for initial layout
             } else {
                 iterations.clamp(1, 10)    // Fewer iterations for interactive updates
             },
-            spring_strength: spring_strength.clamp(0.001, 1.0), // Reduced range for better control
-            damping: damping.clamp(0.5, 0.95), // Increased minimum damping for stability
-            is_initial_layout: if is_initial { 1 } else { 0 },
-            time_step: 0.5, // Default to moderate time step
-            padding2: 0,
-            padding3: 0,
-            padding4: 0,
+            spring_strength: spring_strength.clamp(0.001, 1.0),
+            repulsion_strength: repulsion_strength.clamp(1.0, 10000.0),
+            attraction_strength: attraction_strength.clamp(0.001, 1.0),
+            damping: damping.clamp(0.5, 0.95),
+            is_initial_layout: is_initial,
+            time_step: 0.5,
+            padding: 0,
         }
     }
 
@@ -69,6 +76,8 @@ impl SimulationParams {
         Self::new(
             if is_initial { config.force_directed_iterations } else { 5 },
             config.force_directed_spring,
+            config.force_directed_repulsion,
+            config.force_directed_attraction,
             config.force_directed_damping,
             is_initial
         )
@@ -76,7 +85,7 @@ impl SimulationParams {
 
     /// Updates iterations with phase-appropriate validation
     pub fn with_iterations(mut self, iterations: u32) -> Self {
-        self.iterations = if self.is_initial_layout == 1 {
+        self.iterations = if self.is_initial_layout {
             iterations.clamp(200, 500)
         } else {
             iterations.clamp(1, 10)
@@ -90,6 +99,18 @@ impl SimulationParams {
         self
     }
 
+    /// Updates repulsion strength with validation
+    pub fn with_repulsion_strength(mut self, strength: f32) -> Self {
+        self.repulsion_strength = strength.clamp(1.0, 10000.0);
+        self
+    }
+
+    /// Updates attraction strength with validation
+    pub fn with_attraction_strength(mut self, strength: f32) -> Self {
+        self.attraction_strength = strength.clamp(0.001, 1.0);
+        self
+    }
+
     /// Updates damping with validation
     pub fn with_damping(mut self, damping: f32) -> Self {
         self.damping = damping.clamp(0.5, 0.95);
@@ -104,26 +125,8 @@ impl SimulationParams {
 }
 
 // Manual implementations for required GPU traits
-impl Clone for SimulationParams {
-    fn clone(&self) -> Self {
-        *self
-    }
-}
-
 impl Copy for SimulationParams {}
 
-impl std::fmt::Debug for SimulationParams {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        f.debug_struct("SimulationParams")
-            .field("iterations", &self.iterations)
-            .field("spring_strength", &self.spring_strength)
-            .field("damping", &self.damping)
-            .field("is_initial_layout", &self.is_initial_layout)
-            .field("time_step", &self.time_step)
-            .finish()
-    }
-}
-
 // SAFETY: This type is #[repr(C)], contains only Pod types (u32 and f32),
 // and has explicit padding for proper alignment. All bit patterns are valid.
 unsafe impl bytemuck::Pod for SimulationParams {}
@@ -140,26 +143,29 @@ mod tests {
         let params = SimulationParams::default();
         assert_eq!(params.iterations, 5);
         assert_eq!(params.spring_strength, 0.01);
+        assert_eq!(params.repulsion_strength, 1000.0);
+        assert_eq!(params.attraction_strength, 0.01);
         assert_eq!(params.damping, 0.8);
-        assert_eq!(params.is_initial_layout, 0);
-        assert_eq!(params.time_step, 0.5);
+        assert!(!params.is_initial_layout);
     }
 
     #[test]
     fn test_simulation_params_validation() {
-        // Test interactive mode limits
-        let params = SimulationParams::new(20, 0.0001, 0.3, false);
+        let params = SimulationParams::new(20, 0.0001, 0.5, 0.0001, 0.3, false);
         assert_eq!(params.iterations, 10); // Clamped to interactive max
         assert_eq!(params.spring_strength, 0.001); // Clamped to min
+        assert_eq!(params.repulsion_strength, 1.0); // Clamped to min
+        assert_eq!(params.attraction_strength, 0.001); // Clamped to min
         assert_eq!(params.damping, 0.5); // Clamped to min
-        assert_eq!(params.is_initial_layout, 0);
+        assert!(!params.is_initial_layout);
 
-        // Test initial layout mode limits
-        let params = SimulationParams::new(600, 2.0, 1.0, true);
+        let params = SimulationParams::new(600, 2.0, 20000.0, 2.0, 1.0, true);
         assert_eq!(params.iterations, 500); // Clamped to max
         assert_eq!(params.spring_strength, 1.0); // Clamped to max
+        assert_eq!(params.repulsion_strength, 10000.0); // Clamped to max
+        assert_eq!(params.attraction_strength, 1.0); // Clamped to max
         assert_eq!(params.damping, 0.95); // Clamped to max
-        assert_eq!(params.is_initial_layout, 1);
+        assert!(params.is_initial_layout);
     }
 
     #[test]
@@ -167,11 +173,15 @@ mod tests {
         let params = SimulationParams::default()
             .with_iterations(200)
             .with_spring_strength(0.5)
+            .with_repulsion_strength(5000.0)
+            .with_attraction_strength(0.05)
             .with_damping(0.7)
             .with_time_step(0.8);
 
         assert_eq!(params.iterations, 10); // Clamped to interactive max
         assert_eq!(params.spring_strength, 0.5);
+        assert_eq!(params.repulsion_strength, 5000.0);
+        assert_eq!(params.attraction_strength, 0.05);
         assert_eq!(params.damping, 0.7);
         assert_eq!(params.time_step, 0.8);
     }
diff --git a/src/services/graph_service.rs b/src/services/graph_service.rs
index eca019e3..ad9d97b6 100644
--- a/src/services/graph_service.rs
+++ b/src/services/graph_service.rs
@@ -1,109 +1,105 @@
-use crate::AppState;
+use std::collections::HashMap;
+use std::fs;
+use std::path::Path;
+use std::io::Error;
+use std::sync::Arc;
+use tokio::sync::RwLock;
+use actix_web::web;
+use log::{info, warn};
+use rand::Rng;
 use crate::models::graph::GraphData;
 use crate::models::node::Node;
 use crate::models::edge::Edge;
-use crate::models::metadata::Metadata;
-use crate::utils::gpu_compute::GPUCompute;
 use crate::models::simulation_params::SimulationParams;
-use log::{info, warn, debug};
-use std::collections::{HashMap, HashSet};
-use tokio::fs;
-use std::sync::Arc;
-use tokio::sync::RwLock;
-use serde_json;
+use crate::utils::gpu_compute::GPUCompute;
+use crate::AppState;
+
+pub struct FileMetadata {
+    pub topic_counts: HashMap<String, u32>,
+}
 
-/// Service responsible for building and managing the graph data structure.
-pub struct GraphService;
+pub struct GraphService {
+    pub graph_data: Arc<RwLock<GraphData>>,
+}
 
 impl GraphService {
-    /// Builds the graph data structure from processed Markdown files.
-    pub async fn build_graph(app_state: &AppState) -> Result<GraphData, Box<dyn std::error::Error + Send + Sync>> {
-        info!("Building graph data from metadata");
-        let metadata_path = "/app/data/markdown/metadata.json";
-        let metadata_content = fs::read_to_string(metadata_path).await?;
-        let metadata: HashMap<String, Metadata> = serde_json::from_str(&metadata_content)?;
-    
-        let mut graph = GraphData::default();
-        let mut edge_map: HashMap<(String, String), f32> = HashMap::new();
-    
-        // Create nodes with default positions first
-        for (file_name, file_metadata) in &metadata {
-            let node_id = file_name.trim_end_matches(".md").to_string();
-            let mut node_metadata = HashMap::new();
-            
-            // Add file metadata to node
-            node_metadata.insert("file_size".to_string(), file_metadata.file_size.to_string());
-            node_metadata.insert("node_size".to_string(), file_metadata.node_size.to_string());
-            node_metadata.insert("last_modified".to_string(), file_metadata.last_modified.to_string());
-            node_metadata.insert("hyperlink_count".to_string(), file_metadata.hyperlink_count.to_string());
-            
-            graph.nodes.push(Node {
-                id: node_id.clone(),
-                label: node_id.clone(),
-                metadata: node_metadata,
-                x: 0.0,
-                y: 0.0,
-                z: 0.0,
-                vx: 0.0,
-                vy: 0.0,
-                vz: 0.0,
-            });
-            graph.metadata.insert(node_id.clone(), file_metadata.clone());
+    pub fn new() -> Self {
+        GraphService {
+            graph_data: Arc::new(RwLock::new(GraphData::new())),
         }
-    
-        // Build edges from topic counts
-        for (file_name, file_metadata) in &metadata {
-            let source_id = file_name.trim_end_matches(".md").to_string();
-            
-            // Look through all references in topic_counts
-            for (target_id, reference_count) in &file_metadata.topic_counts {
-                if source_id != *target_id {
-                    // Create a canonical edge key (alphabetically ordered)
-                    let edge_key = if source_id < *target_id {
-                        (source_id.clone(), target_id.clone())
-                    } else {
-                        (target_id.clone(), source_id.clone())
-                    };
+    }
 
-                    // Update edge weight
-                    edge_map.entry(edge_key)
-                        .and_modify(|weight| *weight += *reference_count as f32)
-                        .or_insert(*reference_count as f32);
-                }
+    pub async fn build_graph(state: &web::Data<AppState>) -> Result<GraphData, Box<dyn std::error::Error + Send + Sync>> {
+        let file_cache = state.file_cache.read().await;
+        let mut graph = GraphData::new();
+        let edge_map = HashMap::new();
+
+        // Build nodes from file cache
+        for (file_name, _content) in file_cache.iter() {
+            let source_id = file_name.trim_end_matches(".md").to_string();
+            if !graph.nodes.iter().any(|n| n.id == source_id) {
+                graph.nodes.push(Node::new(source_id));
             }
         }
-    
+
+        // Initialize random positions for all nodes
+        Self::initialize_random_positions(&mut graph);
+
         // Convert edge_map to edges
         graph.edges = edge_map.into_iter().map(|((source, target), weight)| {
             Edge::new(source, target, weight)
         }).collect();
-        
-        info!("Graph data built with {} nodes and {} edges", graph.nodes.len(), graph.edges.len());
-        debug!("Sample node data: {:?}", graph.nodes.first());
-        debug!("Sample edge data: {:?}", graph.edges.first());
 
-        // Calculate layout using GPU if available, otherwise fall back to CPU
-        let settings = app_state.settings.read().await;
-        let params = SimulationParams::new(
-            settings.visualization.force_directed_iterations as u32,
-            settings.visualization.force_directed_spring,
-            settings.visualization.force_directed_damping,
-            true // Initial layout
-        );
+        info!("Built graph with {} nodes and {} edges", graph.nodes.len(), graph.edges.len());
+        Ok(graph)
+    }
 
-        Self::calculate_layout(&app_state.gpu_compute, &mut graph, &params).await?;
-        
-        debug!("Final sample node data after layout calculation: {:?}", graph.nodes.first());
+    pub async fn load_graph(&self, path: &Path) -> Result<(), Error> {
+        info!("Loading graph from {}", path.display());
+        let mut nodes = Vec::new();
+        let edge_map = HashMap::new();
+
+        // Read directory and create nodes
+        if let Ok(entries) = fs::read_dir(path) {
+            for entry in entries.flatten() {
+                let path = entry.path();
+                if path.is_file() {
+                    let _file_size = fs::metadata(&path)
+                        .map(|m| m.len())
+                        .unwrap_or(0);
+
+                    let file_name = path.file_name()
+                        .and_then(|n| n.to_str())
+                        .unwrap_or("unknown")
+                        .to_string();
+
+                    nodes.push(Node::new(file_name));
+                }
+            }
+        }
+
+        // Initialize random positions for the nodes
+        let mut graph = GraphData {
+            nodes,
+            edges: edge_map.into_iter().map(|((source, target), weight)| {
+                Edge::new(source, target, weight)
+            }).collect(),
+            metadata: HashMap::new(),
+        };
+
+        Self::initialize_random_positions(&mut graph);
         
-        Ok(graph)
+        // Update graph data
+        let mut graph_data = self.graph_data.write().await;
+        *graph_data = graph;
+
+        info!("Graph loaded with {} nodes and {} edges", 
+            graph_data.nodes.len(), graph_data.edges.len());
+        Ok(())
     }
 
-    /// Initializes random positions for nodes in a spherical distribution
     fn initialize_random_positions(graph: &mut GraphData) {
-        use rand::Rng;
         let mut rng = rand::thread_rng();
-        
-        // Use a smaller initial radius to prevent nodes from spreading too far
         let initial_radius = 30.0;
         
         for node in &mut graph.nodes {
@@ -114,151 +110,92 @@ impl GraphService {
             node.x = r * theta.cos() * phi.sin();
             node.y = r * theta.sin() * phi.sin();
             node.z = r * phi.cos();
-            
-            // Initialize velocities to 0
             node.vx = 0.0;
             node.vy = 0.0;
             node.vz = 0.0;
         }
     }
 
-    /// Calculates the force-directed layout using GPUCompute if available, otherwise falls back to CPU.
     pub async fn calculate_layout(
         gpu_compute: &Option<Arc<RwLock<GPUCompute>>>,
         graph: &mut GraphData,
         params: &SimulationParams,
     ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
-        // Initialize random positions before layout calculation
-        Self::initialize_random_positions(graph);
-        
         match gpu_compute {
             Some(gpu) => {
                 info!("Using GPU for layout calculation");
                 let mut gpu_compute = gpu.write().await;
+                
+                // Only initialize positions for new graphs
+                if graph.nodes.iter().all(|n| n.x == 0.0 && n.y == 0.0 && n.z == 0.0) {
+                    Self::initialize_random_positions(graph);
+                }
+                
                 gpu_compute.update_graph_data(graph)?;
                 gpu_compute.update_simulation_params(params)?;
                 
-                // Run multiple iterations with position updates
-                for i in 0..params.iterations {
+                // Run iterations with more frequent updates
+                for _ in 0..params.iterations {
                     gpu_compute.step()?;
                     
-                    // Update positions every few iterations to maintain stability
-                    if i % 10 == 0 {
-                        let updated_nodes = gpu_compute.get_node_positions().await?;
-                        for (i, node) in graph.nodes.iter_mut().enumerate() {
-                            node.update_from_gpu_node(&updated_nodes[i]);
-                            
-                            // Add bounds checking
-                            let max_coord = 100.0;
-                            node.x = node.x.clamp(-max_coord, max_coord);
-                            node.y = node.y.clamp(-max_coord, max_coord);
-                            node.z = node.z.clamp(-max_coord, max_coord);
-                        }
+                    // Update positions every iteration for smoother motion
+                    let updated_nodes = gpu_compute.get_node_positions().await?;
+                    for (i, node) in graph.nodes.iter_mut().enumerate() {
+                        node.update_from_gpu_node(&updated_nodes[i]);
+                        
+                        // Apply bounds
+                        let max_coord = 100.0;
+                        node.x = node.x.clamp(-max_coord, max_coord);
+                        node.y = node.y.clamp(-max_coord, max_coord);
+                        node.z = node.z.clamp(-max_coord, max_coord);
                     }
                 }
-                
-                debug!("GPU layout calculation complete. Sample updated node: {:?}", graph.nodes.first());
+                Ok(())
             },
             None => {
                 warn!("GPU not available. Falling back to CPU-based layout calculation.");
                 Self::calculate_layout_cpu(graph, params.iterations, params.spring_strength, params.damping);
-                debug!("CPU layout calculation complete. Sample updated node: {:?}", graph.nodes.first());
+                Ok(())
             }
         }
-        Ok(())
     }
 
-    /// Calculates the force-directed layout using CPU.
     fn calculate_layout_cpu(graph: &mut GraphData, iterations: u32, spring_strength: f32, damping: f32) {
-        let repulsion_strength = spring_strength * 10000.0; // Increase repulsion for better spacing
+        let repulsion_strength = spring_strength * 10000.0;
         
         for _ in 0..iterations {
-            // Calculate repulsive forces
+            // Calculate forces between nodes
             for i in 0..graph.nodes.len() {
-                for j in (i + 1)..graph.nodes.len() {
+                for j in i+1..graph.nodes.len() {
                     let dx = graph.nodes[j].x - graph.nodes[i].x;
                     let dy = graph.nodes[j].y - graph.nodes[i].y;
                     let dz = graph.nodes[j].z - graph.nodes[i].z;
-                    let distance = (dx * dx + dy * dy + dz * dz).sqrt().max(0.1);
-                    let force = repulsion_strength / (distance * distance);
-                    let fx = force * dx / distance;
-                    let fy = force * dy / distance;
-                    let fz = force * dz / distance;
-
-                    // Apply force with a maximum limit
-                    let max_force = 50.0;
-                    let force_magnitude = (fx * fx + fy * fy + fz * fz).sqrt();
-                    let scale = if force_magnitude > max_force {
-                        max_force / force_magnitude
-                    } else {
-                        1.0
-                    };
-
-                    graph.nodes[i].vx -= fx * scale;
-                    graph.nodes[i].vy -= fy * scale;
-                    graph.nodes[i].vz -= fz * scale;
-                    graph.nodes[j].vx += fx * scale;
-                    graph.nodes[j].vy += fy * scale;
-                    graph.nodes[j].vz += fz * scale;
+                    
+                    let distance = (dx * dx + dy * dy + dz * dz).sqrt();
+                    if distance > 0.0 {
+                        let force = repulsion_strength / (distance * distance);
+                        
+                        let fx = dx * force / distance;
+                        let fy = dy * force / distance;
+                        let fz = dz * force / distance;
+                        
+                        graph.nodes[i].vx -= fx;
+                        graph.nodes[i].vy -= fy;
+                        graph.nodes[i].vz -= fz;
+                        
+                        graph.nodes[j].vx += fx;
+                        graph.nodes[j].vy += fy;
+                        graph.nodes[j].vz += fz;
+                    }
                 }
             }
-
-            // Calculate attractive forces
-            for edge in &graph.edges {
-                let source = graph.nodes.iter().position(|n| n.id == edge.source).unwrap();
-                let target = graph.nodes.iter().position(|n| n.id == edge.target_node).unwrap();
-                let dx = graph.nodes[target].x - graph.nodes[source].x;
-                let dy = graph.nodes[target].y - graph.nodes[source].y;
-                let dz = graph.nodes[target].z - graph.nodes[source].z;
-                let distance = (dx * dx + dy * dy + dz * dz).sqrt().max(0.1);
-                
-                // Use spring strength and weight for attraction
-                let force = spring_strength * distance * edge.weight;
-                let fx = force * dx / distance;
-                let fy = force * dy / distance;
-                let fz = force * dz / distance;
-
-                // Apply force with a maximum limit
-                let max_force = 50.0;
-                let force_magnitude = (fx * fx + fy * fy + fz * fz).sqrt();
-                let scale = if force_magnitude > max_force {
-                    max_force / force_magnitude
-                } else {
-                    1.0
-                };
-
-                graph.nodes[source].vx += fx * scale;
-                graph.nodes[source].vy += fy * scale;
-                graph.nodes[source].vz += fz * scale;
-                graph.nodes[target].vx -= fx * scale;
-                graph.nodes[target].vy -= fy * scale;
-                graph.nodes[target].vz -= fz * scale;
-            }
-
-            // Update positions with bounds checking
+            
+            // Apply velocities and damping
             for node in &mut graph.nodes {
-                // Apply velocity limits
-                let max_velocity = 10.0;
-                let velocity_magnitude = (node.vx * node.vx + node.vy * node.vy + node.vz * node.vz).sqrt();
-                if velocity_magnitude > max_velocity {
-                    let scale = max_velocity / velocity_magnitude;
-                    node.vx *= scale;
-                    node.vy *= scale;
-                    node.vz *= scale;
-                }
-
-                // Update position
                 node.x += node.vx;
                 node.y += node.vy;
                 node.z += node.vz;
-
-                // Apply position bounds
-                let max_coord = 100.0;
-                node.x = node.x.clamp(-max_coord, max_coord);
-                node.y = node.y.clamp(-max_coord, max_coord);
-                node.z = node.z.clamp(-max_coord, max_coord);
-
-                // Apply damping
+                
                 node.vx *= damping;
                 node.vy *= damping;
                 node.vz *= damping;
@@ -266,58 +203,42 @@ impl GraphService {
         }
     }
 
-    /// Finds the shortest path between two nodes in the graph.
-    pub fn find_shortest_path(graph: &GraphData, start: &str, end: &str) -> Result<Vec<String>, String> {
-        let mut distances: HashMap<String, f32> = HashMap::new();
-        let mut previous: HashMap<String, Option<String>> = HashMap::new();
-        let mut unvisited: HashSet<String> = HashSet::new();
-    
-        for node in &graph.nodes {
-            distances.insert(node.id.clone(), f32::INFINITY);
-            previous.insert(node.id.clone(), None);
-            unvisited.insert(node.id.clone());
-        }
-        distances.insert(start.to_string(), 0.0);
-    
-        while !unvisited.is_empty() {
-            let current = unvisited.iter()
-                .min_by(|a, b| distances[*a].partial_cmp(&distances[*b]).unwrap())
-                .cloned()
-                .unwrap();
-    
-            if current == end {
-                break;
+    pub async fn build_graph_from_metadata(
+        metadata: &HashMap<String, FileMetadata>
+    ) -> Result<GraphData, Box<dyn std::error::Error + Send + Sync>> {
+        let mut graph = GraphData::new();
+        let mut edge_map = HashMap::new();
+
+        // Build nodes and edges
+        for (file_name, file_metadata) in metadata {
+            let source_id = file_name.trim_end_matches(".md").to_string();
+            
+            // Add node if it doesn't exist
+            if !graph.nodes.iter().any(|n| n.id == source_id) {
+                graph.nodes.push(Node::new(source_id.clone()));
             }
-    
-            unvisited.remove(&current);
-    
-            for edge in &graph.edges {
-                if edge.source == current || edge.target_node == current {
-                    let neighbor = if edge.source == current { &edge.target_node } else { &edge.source };
-                    if unvisited.contains(neighbor) {
-                        let alt = distances[&current] + edge.weight;
-                        if alt < distances[neighbor] {
-                            distances.insert(neighbor.to_string(), alt);
-                            previous.insert(neighbor.to_string(), Some(current.to_string()));
-                        }
-                    }
+
+            // Process references
+            for (target_id, reference_count) in &file_metadata.topic_counts {
+                if source_id != *target_id {
+                    let edge_key = if source_id < *target_id {
+                        (source_id.clone(), target_id.clone())
+                    } else {
+                        (target_id.clone(), source_id.clone())
+                    };
+
+                    edge_map.entry(edge_key)
+                        .and_modify(|weight| { *weight += *reference_count as f32 })
+                        .or_insert(*reference_count as f32);
                 }
             }
         }
-    
-        // Reconstruct path
-        let mut path = Vec::new();
-        let mut current = end.to_string();
-        while let Some(prev) = previous[&current].clone() {
-            path.push(current.clone());
-            current = prev;
-            if current == start {
-                path.push(start.to_string());
-                path.reverse();
-                return Ok(path);
-            }
-        }
-    
-        Err("No path found".to_string())
+
+        // Convert edge map to edges
+        graph.edges = edge_map.into_iter().map(|((source, target), weight)| {
+            Edge::new(source, target, weight)
+        }).collect();
+
+        Ok(graph)
     }
 }
diff --git a/src/utils/force_calculation.wgsl b/src/utils/force_calculation.wgsl
index ea1bd8e8..946ca4fc 100644
--- a/src/utils/force_calculation.wgsl
+++ b/src/utils/force_calculation.wgsl
@@ -1,8 +1,8 @@
 struct Node {
     position: vec3<f32>,  // 12 bytes
     velocity: vec3<f32>,  // 12 bytes
-    mass: f32,           // 4 bytes
-    padding1: u32,        // 4 bytes
+    mass: u32,           // 4 bytes (quantized 0-255 maps to 0.0-2.0, stored in lower 8 bits)
+    flags: u32,          // 4 bytes (can be used for node state)
 }
 
 struct Edge {
@@ -82,7 +82,12 @@ fn get_grid_index(position: vec3<f32>) -> u32 {
     return grid_pos.x + grid_pos.y * GRID_DIM + grid_pos.z * GRID_DIM * GRID_DIM;
 }
 
-fn calculate_spring_force(pos1: vec3<f32>, pos2: vec3<f32>, mass1: f32, mass2: f32, is_connected: bool, weight: f32) -> vec3<f32> {
+// Convert quantized mass (0-255) to float (0.0-2.0)
+fn decode_mass(mass: u32) -> f32 {
+    return f32(mass & 0xFFu) / 127.5;
+}
+
+fn calculate_spring_force(pos1: vec3<f32>, pos2: vec3<f32>, mass1: u32, mass2: u32, is_connected: bool, weight: f32) -> vec3<f32> {
     if (!is_valid_vec3(pos1) || !is_valid_vec3(pos2)) {
         return vec3<f32>(0.0);
     }
@@ -97,13 +102,17 @@ fn calculate_spring_force(pos1: vec3<f32>, pos2: vec3<f32>, mass1: f32, mass2: f
     let distance = sqrt(distance_sq);
     var force_magnitude: f32;
     
+    // Convert quantized masses to float
+    let mass1_f = decode_mass(mass1);
+    let mass2_f = decode_mass(mass2);
+    
     if (is_connected) {
         // Connected nodes: Hooke's law with natural length
         force_magnitude = params.spring_strength * (distance - NATURAL_LENGTH) * weight;
     } else {
         // Unconnected nodes: Inverse square repulsion
         let repulsion_scale = select(1.0, 0.5, params.is_initial_layout == 0u);
-        force_magnitude = -params.spring_strength * REPULSION_SCALE * repulsion_scale * mass1 * mass2 / (distance_sq + MIN_DISTANCE);
+        force_magnitude = -params.spring_strength * REPULSION_SCALE * repulsion_scale * mass1_f * mass2_f / (distance_sq + MIN_DISTANCE);
     }
     
     return clamp_vector(normalize(direction) * force_magnitude, MAX_FORCE);
@@ -181,7 +190,7 @@ fn compute_main(@builtin(global_invocation_id) global_id: vec3<u32>) {
     }
 
     // Update velocity and position with time step
-    node.velocity = clamp_vector((node.velocity + force / node.mass) * params.damping, MAX_VELOCITY);
+    node.velocity = clamp_vector((node.velocity + force / decode_mass(node.mass)) * params.damping, MAX_VELOCITY);
     node.position = clamp_position(node.position + node.velocity * params.time_step);
 
     if (!is_valid_vec3(node.position) || !is_valid_vec3(node.velocity)) {
diff --git a/src/utils/gpu_compute.rs b/src/utils/gpu_compute.rs
index 76441f4b..b92ba981 100644
--- a/src/utils/gpu_compute.rs
+++ b/src/utils/gpu_compute.rs
@@ -1,20 +1,19 @@
 use wgpu::{Device, Queue, Buffer, BindGroup, ComputePipeline, InstanceDescriptor};
 use wgpu::util::DeviceExt;
 use std::io::Error;
-use log::{debug, info, warn};
+use log::{debug, info};
 use crate::models::graph::GraphData;
-use crate::models::node::GPUNode;
 use crate::models::edge::GPUEdge;
+use crate::models::node::GPUNode;
 use crate::models::simulation_params::SimulationParams;
 use futures::channel::oneshot;
-use rand::Rng;
 
 // Constants for buffer management and computation
 const WORKGROUP_SIZE: u32 = 256;
 const INITIAL_BUFFER_SIZE: u64 = 1024 * 1024;  // 1MB initial size
 const BUFFER_ALIGNMENT: u64 = 256;  // Required GPU memory alignment
 const EDGE_SIZE: u64 = 32;  // Size of Edge struct (must match WGSL)
-const NODE_SIZE: u64 = 32;  // Size of Node struct in WGSL (vec3 alignment)
+const NODE_SIZE: u64 = 28;  // Size of Node struct in WGSL (optimized)
 const MAX_NODES: u32 = 1_000_000;  // Safety limit for number of nodes
 const MAX_EDGES: u32 = 5_000_000;  // Safety limit for number of edges
 
@@ -67,6 +66,10 @@ pub struct GPUCompute {
     simulation_params: SimulationParams,
     fisheye_params: FisheyeParams,
     is_initialized: bool,
+    position_update_buffer: Buffer,
+    position_staging_buffer: Buffer,
+    position_pipeline: ComputePipeline,
+    position_bind_group: BindGroup,
 }
 
 impl GPUCompute {
@@ -257,6 +260,72 @@ impl GPUCompute {
             usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
         });
 
+        // Create dedicated position buffers
+        let position_update_buffer = device.create_buffer(&wgpu::BufferDescriptor {
+            label: Some("Position Update Buffer"),
+            size: (MAX_NODES as u64) * 12, // 3 floats per node
+            usage: wgpu::BufferUsages::STORAGE 
+                | wgpu::BufferUsages::COPY_DST 
+                | wgpu::BufferUsages::COPY_SRC,
+            mapped_at_creation: false,
+        });
+
+        let position_staging_buffer = device.create_buffer(&wgpu::BufferDescriptor {
+            label: Some("Position Staging Buffer"),
+            size: (MAX_NODES as u64) * 12,
+            usage: wgpu::BufferUsages::MAP_READ | wgpu::BufferUsages::COPY_DST,
+            mapped_at_creation: false,
+        });
+
+        // Create position update shader module
+        let position_module = device.create_shader_module(wgpu::ShaderModuleDescriptor {
+            label: Some("Position Update Shader"),
+            source: wgpu::ShaderSource::Wgsl(include_str!("update_positions.wgsl").into()),
+        });
+
+        // Create position bind group layout
+        let position_bind_group_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
+            label: Some("Position Update Layout"),
+            entries: &[
+                wgpu::BindGroupLayoutEntry {
+                    binding: 0,
+                    visibility: wgpu::ShaderStages::COMPUTE,
+                    ty: wgpu::BindingType::Buffer {
+                        ty: wgpu::BufferBindingType::Storage { read_only: false },
+                        has_dynamic_offset: false,
+                        min_binding_size: None,
+                    },
+                    count: None,
+                },
+            ],
+        });
+
+        // Create position pipeline
+        let position_pipeline = device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
+            label: Some("Position Update Pipeline"),
+            layout: Some(&device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
+                label: Some("Position Pipeline Layout"),
+                bind_group_layouts: &[&position_bind_group_layout],
+                push_constant_ranges: &[],
+            })),
+            module: &position_module,
+            entry_point: Some("update_positions"),
+            cache: None,
+            compilation_options: Default::default(),
+        });
+
+        // Create position bind group
+        let position_bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
+            label: Some("Position Update Bind Group"),
+            layout: &position_bind_group_layout,
+            entries: &[
+                wgpu::BindGroupEntry {
+                    binding: 0,
+                    resource: position_update_buffer.as_entire_binding(),
+                },
+            ],
+        });
+
         // Create bind groups
         let force_bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
             label: Some("Force Compute Bind Group"),
@@ -311,6 +380,10 @@ impl GPUCompute {
             simulation_params,
             fisheye_params,
             is_initialized: false,
+            position_update_buffer,
+            position_staging_buffer,
+            position_pipeline,
+            position_bind_group,
         })
     }
 
@@ -323,8 +396,9 @@ impl GPUCompute {
             vx: node.vx,
             vy: node.vy,
             vz: node.vz,
-            mass: 1.0,
-            padding1: 0,
+            mass: 127, // Default mass of 1.0
+            flags: 0,
+            padding: [0; 2],
         }).collect();
 
         let gpu_edges: Vec<GPUEdge> = graph.edges.iter()
@@ -340,6 +414,103 @@ impl GPUCompute {
         Ok(())
     }
 
+    /// Fast path for position updates from client
+    pub async fn update_positions(&mut self, binary_data: &[u8]) -> Result<(), Error> {
+        // Verify data length (12 bytes per node)
+        let expected_size = self.num_nodes as usize * 12;
+        if binary_data.len() != expected_size {
+            return Err(Error::new(
+                std::io::ErrorKind::InvalidData,
+                format!("Invalid position data length: expected {}, got {}", 
+                    expected_size, binary_data.len())
+            ));
+        }
+
+        // Write directly to position buffer
+        self.queue.write_buffer(
+            &self.position_update_buffer,
+            0,
+            binary_data
+        );
+
+        // Run position validation shader
+        let mut encoder = self.device.create_command_encoder(
+            &wgpu::CommandEncoderDescriptor {
+                label: Some("Position Update Encoder"),
+            }
+        );
+
+        {
+            let mut compute_pass = encoder.begin_compute_pass(
+                &wgpu::ComputePassDescriptor {
+                    label: Some("Position Validation Pass"),
+                    timestamp_writes: None,
+                }
+            );
+
+            compute_pass.set_pipeline(&self.position_pipeline);
+            compute_pass.set_bind_group(0, &self.position_bind_group, &[]);
+            compute_pass.dispatch_workgroups(
+                (self.num_nodes + WORKGROUP_SIZE - 1) / WORKGROUP_SIZE, 
+                1, 
+                1
+            );
+        }
+
+        // Copy validated positions to node buffer
+        encoder.copy_buffer_to_buffer(
+            &self.position_update_buffer,
+            0,
+            &self.nodes_buffer,
+            0,
+            expected_size as u64,
+        );
+
+        self.queue.submit(Some(encoder.finish()));
+
+        Ok(())
+    }
+
+    /// Get current positions in binary format for client updates
+    pub async fn get_position_updates(&self) -> Result<Vec<u8>, Error> {
+        let mut encoder = self.device.create_command_encoder(
+            &wgpu::CommandEncoderDescriptor {
+                label: Some("Position Readback Encoder"),
+            }
+        );
+
+        // Copy only position data
+        encoder.copy_buffer_to_buffer(
+            &self.nodes_buffer,
+            0,
+            &self.position_staging_buffer,
+            0,
+            (self.num_nodes as u64) * 12,
+        );
+
+        self.queue.submit(Some(encoder.finish()));
+
+        // Map buffer and read positions
+        let buffer_slice = self.position_staging_buffer.slice(..);
+        let (sender, receiver) = futures::channel::oneshot::channel();
+        
+        buffer_slice.map_async(wgpu::MapMode::Read, move |result| {
+            sender.send(result).unwrap();
+        });
+        
+        self.device.poll(wgpu::Maintain::Wait);
+
+        receiver.await.unwrap()
+            .map_err(|e| Error::new(std::io::ErrorKind::Other, e.to_string()))?;
+
+        let data = buffer_slice.get_mapped_range();
+        let positions = data.to_vec();
+        drop(data);
+        self.position_staging_buffer.unmap();
+
+        Ok(positions)
+    }
+
     /// Updates simulation parameters
     pub fn update_simulation_params(&mut self, params: &SimulationParams) -> Result<(), Error> {
         self.simulation_params = *params;
diff --git a/src/utils/mod.rs b/src/utils/mod.rs
index 170c1c1b..4bc04eaa 100644
--- a/src/utils/mod.rs
+++ b/src/utils/mod.rs
@@ -1,5 +1,4 @@
 pub mod audio_processor;
-pub mod compression;
 pub mod gpu_compute;
 pub mod websocket_manager;
 pub mod websocket_messages;
diff --git a/src/utils/update_positions.wgsl b/src/utils/update_positions.wgsl
index a3e63893..f2830feb 100644
--- a/src/utils/update_positions.wgsl
+++ b/src/utils/update_positions.wgsl
@@ -1,52 +1,31 @@
-struct Node {
+struct PositionUpdate {
     position: vec3<f32>,  // 12 bytes
-    velocity: vec3<f32>,  // 12 bytes
-    mass: f32,           // 4 bytes
-    padding1: u32,       // 4 bytes
 }
 
-struct NodesBuffer {
-    nodes: array<Node>,
-}
-
-@group(0) @binding(1) var<uniform> delta_time: f32;
-@group(0) @binding(0) var<storage, read_write> nodes_buffer: NodesBuffer;
+@group(0) @binding(0) var<storage, read_write> position_updates: array<PositionUpdate>;
 
-const MIN_DISTANCE: f32 = 0.1;
-
-fn is_nan(x: f32) -> bool {
-    return x != x;
-}
-
-fn is_inf(x: f32) -> bool {
-    return abs(x) >= 3.402823466e+38;
+// Utility functions
+fn is_valid_float(x: f32) -> bool {
+    return x == x && abs(x) < 1e10;
 }
 
 fn is_valid_float3(v: vec3<f32>) -> bool {
-    return !(is_nan(v.x) || is_nan(v.y) || is_nan(v.z) || 
-             is_inf(v.x) || is_inf(v.y) || is_inf(v.z));
+    return is_valid_float(v.x) && is_valid_float(v.y) && is_valid_float(v.z);
 }
 
-@compute @workgroup_size(64)
-fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
+@compute @workgroup_size(256)  // Increased workgroup size for better throughput
+fn update_positions(@builtin(global_invocation_id) global_id: vec3<u32>) {
     let node_id = global_id.x;
-    let n_nodes = arrayLength(&nodes_buffer.nodes);
+    let n_nodes = arrayLength(&position_updates);
 
     if (node_id >= n_nodes) { return; }
 
-    var node = nodes_buffer.nodes[node_id];
+    var update = position_updates[node_id];
     
-    // Validate position and velocity
-    if (!is_valid_float3(node.position)) {
-        node.position = vec3<f32>(0.0);
-    }
-    if (!is_valid_float3(node.velocity)) {
-        node.velocity = vec3<f32>(0.0);
+    // Only validate position
+    if (!is_valid_float3(update.position)) {
+        update.position = vec3<f32>(0.0);
     }
 
-    // Update position with velocity and delta time
-    node.position = node.position + node.velocity * delta_time;
-
-    // Write back to buffer
-    nodes_buffer.nodes[node_id] = node;
+    position_updates[node_id] = update;
 }
diff --git a/src/utils/websocket_manager.rs b/src/utils/websocket_manager.rs
index 9a8dccff..ffd38125 100644
--- a/src/utils/websocket_manager.rs
+++ b/src/utils/websocket_manager.rs
@@ -1,60 +1,15 @@
 use actix_web::{web, Error, HttpRequest, HttpResponse};
 use actix_web_actors::ws;
 use actix::prelude::*;
-use log::{info, error, debug};
+use log::{info, error};
 use std::sync::{Mutex, Arc};
 use serde_json::json;
-use futures::stream::StreamExt;
-use futures::future::join_all;
-use std::error::Error as StdError;
-use bytestring::ByteString;
-use serde::Deserialize;
-use tokio::time::Duration;
+use actix_web_actors::ws::WebsocketContext;
 
 use crate::AppState;
-use crate::models::simulation_params::{SimulationMode, SimulationParams};
-use crate::utils::compression::{compress_message, decompress_message};
-use crate::utils::websocket_messages::{SendCompressedMessage, MessageHandler, OpenAIMessage};
-use crate::utils::websocket_openai::OpenAIWebSocket;
-use crate::services::graph_service::GraphService;
-
-const OPENAI_CONNECT_TIMEOUT: Duration = Duration::from_secs(5);
-
-#[derive(Deserialize, Debug)]
-#[serde(tag = "type")]
-pub enum ClientMessage {
-    #[serde(rename = "chatMessage")]
-    ChatMessage {
-        message: String,
-        #[serde(rename = "tts_provider")]
-        tts_provider: String,
-    },
-    #[serde(rename = "setSimulationMode")]
-    SetSimulationMode {
-        mode: String,
-    },
-    #[serde(rename = "recalculateLayout")]
-    RecalculateLayout {
-        params: SimulationParams,
-    },
-    #[serde(rename = "getInitialData")]
-    GetInitialData,
-    #[serde(rename = "updateFisheyeSettings")]
-    UpdateFisheyeSettings {
-        enabled: bool,
-        strength: f32,
-        focus_point: [f32; 3],
-        radius: f32,
-    },
-}
-
-/// Helper function to convert hex color to proper format
-fn format_color(color: &str) -> String {
-    let color = color.trim_matches('"')
-        .trim_start_matches("0x")
-        .trim_start_matches('#');
-    format!("#{}", color)
-}
+use crate::models::simulation_params::SimulationMode;
+use crate::handlers::{WebSocketSession, WebSocketSessionHandler};
+use crate::utils::websocket_messages::{MessageHandler, SendText, ClientMessage};
 
 /// Manages WebSocket sessions and communication.
 pub struct WebSocketManager {
@@ -72,7 +27,7 @@ impl WebSocketManager {
     }
 
     /// Initializes the WebSocketManager with a conversation ID.
-    pub async fn initialize(&self, ragflow_service: &crate::services::ragflow_service::RAGFlowService) -> Result<(), Box<dyn StdError + Send + Sync>> {
+    pub async fn initialize(&self, ragflow_service: &crate::services::ragflow_service::RAGFlowService) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
         let conversation_id = ragflow_service.create_conversation("default_user".to_string()).await?;
         let mut conv_id_lock = self.conversation_id.lock().unwrap();
         *conv_id_lock = Some(conversation_id.clone());
@@ -94,26 +49,17 @@ impl WebSocketManager {
     }
 
     /// Broadcasts a message to all connected WebSocket sessions.
-    pub async fn broadcast_message(&self, message: &str) -> Result<(), Box<dyn StdError + Send + Sync>> {
+    pub async fn broadcast_message(&self, message: &str) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
         let sessions = self.sessions.lock().unwrap().clone();
-        let futures: Vec<_> = sessions.iter()
-            .map(|session| {
-                let compressed = compress_message(message).unwrap_or_default();
-                session.send(SendCompressedMessage(compressed))
-            })
-            .collect();
-        
-        let results = join_all(futures).await;
-        for result in results {
-            if let Err(e) = result {
-                error!("Failed to broadcast message: {}", e);
-            }
+        for session in sessions {
+            let msg: SendText = SendText(message.to_string());
+            session.do_send(msg);
         }
         Ok(())
     }
 
     /// Broadcasts graph update to all connected WebSocket sessions.
-    pub async fn broadcast_graph_update(&self, graph_data: &crate::models::graph::GraphData) -> Result<(), Box<dyn StdError + Send + Sync>> {
+    pub async fn broadcast_graph_update(&self, graph_data: &crate::models::graph::GraphData) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
         let json_data = json!({
             "type": "graph_update",
             "graph_data": graph_data
@@ -123,102 +69,40 @@ impl WebSocketManager {
     }
 }
 
-/// WebSocket session actor.
-pub struct WebSocketSession {
-    state: web::Data<AppState>,
-    tts_method: String,
-    openai_ws: Option<Addr<OpenAIWebSocket>>,
-    simulation_mode: SimulationMode,
-    conversation_id: Option<Arc<Mutex<Option<String>>>>,
-}
-
-impl Actor for WebSocketSession {
-    type Context = ws::WebsocketContext<Self>;
-
-    fn started(&mut self, ctx: &mut Self::Context) {
-        let addr = ctx.address();
-        self.state.websocket_manager.sessions.lock().unwrap().push(addr.clone());
-        info!(
-            "WebSocket session started. Total sessions: {}",
-            self.state.websocket_manager.sessions.lock().unwrap().len()
-        );
-    }
-
-    fn stopped(&mut self, ctx: &mut Self::Context) {
-        let addr = ctx.address();
-        self.state.websocket_manager.sessions.lock().unwrap().retain(|session| session != &addr);
-        info!(
-            "WebSocket session stopped. Total sessions: {}",
-            self.state.websocket_manager.sessions.lock().unwrap().len()
-        );
-    }
-}
-
-impl MessageHandler for WebSocketSession {}
-
-impl Handler<SendCompressedMessage> for WebSocketSession {
-    type Result = ();
-
-    fn handle(&mut self, msg: SendCompressedMessage, ctx: &mut Self::Context) {
-        ctx.binary(msg.0);
-    }
-}
-
 impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for WebSocketSession {
-    fn handle(&mut self, msg: Result<ws::Message, ws::ProtocolError>, ctx: &mut Self::Context) {
+    fn handle(&mut self, msg: Result<ws::Message, ws::ProtocolError>, ctx: &mut WebsocketContext<Self>) {
         match msg {
-            Ok(ws::Message::Ping(msg)) => ctx.pong(&msg),
+            Ok(ws::Message::Ping(msg)) => {
+                let ctx: &mut WebsocketContext<WebSocketSession> = ctx;
+                ctx.pong(&msg);
+            },
             Ok(ws::Message::Pong(_)) => (),
             Ok(ws::Message::Text(text)) => {
                 match serde_json::from_str::<ClientMessage>(&text) {
                     Ok(client_msg) => match client_msg {
-                        ClientMessage::ChatMessage { message, tts_provider } => {
-                            self.handle_chat_message(ctx, message, tts_provider == "openai");
+                        ClientMessage::ChatMessage { message, use_openai } => {
+                            WebSocketSessionHandler::handle_chat_message(self, ctx, message, use_openai);
                         },
                         ClientMessage::SetSimulationMode { mode } => {
-                            self.handle_simulation(ctx, &mode);
+                            WebSocketSessionHandler::handle_simulation_mode(self, ctx, &mode);
                         },
                         ClientMessage::RecalculateLayout { params } => {
-                            self.handle_layout(ctx, params);
+                            WebSocketSessionHandler::handle_layout(self, ctx, params);
                         },
                         ClientMessage::GetInitialData => {
-                            self.handle_initial_data(ctx);
+                            WebSocketSessionHandler::handle_initial_data(self, ctx);
                         },
                         ClientMessage::UpdateFisheyeSettings { enabled, strength, focus_point, radius } => {
-                            let state = self.state.clone();
-                            let ctx_addr = ctx.address();
-                            
-                            ctx.spawn(async move {
-                                if let Some(gpu_compute) = &state.gpu_compute {
-                                    let mut gpu = gpu_compute.write().await;
-                                    gpu.update_fisheye_params(enabled, strength, focus_point, radius);
-                                    
-                                    let response = json!({
-                                        "type": "fisheye_settings_updated",
-                                        "enabled": enabled,
-                                        "strength": strength,
-                                        "focus_point": focus_point,
-                                        "radius": radius
-                                    });
-                                    if let Ok(response_str) = serde_json::to_string(&response) {
-                                        if let Ok(compressed) = compress_message(&response_str) {
-                                            ctx_addr.do_send(SendCompressedMessage(compressed));
-                                        }
-                                    }
-                                } else {
-                                    error!("GPU compute service not available");
-                                    let error_message = json!({
-                                        "type": "error",
-                                        "message": "GPU compute service not available"
-                                    });
-                                    if let Ok(error_str) = serde_json::to_string(&error_message) {
-                                        if let Ok(compressed) = compress_message(&error_str) {
-                                            ctx_addr.do_send(SendCompressedMessage(compressed));
-                                        }
-                                    }
-                                }
-                            }.into_actor(self));
+                            WebSocketSessionHandler::handle_fisheye_settings(self, ctx, enabled, strength, focus_point, radius);
                         },
+                        _ => {
+                            error!("Unhandled client message type");
+                            let error_message = json!({
+                                "type": "error",
+                                "message": "Unhandled message type"
+                            });
+                            MessageHandler::send_json_response(self, error_message, ctx);
+                        }
                     },
                     Err(e) => {
                         error!("Failed to parse client message: {}", e);
@@ -226,15 +110,35 @@ impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for WebSocketSession
                             "type": "error",
                             "message": format!("Invalid message format: {}", e)
                         });
-                        self.send_json_response(error_message, ctx);
+                        MessageHandler::send_json_response(self, error_message, ctx);
                     }
                 }
             },
             Ok(ws::Message::Binary(bin)) => {
-                if let Ok(text) = decompress_message(&bin) {
-                    StreamHandler::handle(self, Ok(ws::Message::Text(ByteString::from(text))), ctx);
-                } else {
-                    error!("Failed to decompress binary message");
+                if let Some(gpu_compute) = &self.state.gpu_compute {
+                    let gpu = gpu_compute.clone();
+                    let bin_data = bin.to_vec();
+                    let ctx_addr = ctx.address();
+
+                    ctx.spawn(
+                        async move {
+                            let mut gpu = gpu.write().await;
+                            if let Err(e) = gpu.update_positions(&bin_data).await {
+                                error!("Failed to update node positions: {}", e);
+                                let error_message = json!({
+                                    "type": "error",
+                                    "message": format!("Failed to update node positions: {}", e)
+                                });
+                                if let Ok(error_str) = serde_json::to_string(&error_message) {
+                                    let msg: SendText = SendText(error_str);
+                                    ctx_addr.do_send(msg);
+                                }
+                            }
+                            let msg: SendText = SendText("Position update complete".to_string());
+                            ctx_addr.do_send(msg);
+                        }
+                        .into_actor(self)
+                    );
                 }
             },
             Ok(ws::Message::Close(reason)) => {
@@ -249,244 +153,3 @@ impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for WebSocketSession
         }
     }
 }
-
-impl WebSocketSession {
-    fn handle_chat_message(&mut self, ctx: &mut ws::WebsocketContext<Self>, message: String, use_openai: bool) {
-        let state = self.state.clone();
-        let conversation_id = self.conversation_id.clone();
-        let ctx_addr = ctx.address();
-        let settings = self.state.settings.clone();
-        
-        ctx.spawn(async move {
-            let conv_id = if let Some(conv_arc) = conversation_id {
-                if let Some(id) = conv_arc.lock().unwrap().clone() {
-                    id
-                } else {
-                    match state.ragflow_service.create_conversation("default_user".to_string()).await {
-                        Ok(new_id) => new_id,
-                        Err(e) => {
-                            error!("Failed to create conversation: {}", e);
-                            return;
-                        }
-                    }
-                }
-            } else {
-                error!("No conversation ID available");
-                return;
-            };
-
-            match state.ragflow_service.send_message(
-                conv_id.clone(),
-                message.clone(),
-                false,
-                None,
-                false,
-            ).await {
-                Ok(mut stream) => {
-                    debug!("RAGFlow service initialized for conversation {}", conv_id);
-                    
-                    if let Some(result) = stream.next().await {
-                        match result {
-                            Ok(text) => {
-                                debug!("Received text response from RAGFlow: {}", text);
-                                
-                                if use_openai {
-                                    debug!("Creating OpenAI WebSocket for TTS");
-                                    let openai_ws = OpenAIWebSocket::new(ctx_addr.clone(), settings);
-                                    let addr = openai_ws.start();
-                                    
-                                    debug!("Waiting for OpenAI WebSocket to be ready");
-                                    tokio::time::sleep(OPENAI_CONNECT_TIMEOUT).await;
-                                    
-                                    debug!("Sending text to OpenAI TTS: {}", text);
-                                    addr.do_send(OpenAIMessage(text));
-                                } else {
-                                    debug!("Using local TTS service");
-                                    if let Err(e) = state.speech_service.send_message(text).await {
-                                        error!("Failed to generate speech: {}", e);
-                                        let error_message = json!({
-                                            "type": "error",
-                                            "message": format!("Failed to generate speech: {}", e)
-                                        });
-                                        if let Ok(error_str) = serde_json::to_string(&error_message) {
-                                            if let Ok(compressed) = compress_message(&error_str) {
-                                                ctx_addr.do_send(SendCompressedMessage(compressed));
-                                            }
-                                        }
-                                    }
-                                }
-                            },
-                            Err(e) => {
-                                error!("Error processing RAGFlow response: {}", e);
-                                let error_message = json!({
-                                    "type": "error",
-                                    "message": format!("Error processing RAGFlow response: {}", e)
-                                });
-                                if let Ok(error_str) = serde_json::to_string(&error_message) {
-                                    if let Ok(compressed) = compress_message(&error_str) {
-                                        ctx_addr.do_send(SendCompressedMessage(compressed));
-                                    }
-                                }
-                            }
-                        }
-                    }
-                },
-                Err(e) => {
-                    error!("Failed to send message to RAGFlow: {}", e);
-                    let error_message = json!({
-                        "type": "error",
-                        "message": format!("Failed to send message to RAGFlow: {}", e)
-                    });
-                    if let Ok(error_str) = serde_json::to_string(&error_message) {
-                        if let Ok(compressed) = compress_message(&error_str) {
-                            ctx_addr.do_send(SendCompressedMessage(compressed));
-                        }
-                    }
-                }
-            }
-        }.into_actor(self));
-    }
-
-    fn handle_simulation(&mut self, ctx: &mut ws::WebsocketContext<Self>, mode: &str) {
-        self.simulation_mode = match mode {
-            "remote" => {
-                info!("Simulation mode set to Remote (GPU-accelerated)");
-                SimulationMode::Remote
-            },
-            "gpu" => {
-                info!("Simulation mode set to GPU (local)");
-                SimulationMode::GPU
-            },
-            "local" => {
-                info!("Simulation mode set to Local (CPU)");
-                SimulationMode::Local
-            },
-            _ => {
-                error!("Invalid simulation mode: {}, defaulting to Remote", mode);
-                SimulationMode::Remote
-            }
-        };
-
-        let response = json!({
-            "type": "simulation_mode_set",
-            "mode": mode,
-            "gpu_enabled": matches!(self.simulation_mode, SimulationMode::Remote | SimulationMode::GPU)
-        });
-        self.send_json_response(response, ctx);
-    }
-
-    fn handle_layout(&mut self, ctx: &mut ws::WebsocketContext<Self>, params: SimulationParams) {
-        let state = self.state.clone();
-        let simulation_mode = self.simulation_mode.clone();
-        let ctx_addr = ctx.address();
-        
-        ctx.spawn(async move {
-            let mut graph_data = state.graph_data.write().await;
-            
-            let result = match simulation_mode {
-                SimulationMode::Remote => {
-                    if let Some(gpu_compute) = &state.gpu_compute {
-                        GraphService::calculate_layout(
-                            &Some(gpu_compute.clone()),
-                            &mut *graph_data,
-                            &params
-                        ).await
-                    } else {
-                        GraphService::calculate_layout(
-                            &None,
-                            &mut *graph_data,
-                            &params
-                        ).await
-                    }
-                },
-                _ => GraphService::calculate_layout(
-                    &None,
-                    &mut *graph_data,
-                    &params
-                ).await,
-            };
-
-            match result {
-                Ok(_) => {
-                    let response = json!({
-                        "type": "layout_update",
-                        "graph_data": &*graph_data
-                    });
-                    if let Ok(response_str) = serde_json::to_string(&response) {
-                        if let Ok(compressed) = compress_message(&response_str) {
-                            ctx_addr.do_send(SendCompressedMessage(compressed));
-                        }
-                    }
-                },
-                Err(e) => {
-                    error!("Failed to recalculate layout: {}", e);
-                    let error_message = json!({
-                        "type": "error",
-                        "message": format!("Layout calculation failed: {}", e)
-                    });
-                    if let Ok(error_str) = serde_json::to_string(&error_message) {
-                        if let Ok(compressed) = compress_message(&error_str) {
-                            ctx_addr.do_send(SendCompressedMessage(compressed));
-                        }
-                    }
-                }
-            }
-        }.into_actor(self));
-    }
-
-    fn handle_initial_data(&mut self, ctx: &mut ws::WebsocketContext<Self>) {
-        let state = self.state.clone();
-        let ctx_addr = ctx.address();
-        
-        ctx.spawn(async move {
-            let graph_data = state.graph_data.read().await;
-            let settings = state.settings.read().await;
-            
-            let response = json!({
-                "type": "getInitialData",
-                "graph_data": &*graph_data,
-                "settings": {
-                    "visualization": {
-                        "nodeColor": format_color(&settings.visualization.node_color),
-                        "edgeColor": format_color(&settings.visualization.edge_color),
-                        "hologramColor": format_color(&settings.visualization.hologram_color),
-                        "nodeSizeScalingFactor": settings.visualization.node_size_scaling_factor,
-                        "hologramScale": settings.visualization.hologram_scale,
-                        "hologramOpacity": settings.visualization.hologram_opacity,
-                        "edgeOpacity": settings.visualization.edge_opacity,
-                        "labelFontSize": settings.visualization.label_font_size,
-                        "fogDensity": settings.visualization.fog_density,
-                        "forceDirectedIterations": settings.visualization.force_directed_iterations,
-                        "forceDirectedRepulsion": settings.visualization.force_directed_repulsion,
-                        "forceDirectedAttraction": settings.visualization.force_directed_attraction,
-                    },
-                    "bloom": {
-                        "nodeBloomStrength": settings.bloom.node_bloom_strength,
-                        "nodeBloomRadius": settings.bloom.node_bloom_radius,
-                        "nodeBloomThreshold": settings.bloom.node_bloom_threshold,
-                        "edgeBloomStrength": settings.bloom.edge_bloom_strength,
-                        "edgeBloomRadius": settings.bloom.edge_bloom_radius,
-                        "edgeBloomThreshold": settings.bloom.edge_bloom_threshold,
-                        "environmentBloomStrength": settings.bloom.environment_bloom_strength,
-                        "environmentBloomRadius": settings.bloom.environment_bloom_radius,
-                        "environmentBloomThreshold": settings.bloom.environment_bloom_threshold,
-                    },
-                    "fisheye": {
-                        "enabled": settings.fisheye.enabled,
-                        "strength": settings.fisheye.strength,
-                        "focusPoint": settings.fisheye.focus_point,
-                        "radius": settings.fisheye.radius,
-                    }
-                }
-            });
-
-            debug!("Sending initial data response: {:?}", response);
-
-            if let Ok(response_str) = serde_json::to_string(&response) {
-                if let Ok(compressed) = compress_message(&response_str) {
-                    ctx_addr.do_send(SendCompressedMessage(compressed));
-                }
-            }
-        }.into_actor(self));
-    }
-}
diff --git a/src/utils/websocket_messages.rs b/src/utils/websocket_messages.rs
index 6420a9fb..bcf99271 100644
--- a/src/utils/websocket_messages.rs
+++ b/src/utils/websocket_messages.rs
@@ -4,7 +4,7 @@ use serde_json::{json, Value};
 use crate::models::simulation_params::SimulationParams;
 use actix_web_actors::ws;
 use log::{error, debug};
-use crate::utils::compression::compress_message;
+use bytestring::ByteString;
 
 /// Helper function to convert hex color to proper format
 fn format_color(color: &str) -> String {
@@ -14,31 +14,57 @@ fn format_color(color: &str) -> String {
     format!("#{}", color)
 }
 
-/// Represents messages sent to the client as compressed binary data.
+/// GPU-computed node positions
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct GPUPositionUpdate {
+    pub positions: Vec<[f32; 3]>
+}
+
+/// Message for sending text data
+#[derive(Message)]
+#[rtype(result = "()")]
+pub struct SendText(pub String);
+
+/// Message for sending binary data
+#[derive(Message)]
+#[rtype(result = "()")]
+pub struct SendBinary(pub Vec<u8>);
+
+/// Message for OpenAI text-to-speech
+#[derive(Message)]
+#[rtype(result = "()")]
+pub struct OpenAIMessage(pub String);
+
+/// Message indicating OpenAI connection success
 #[derive(Message)]
 #[rtype(result = "()")]
-pub struct SendCompressedMessage(pub Vec<u8>);
+pub struct OpenAIConnected;
+
+/// Message indicating OpenAI connection failure
+#[derive(Message)]
+#[rtype(result = "()")]
+pub struct OpenAIConnectionFailed;
 
 /// Represents messages sent from the client.
 #[derive(Serialize, Deserialize, Debug)]
 #[serde(tag = "type")]
 pub enum ClientMessage {
-    #[serde(rename = "set_tts_method")]
+    #[serde(rename = "setTtsMethod")]
     SetTTSMethod { method: String },
     
-    #[serde(rename = "chat_message")]
+    #[serde(rename = "chatMessage")]
     ChatMessage { 
         message: String, 
         use_openai: bool 
     },
     
-    #[serde(rename = "get_initial_data")]
+    #[serde(rename = "getInitialData")]
     GetInitialData,
     
-    #[serde(rename = "set_simulation_mode")]
+    #[serde(rename = "setSimulationMode")]
     SetSimulationMode { mode: String },
     
-    #[serde(rename = "recalculate_layout")]
+    #[serde(rename = "recalculateLayout")]
     RecalculateLayout { params: SimulationParams },
     
     #[serde(rename = "ragflowQuery")]
@@ -64,17 +90,17 @@ pub enum ClientMessage {
 #[derive(Serialize, Deserialize, Debug)]
 #[serde(tag = "type")]
 pub enum ServerMessage {
-    #[serde(rename = "audio_data")]
+    #[serde(rename = "audioData")]
     AudioData {
         audio_data: String // base64 encoded audio
     },
     
-    #[serde(rename = "ragflow_response")]
+    #[serde(rename = "ragflowResponse")]
     RagflowResponse {
         answer: String
     },
     
-    #[serde(rename = "openai_response")]
+    #[serde(rename = "openaiResponse")]
     OpenAIResponse {
         response: String,
         audio: Option<String> // base64 encoded audio
@@ -86,54 +112,35 @@ pub enum ServerMessage {
         code: Option<String>
     },
     
-    #[serde(rename = "graph_update")]
+    #[serde(rename = "graphUpdate")]
     GraphUpdate {
         graph_data: Value
     },
     
-    #[serde(rename = "simulation_mode_set")]
+    #[serde(rename = "simulationModeSet")]
     SimulationModeSet {
         mode: String,
         gpu_enabled: bool
     },
 
-    #[serde(rename = "fisheye_settings_updated")]
+    #[serde(rename = "fisheyeSettingsUpdated")]
     FisheyeSettingsUpdated {
         enabled: bool,
         strength: f32,
         focus_point: [f32; 3],
         radius: f32,
-    }
-}
-
-#[derive(Message)]
-#[rtype(result = "()")]
-pub struct OpenAIConnected;
-
-#[derive(Message)]
-#[rtype(result = "()")]
-pub struct OpenAIConnectionFailed;
+    },
 
-#[derive(Message)]
-#[rtype(result = "()")]
-pub struct OpenAIMessage(pub String);
+    #[serde(rename = "gpuPositions")]
+    GPUPositions(GPUPositionUpdate)
+}
 
 pub trait MessageHandler: Actor<Context = ws::WebsocketContext<Self>> {
     fn send_json_response(&self, response: Value, ctx: &mut ws::WebsocketContext<Self>) {
         match serde_json::to_string(&response) {
             Ok(json_string) => {
                 debug!("Sending JSON response: {}", json_string);
-                match compress_message(&json_string) {
-                    Ok(compressed) => {
-                        debug!("Compressed response size: {} bytes", compressed.len());
-                        ctx.binary(compressed)
-                    },
-                    Err(e) => {
-                        error!("Failed to compress JSON response: {}", e);
-                        // Fallback to uncompressed JSON if compression fails
-                        ctx.text(json_string);
-                    }
-                }
+                ctx.text(ByteString::from(json_string));
             },
             Err(e) => {
                 error!("Failed to serialize JSON response: {}", e);
@@ -143,7 +150,7 @@ pub trait MessageHandler: Actor<Context = ws::WebsocketContext<Self>> {
                     "code": "SERIALIZATION_ERROR"
                 });
                 if let Ok(error_string) = serde_json::to_string(&error_message) {
-                    ctx.text(error_string);
+                    ctx.text(ByteString::from(error_string));
                 }
             }
         }
@@ -205,7 +212,7 @@ mod tests {
             use_openai: true
         };
         let serialized = serde_json::to_string(&message).unwrap();
-        assert!(serialized.contains("chat_message"));
+        assert!(serialized.contains("chatMessage"));
         assert!(serialized.contains("Hello"));
 
         let fisheye_message = ClientMessage::UpdateFisheyeSettings {
@@ -225,7 +232,7 @@ mod tests {
             answer: "Test answer".to_string()
         };
         let serialized = serde_json::to_string(&message).unwrap();
-        assert!(serialized.contains("ragflow_response"));
+        assert!(serialized.contains("ragflowResponse"));
         assert!(serialized.contains("Test answer"));
 
         let fisheye_message = ServerMessage::FisheyeSettingsUpdated {
@@ -234,9 +241,13 @@ mod tests {
             focus_point: [0.0, 0.0, 0.0],
             radius: 100.0,
         };
-        let serialized = serde_json::to_string(&fisheye_message).unwrap();
-        assert!(serialized.contains("fisheye_settings_updated"));
-        assert!(serialized.contains("strength"));
+        
+        let json = serde_json::to_string(&fisheye_message).unwrap();
+        assert!(json.contains("\"type\":\"fisheye_settings_updated\""));
+        assert!(json.contains("\"enabled\":true"));
+        assert!(json.contains("\"strength\":0.5"));
+        assert!(json.contains("\"focus_point\":[0.0,0.0,0.0]"));
+        assert!(json.contains("\"radius\":100.0"));
     }
 
     #[test]
diff --git a/src/utils/websocket_openai.rs b/src/utils/websocket_openai.rs
index 5f093db4..8fd975ba 100644
--- a/src/utils/websocket_openai.rs
+++ b/src/utils/websocket_openai.rs
@@ -15,9 +15,8 @@ use tokio::net::TcpStream;
 use std::time::Instant;
 
 use crate::config::Settings;
-use crate::utils::websocket_messages::{OpenAIMessage, OpenAIConnected, OpenAIConnectionFailed, SendCompressedMessage};
-use crate::utils::websocket_manager::WebSocketSession;
-use crate::utils::compression;
+use crate::utils::websocket_messages::{OpenAIMessage, OpenAIConnected, OpenAIConnectionFailed, SendText};
+use crate::handlers::WebSocketSession;  // Updated import path
 
 const KEEPALIVE_INTERVAL: Duration = Duration::from_secs(30);
 const CONNECTION_WAIT: Duration = Duration::from_millis(500);
@@ -197,17 +196,15 @@ impl OpenAIWebSocket {
         let start_time = Instant::now();
         debug!("Preparing to send audio data to client");
 
-        // Send audio data directly without compression
+        // Send audio data as JSON
         let audio_message = json!({
             "type": "audio",
             "audio": audio_data
         });
 
-        // Convert to string first
+        // Convert to string and send
         let message_str = audio_message.to_string();
-        let compressed = compression::compress_message(&message_str)?;
-        
-        if let Err(e) = self.client_addr.try_send(SendCompressedMessage(compressed)) {
+        if let Err(e) = self.client_addr.try_send(SendText(message_str)) {
             error!("Failed to send audio data to client: {}", e);
             return Err(Box::new(WebSocketError::SendFailed(format!(
                 "Failed to send audio data to client: {}", e
@@ -227,11 +224,9 @@ impl OpenAIWebSocket {
             "message": error_msg
         });
 
-        // Convert to string first
+        // Convert to string and send
         let message_str = error_message.to_string();
-        let compressed = compression::compress_message(&message_str)?;
-        
-        if let Err(e) = self.client_addr.try_send(SendCompressedMessage(compressed)) {
+        if let Err(e) = self.client_addr.try_send(SendText(message_str)) {
             error!("Failed to send error message to client: {}", e);
             return Err(Box::new(WebSocketError::SendFailed(format!(
                 "Failed to send error message to client: {}", e
