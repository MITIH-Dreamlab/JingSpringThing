

===== ./html/app.js =====

// static/app.js

const wsProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
const ws = new WebSocket(`${wsProtocol}://${window.location.host}/ws/`);

ws.onopen = function() {
    console.log('WebSocket connection established');
};

ws.onmessage = function(event) {
    console.log('Received message:', event.data);
};

ws.onerror = function(error) {
    console.log('WebSocket error:', error);
};

ws.onclose = function() {
    console.log('WebSocket connection closed');
};


===== ./html/index.html =====

<!-- static/index.html -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebSocket Test</title>
</head>
<body>
    <h1>WebSocket Test</h1>
    <p>Open the browser console to see WebSocket messages.</p>
    <script src="app.js"></script>
</body>
</html>


===== ./server/Cargo.toml =====

[package]
name = "server"
version = "0.1.0"
edition = "2021"

[dependencies]
actix = "0.13"
actix-web = "4"
actix-web-actors = "4"
actix-files = "0.6"
env_logger = "0.10"


===== ./server/src/main.rs =====

// src/main.rs

use actix::prelude::*;
use actix_files as fs;
use actix_web::{web, App, Error, HttpRequest, HttpResponse, HttpServer, Result};
use actix_web::middleware::Logger;
use actix_web_actors::ws;

struct MyWebSocket;

impl Actor for MyWebSocket {
    type Context = ws::WebsocketContext<Self>;

    // Called when the WebSocket connection is established
    fn started(&mut self, ctx: &mut Self::Context) {
        ctx.text("Welcome!");
        println!("WebSocket connection established");
    }
}

impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for MyWebSocket {
    fn handle(
        &mut self,
        msg: Result<ws::Message, ws::ProtocolError>,
        ctx: &mut Self::Context,
    ) {
        match msg {
            Ok(ws::Message::Text(text)) => {
                println!("Received message: {}", text);
                ctx.text(format!("Echo: {}", text));
            }
            Ok(ws::Message::Binary(bin)) => ctx.binary(bin),
            Ok(ws::Message::Ping(msg)) => ctx.pong(&msg),
            Ok(ws::Message::Close(reason)) => {
                println!("WebSocket closed: {:?}", reason);
                ctx.stop();
            }
            Err(e) => {
                println!("WebSocket error: {:?}", e);
                ctx.stop();
            }
            _ => (),
        }
    }
}

async fn ws_index(req: HttpRequest, stream: web::Payload) -> Result<HttpResponse, Error> {
    println!("WebSocket connection request received");
    ws::start(MyWebSocket {}, &req, stream)
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    // Initialize logger
    env_logger::init();

    // Start HTTP server
    HttpServer::new(|| {
        App::new()
            .wrap(Logger::default())
            .route("/ws/", web::get().to(ws_index)) // WebSocket route
            .service(
                fs::Files::new("/", "./html")      // Serve static files from the "html" directory
                    .index_file("index.html"),
            )
    })
    .bind("0.0.0.0:8080")? // Bind to port 8080, matching the proxy_pass in nginx.conf
    .run()
    .await
}


===== ./nginx.conf =====

# nginx.conf

user www-data;
worker_processes auto;
error_log /var/log/nginx/error.log;
pid /run/nginx.pid;

events {
    worker_connections 1024;
}

http {
    # Comment out or remove default includes to prevent conflicts
    # include /etc/nginx/mime.types;
    # include /etc/nginx/conf.d/*.conf;
    # include /etc/nginx/sites-enabled/*;

    # Define MIME types directly if needed
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    sendfile on;
    keepalive_timeout 65;

    server {
        listen 8443 ssl;
        server_name 192.168.0.51;

        ssl_certificate /etc/nginx/ssl/selfsigned.crt;
        ssl_certificate_key /etc/nginx/ssl/selfsigned.key;

        location / {
            proxy_pass http://127.0.0.1:8080;

            # Enable WebSocket proxying
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "Upgrade";

            # Additional headers
            proxy_set_header Host $host;
            proxy_cache_bypass $http_upgrade;
        }
    }
}


===== ./all_files_and_contents.txt =====



===== ./start.sh =====

#!/bin/sh

# Start the Rust server in the background
/app/target/release/server &

# Start Nginx in the foreground
nginx -g 'daemon off;'


===== ./Dockerfile =====

# Dockerfile

# Use an NVIDIA base image (or consider switching to ubuntu:22.04 if GPU is not required)
FROM nvidia/cuda:11.7.1-runtime-ubuntu22.04

# Update package lists
RUN apt-get update -y

# Install necessary packages
RUN apt-get install -y \
    curl \
    nginx \
    openssl \
    build-essential \
    pkg-config \
    libssl-dev

# Install Rust
RUN curl https://sh.rustup.rs -sSf | sh -s -- -y

# Add Rust to PATH
ENV PATH="/root/.cargo/bin:${PATH}"

# Create application directory
WORKDIR /app

# Copy Rust server source code into the container
COPY ./server /app

# Build the Rust server
RUN cargo build --release

# Generate self-signed SSL certificate
RUN mkdir -p /etc/nginx/ssl
RUN openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
    -keyout /etc/nginx/ssl/selfsigned.key \
    -out /etc/nginx/ssl/selfsigned.crt \
    -subj "/C=US/ST=State/L=City/O=Organization/CN=localhost"

# Remove default Nginx site configuration
RUN rm -f /etc/nginx/sites-enabled/default /etc/nginx/conf.d/*

# Copy your custom nginx.conf to the correct location
COPY ./nginx.conf /etc/nginx/nginx.conf

# Copy the html directory into /app/html
COPY ./html /app/html

# Copy the startup script
COPY start.sh /start.sh
RUN chmod +x /start.sh

# Expose port 8443
EXPOSE 8443

# Set the entrypoint to the startup script
ENTRYPOINT ["/start.sh"]
machinelearn@MLAI:/mnt/mldata/githubs/webSockTest$ docker stop websocktest
Error response from daemon: No such container: websocktest
machinelearn@MLAI:/mnt/mldata/githubs/webSockTest$ docker logs websocktest
Error response from daemon: No such container: websocktest
machinelearn@MLAI:/mnt/mldata/githubs/webSockTest$ cat 
all_files_and_contents.txt  html/                       server/                     
Dockerfile                  nginx.conf                  start.sh                    
machinelearn@MLAI:/mnt/mldata/githubs/webSockTest$ cat all_files_and_contents.txt 


===== ./html/app.js =====

// static/app.js

const wsProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
const ws = new WebSocket(`${wsProtocol}://${window.location.host}/ws/`);

ws.onopen = function() {
    console.log('WebSocket connection established');
};

ws.onmessage = function(event) {
    console.log('Received message:', event.data);
};

ws.onerror = function(error) {
    console.log('WebSocket error:', error);
};

ws.onclose = function() {
    console.log('WebSocket connection closed');
};


===== ./html/index.html =====

<!-- static/index.html -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebSocket Test</title>
</head>
<body>
    <h1>WebSocket Test</h1>
    <p>Open the browser console to see WebSocket messages.</p>
    <script src="app.js"></script>
</body>
</html>


===== ./server/Cargo.toml =====

[package]
name = "server"
version = "0.1.0"
edition = "2021"

[dependencies]
actix = "0.13"
actix-web = "4"
actix-web-actors = "4"
actix-files = "0.6"
env_logger = "0.10"


===== ./server/src/main.rs =====

// src/main.rs

use actix::prelude::*;
use actix_files as fs;
use actix_web::{web, App, Error, HttpRequest, HttpResponse, HttpServer, Result};
use actix_web::middleware::Logger;
use actix_web_actors::ws;

struct MyWebSocket;

impl Actor for MyWebSocket {
    type Context = ws::WebsocketContext<Self>;

    // Called when the WebSocket connection is established
    fn started(&mut self, ctx: &mut Self::Context) {
        ctx.text("Welcome!");
        println!("WebSocket connection established");
    }
}

impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for MyWebSocket {
    fn handle(
        &mut self,
        msg: Result<ws::Message, ws::ProtocolError>,
        ctx: &mut Self::Context,
    ) {
        match msg {
            Ok(ws::Message::Text(text)) => {
                println!("Received message: {}", text);
                ctx.text(format!("Echo: {}", text));
            }
            Ok(ws::Message::Binary(bin)) => ctx.binary(bin),
            Ok(ws::Message::Ping(msg)) => ctx.pong(&msg),
            Ok(ws::Message::Close(reason)) => {
                println!("WebSocket closed: {:?}", reason);
                ctx.stop();
            }
            Err(e) => {
                println!("WebSocket error: {:?}", e);
                ctx.stop();
            }
            _ => (),
        }
    }
}

async fn ws_index(req: HttpRequest, stream: web::Payload) -> Result<HttpResponse, Error> {
    println!("WebSocket connection request received");
    ws::start(MyWebSocket {}, &req, stream)
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    // Initialize logger
    env_logger::init();

    // Start HTTP server
    HttpServer::new(|| {
        App::new()
            .wrap(Logger::default())
            .route("/ws/", web::get().to(ws_index)) // WebSocket route
            .service(
                fs::Files::new("/", "./html")      // Serve static files from the "html" directory
                    .index_file("index.html"),
            )
    })
    .bind("0.0.0.0:8080")? // Bind to port 8080, matching the proxy_pass in nginx.conf
    .run()
    .await
}


===== ./nginx.conf =====

# nginx.conf

user www-data;
worker_processes auto;
error_log /var/log/nginx/error.log;
pid /run/nginx.pid;

events {
    worker_connections 1024;
}

http {
    # Comment out or remove default includes to prevent conflicts
    # include /etc/nginx/mime.types;
    # include /etc/nginx/conf.d/*.conf;
    # include /etc/nginx/sites-enabled/*;

    # Define MIME types directly if needed
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    sendfile on;
    keepalive_timeout 65;

    server {
        listen 8443 ssl;
        server_name 192.168.0.51;

        ssl_certificate /etc/nginx/ssl/selfsigned.crt;
        ssl_certificate_key /etc/nginx/ssl/selfsigned.key;

        location / {
            proxy_pass http://127.0.0.1:8080;

            # Enable WebSocket proxying
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "Upgrade";

            # Additional headers
            proxy_set_header Host $host;
            proxy_cache_bypass $http_upgrade;
        }
    }
}


===== ./all_files_and_contents.txt =====



===== ./start.sh =====

#!/bin/sh

# Start the Rust server in the background
/app/target/release/server &

# Start Nginx in the foreground
nginx -g 'daemon off;'


===== ./Dockerfile =====

# Dockerfile

# Use an NVIDIA base image (or consider switching to ubuntu:22.04 if GPU is not required)
FROM nvidia/cuda:11.7.1-runtime-ubuntu22.04

# Update package lists
RUN apt-get update -y

# Install necessary packages
RUN apt-get install -y \
    curl \
    nginx \
    openssl \
    build-essential \
    pkg-config \
    libssl-dev

# Install Rust
RUN curl https://sh.rustup.rs -sSf | sh -s -- -y

# Add Rust to PATH
ENV PATH="/root/.cargo/bin:${PATH}"

# Create application directory
WORKDIR /app

# Copy Rust server source code into the container
COPY ./server /app

# Build the Rust server
RUN cargo build --release

# Generate self-signed SSL certificate
RUN mkdir -p /etc/nginx/ssl
RUN openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
    -keyout /etc/nginx/ssl/selfsigned.key \
    -out /etc/nginx/ssl/selfsigned.crt \
    -subj "/C=US/ST=State/L=City/O=Organization/CN=localhost"

# Remove default Nginx site configuration
RUN rm -f /etc/nginx/sites-enabled/default /etc/nginx/conf.d/*

# Copy your custom nginx.conf to the correct location
COPY ./nginx.conf /etc/nginx/nginx.conf

# Copy the html directory into /app/html
COPY ./html /app/html

# Copy the startup script
COPY start.sh /start.sh
RUN chmod +x /start.sh

# Expose port 8443
EXPOSE 8443

# Set the entrypoint to the startup script
ENTRYPOINT ["/start.sh"]
